import { __assign, __awaiter, __generator, __read } from "tslib";
import { SignatureV4 } from "@aws-sdk/signature-v4";
export function resolveAwsAuthConfig(input) {
    var _this = this;
    var credentials = input.credentials || input.credentialDefaultProvider(input);
    var normalizedCreds = normalizeProvider(credentials);
    var _a = input.signingEscapePath, signingEscapePath = _a === void 0 ? true : _a, _b = input.systemClockOffset, systemClockOffset = _b === void 0 ? input.systemClockOffset || 0 : _b, sha256 = input.sha256;
    var signer;
    if (input.signer) {
        //if signer is supplied by user, normalize it to a function returning a promise for signer.
        signer = normalizeProvider(input.signer);
    }
    else {
        //construct a provider inferring signing from region.
        signer = function () {
            return normalizeProvider(input.region)()
                .then(function (region) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, input.regionInfoProvider(region)];
                    case 1: return [2 /*return*/, [(_a.sent()) || {}, region]];
                }
            }); }); })
                .then(function (_a) {
                var _b = __read(_a, 2), regionInfo = _b[0], region = _b[1];
                var signingRegion = regionInfo.signingRegion, signingService = regionInfo.signingService;
                //update client's singing region and signing service config if they are resolved.
                //signing region resolving order: user supplied signingRegion -> endpoints.json inferred region -> client region
                input.signingRegion = input.signingRegion || signingRegion || region;
                input.signingName = input.signingName || signingService || input.serviceId;
                return new SignatureV4({
                    credentials: normalizedCreds,
                    region: input.signingRegion,
                    service: input.signingName,
                    sha256: sha256,
                    uriEscapePath: signingEscapePath,
                });
            });
        };
    }
    return __assign(__assign({}, input), { systemClockOffset: systemClockOffset,
        signingEscapePath: signingEscapePath, credentials: normalizedCreds, signer: signer });
}
function normalizeProvider(input) {
    if (typeof input === "object") {
        var promisified_1 = Promise.resolve(input);
        return function () { return promisified_1; };
    }
    return input;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZmlndXJhdGlvbnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvY29uZmlndXJhdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQTRDcEQsTUFBTSxVQUFVLG9CQUFvQixDQUFJLEtBQWtEO0lBQTFGLGlCQXFDQztJQXBDQyxJQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsV0FBVyxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxLQUFZLENBQUMsQ0FBQztJQUN2RixJQUFNLGVBQWUsR0FBRyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUMvQyxJQUFBLEtBQXVGLEtBQUssa0JBQXBFLEVBQXhCLGlCQUFpQixtQkFBRyxJQUFJLEtBQUEsRUFBRSxLQUE2RCxLQUFLLGtCQUFsQixFQUFoRCxpQkFBaUIsbUJBQUcsS0FBSyxDQUFDLGlCQUFpQixJQUFJLENBQUMsS0FBQSxFQUFFLE1BQU0sR0FBSyxLQUFLLE9BQVYsQ0FBVztJQUNyRyxJQUFJLE1BQStCLENBQUM7SUFDcEMsSUFBSSxLQUFLLENBQUMsTUFBTSxFQUFFO1FBQ2hCLDJGQUEyRjtRQUMzRixNQUFNLEdBQUcsaUJBQWlCLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQzFDO1NBQU07UUFDTCxxREFBcUQ7UUFDckQsTUFBTSxHQUFHO1lBQ1AsT0FBQSxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUU7aUJBQzlCLElBQUksQ0FBQyxVQUFPLE1BQU07OzRCQUFPLHFCQUFNLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsRUFBQTs0QkFBeEMsc0JBQUEsQ0FBQyxDQUFDLFNBQXNDLENBQUMsSUFBSSxFQUFFLEVBQUUsTUFBTSxDQUF5QixFQUFBOztxQkFBQSxDQUFDO2lCQUN4RyxJQUFJLENBQUMsVUFBQyxFQUFvQjtvQkFBcEIsS0FBQSxhQUFvQixFQUFuQixVQUFVLFFBQUEsRUFBRSxNQUFNLFFBQUE7Z0JBQ2hCLElBQUEsYUFBYSxHQUFxQixVQUFVLGNBQS9CLEVBQUUsY0FBYyxHQUFLLFVBQVUsZUFBZixDQUFnQjtnQkFDckQsaUZBQWlGO2dCQUNqRixnSEFBZ0g7Z0JBQ2hILEtBQUssQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDLGFBQWEsSUFBSSxhQUFhLElBQUksTUFBTSxDQUFDO2dCQUNyRSxLQUFLLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQyxXQUFXLElBQUksY0FBYyxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUM7Z0JBRTNFLE9BQU8sSUFBSSxXQUFXLENBQUM7b0JBQ3JCLFdBQVcsRUFBRSxlQUFlO29CQUM1QixNQUFNLEVBQUUsS0FBSyxDQUFDLGFBQWE7b0JBQzNCLE9BQU8sRUFBRSxLQUFLLENBQUMsV0FBVztvQkFDMUIsTUFBTSxRQUFBO29CQUNOLGFBQWEsRUFBRSxpQkFBaUI7aUJBQ2pDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQztRQWhCSixDQWdCSSxDQUFDO0tBQ1I7SUFFRCw2QkFDSyxLQUFLLEtBQ1IsaUJBQWlCLG1CQUFBO1FBQ2pCLGlCQUFpQixtQkFBQSxFQUNqQixXQUFXLEVBQUUsZUFBZSxFQUM1QixNQUFNLFFBQUEsSUFDTjtBQUNKLENBQUM7QUFFRCxTQUFTLGlCQUFpQixDQUFJLEtBQXNCO0lBQ2xELElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO1FBQzdCLElBQU0sYUFBVyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0MsT0FBTyxjQUFNLE9BQUEsYUFBVyxFQUFYLENBQVcsQ0FBQztLQUMxQjtJQUNELE9BQU8sS0FBb0IsQ0FBQztBQUM5QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2lnbmF0dXJlVjQgfSBmcm9tIFwiQGF3cy1zZGsvc2lnbmF0dXJlLXY0XCI7XG5pbXBvcnQgeyBDcmVkZW50aWFscywgSGFzaENvbnN0cnVjdG9yLCBQcm92aWRlciwgUmVnaW9uSW5mbywgUmVnaW9uSW5mb1Byb3ZpZGVyLCBSZXF1ZXN0U2lnbmVyIH0gZnJvbSBcIkBhd3Mtc2RrL3R5cGVzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXdzQXV0aElucHV0Q29uZmlnIHtcbiAgLyoqXG4gICAqIFRoZSBjcmVkZW50aWFscyB1c2VkIHRvIHNpZ24gcmVxdWVzdHMuXG4gICAqL1xuICBjcmVkZW50aWFscz86IENyZWRlbnRpYWxzIHwgUHJvdmlkZXI8Q3JlZGVudGlhbHM+O1xuXG4gIC8qKlxuICAgKiBUaGUgc2lnbmVyIHRvIHVzZSB3aGVuIHNpZ25pbmcgcmVxdWVzdHMuXG4gICAqL1xuICBzaWduZXI/OiBSZXF1ZXN0U2lnbmVyIHwgUHJvdmlkZXI8UmVxdWVzdFNpZ25lcj47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZXNjYXBlIHJlcXVlc3QgcGF0aCB3aGVuIHNpZ25pbmcgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBzaWduaW5nRXNjYXBlUGF0aD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEFuIG9mZnNldCB2YWx1ZSBpbiBtaWxsaXNlY29uZHMgdG8gYXBwbHkgdG8gYWxsIHNpZ25pbmcgdGltZXMuXG4gICAqL1xuICBzeXN0ZW1DbG9ja09mZnNldD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIHJlZ2lvbiB3aGVyZSB5b3Ugd2FudCB0byBzaWduIHlvdXIgcmVxdWVzdCBhZ2FpbnN0LiBUaGlzXG4gICAqIGNhbiBiZSBkaWZmZXJlbnQgdG8gdGhlIHJlZ2lvbiBpbiB0aGUgZW5kcG9pbnQuXG4gICAqL1xuICBzaWduaW5nUmVnaW9uPzogc3RyaW5nO1xufVxuaW50ZXJmYWNlIFByZXZpb3VzbHlSZXNvbHZlZCB7XG4gIGNyZWRlbnRpYWxEZWZhdWx0UHJvdmlkZXI6IChpbnB1dDogYW55KSA9PiBQcm92aWRlcjxDcmVkZW50aWFscz47XG4gIHJlZ2lvbjogc3RyaW5nIHwgUHJvdmlkZXI8c3RyaW5nPjtcbiAgcmVnaW9uSW5mb1Byb3ZpZGVyOiBSZWdpb25JbmZvUHJvdmlkZXI7XG4gIHNpZ25pbmdOYW1lPzogc3RyaW5nO1xuICBzZXJ2aWNlSWQ6IHN0cmluZztcbiAgc2hhMjU2OiBIYXNoQ29uc3RydWN0b3I7XG59XG5leHBvcnQgaW50ZXJmYWNlIEF3c0F1dGhSZXNvbHZlZENvbmZpZyB7XG4gIGNyZWRlbnRpYWxzOiBQcm92aWRlcjxDcmVkZW50aWFscz47XG4gIHNpZ25lcjogUHJvdmlkZXI8UmVxdWVzdFNpZ25lcj47XG4gIHNpZ25pbmdFc2NhcGVQYXRoOiBib29sZWFuO1xuICBzeXN0ZW1DbG9ja09mZnNldDogbnVtYmVyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVBd3NBdXRoQ29uZmlnPFQ+KGlucHV0OiBUICYgQXdzQXV0aElucHV0Q29uZmlnICYgUHJldmlvdXNseVJlc29sdmVkKTogVCAmIEF3c0F1dGhSZXNvbHZlZENvbmZpZyB7XG4gIGNvbnN0IGNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHMgfHwgaW5wdXQuY3JlZGVudGlhbERlZmF1bHRQcm92aWRlcihpbnB1dCBhcyBhbnkpO1xuICBjb25zdCBub3JtYWxpemVkQ3JlZHMgPSBub3JtYWxpemVQcm92aWRlcihjcmVkZW50aWFscyk7XG4gIGNvbnN0IHsgc2lnbmluZ0VzY2FwZVBhdGggPSB0cnVlLCBzeXN0ZW1DbG9ja09mZnNldCA9IGlucHV0LnN5c3RlbUNsb2NrT2Zmc2V0IHx8IDAsIHNoYTI1NiB9ID0gaW5wdXQ7XG4gIGxldCBzaWduZXI6IFByb3ZpZGVyPFJlcXVlc3RTaWduZXI+O1xuICBpZiAoaW5wdXQuc2lnbmVyKSB7XG4gICAgLy9pZiBzaWduZXIgaXMgc3VwcGxpZWQgYnkgdXNlciwgbm9ybWFsaXplIGl0IHRvIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgcHJvbWlzZSBmb3Igc2lnbmVyLlxuICAgIHNpZ25lciA9IG5vcm1hbGl6ZVByb3ZpZGVyKGlucHV0LnNpZ25lcik7XG4gIH0gZWxzZSB7XG4gICAgLy9jb25zdHJ1Y3QgYSBwcm92aWRlciBpbmZlcnJpbmcgc2lnbmluZyBmcm9tIHJlZ2lvbi5cbiAgICBzaWduZXIgPSAoKSA9PlxuICAgICAgbm9ybWFsaXplUHJvdmlkZXIoaW5wdXQucmVnaW9uKSgpXG4gICAgICAgIC50aGVuKGFzeW5jIChyZWdpb24pID0+IFsoYXdhaXQgaW5wdXQucmVnaW9uSW5mb1Byb3ZpZGVyKHJlZ2lvbikpIHx8IHt9LCByZWdpb25dIGFzIFtSZWdpb25JbmZvLCBzdHJpbmddKVxuICAgICAgICAudGhlbigoW3JlZ2lvbkluZm8sIHJlZ2lvbl0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IHNpZ25pbmdSZWdpb24sIHNpZ25pbmdTZXJ2aWNlIH0gPSByZWdpb25JbmZvO1xuICAgICAgICAgIC8vdXBkYXRlIGNsaWVudCdzIHNpbmdpbmcgcmVnaW9uIGFuZCBzaWduaW5nIHNlcnZpY2UgY29uZmlnIGlmIHRoZXkgYXJlIHJlc29sdmVkLlxuICAgICAgICAgIC8vc2lnbmluZyByZWdpb24gcmVzb2x2aW5nIG9yZGVyOiB1c2VyIHN1cHBsaWVkIHNpZ25pbmdSZWdpb24gLT4gZW5kcG9pbnRzLmpzb24gaW5mZXJyZWQgcmVnaW9uIC0+IGNsaWVudCByZWdpb25cbiAgICAgICAgICBpbnB1dC5zaWduaW5nUmVnaW9uID0gaW5wdXQuc2lnbmluZ1JlZ2lvbiB8fCBzaWduaW5nUmVnaW9uIHx8IHJlZ2lvbjtcbiAgICAgICAgICBpbnB1dC5zaWduaW5nTmFtZSA9IGlucHV0LnNpZ25pbmdOYW1lIHx8IHNpZ25pbmdTZXJ2aWNlIHx8IGlucHV0LnNlcnZpY2VJZDtcblxuICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlVjQoe1xuICAgICAgICAgICAgY3JlZGVudGlhbHM6IG5vcm1hbGl6ZWRDcmVkcyxcbiAgICAgICAgICAgIHJlZ2lvbjogaW5wdXQuc2lnbmluZ1JlZ2lvbixcbiAgICAgICAgICAgIHNlcnZpY2U6IGlucHV0LnNpZ25pbmdOYW1lLFxuICAgICAgICAgICAgc2hhMjU2LFxuICAgICAgICAgICAgdXJpRXNjYXBlUGF0aDogc2lnbmluZ0VzY2FwZVBhdGgsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5pbnB1dCxcbiAgICBzeXN0ZW1DbG9ja09mZnNldCxcbiAgICBzaWduaW5nRXNjYXBlUGF0aCxcbiAgICBjcmVkZW50aWFsczogbm9ybWFsaXplZENyZWRzLFxuICAgIHNpZ25lcixcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUHJvdmlkZXI8VD4oaW5wdXQ6IFQgfCBQcm92aWRlcjxUPik6IFByb3ZpZGVyPFQ+IHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnN0IHByb21pc2lmaWVkID0gUHJvbWlzZS5yZXNvbHZlKGlucHV0KTtcbiAgICByZXR1cm4gKCkgPT4gcHJvbWlzaWZpZWQ7XG4gIH1cbiAgcmV0dXJuIGlucHV0IGFzIFByb3ZpZGVyPFQ+O1xufVxuIl19