"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_source_map_1 = __importDefault(require("convert-source-map"));
const defaults_1 = __importDefault(require("lodash/defaults"));
// @ts-ignore
const source_map_1 = __importDefault(require("source-map"));
const slash_1 = __importDefault(require("slash"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const util = __importStar(require("./util"));
function default_1({ cliOptions, swcOptions }) {
    return __awaiter(this, void 0, void 0, function* () {
        function buildResult(fileResults) {
            return __awaiter(this, void 0, void 0, function* () {
                const map = new source_map_1.default.SourceMapGenerator({
                    file: cliOptions.sourceMapTarget ||
                        path_1.default.basename(cliOptions.outFile || "") ||
                        "stdout",
                    sourceRoot: swcOptions.sourceRoot,
                });
                let code = "";
                let offset = 0;
                for (const result of fileResults) {
                    if (!result)
                        continue;
                    code += result.code + "\n";
                    if (result.map) {
                        const consumer = yield new source_map_1.default.SourceMapConsumer(result.map);
                        const sources = new Set();
                        consumer.eachMapping(function (mapping) {
                            if (mapping.source != null)
                                sources.add(mapping.source);
                            map.addMapping({
                                generated: {
                                    line: mapping.generatedLine + offset,
                                    column: mapping.generatedColumn,
                                },
                                source: mapping.source,
                                // @ts-ignore
                                original: mapping.source == null
                                    ? null
                                    : {
                                        line: mapping.originalLine,
                                        column: mapping.originalColumn,
                                    },
                            });
                        });
                        sources.forEach(source => {
                            const content = consumer.sourceContentFor(source, true);
                            if (content !== null) {
                                map.setSourceContent(source, content);
                            }
                        });
                        offset = code.split("\n").length - 1;
                    }
                }
                // add the inline sourcemap comment if we've either explicitly asked for inline source
                // maps, or we've requested them without any output file
                if (swcOptions.sourceMaps === "inline" ||
                    (!cliOptions.outFile && swcOptions.sourceMaps)) {
                    code += "\n" + convert_source_map_1.default.fromObject(map).toComment();
                }
                return {
                    map: map,
                    code: code,
                };
            });
        }
        function output(fileResults) {
            return __awaiter(this, void 0, void 0, function* () {
                const result = yield buildResult(fileResults);
                if (cliOptions.outFile) {
                    // we've requested for a sourcemap to be written to disk
                    if (swcOptions.sourceMaps && swcOptions.sourceMaps !== "inline") {
                        const mapLoc = cliOptions.outFile + ".map";
                        result.code = util.addSourceMappingUrl(result.code, mapLoc);
                        fs_1.default.writeFileSync(mapLoc, JSON.stringify(result.map));
                    }
                    fs_1.default.writeFileSync(cliOptions.outFile, result.code);
                }
                else {
                    process.stdout.write(result.code + "\n");
                }
            });
        }
        function readStdin() {
            return new Promise((resolve, reject) => {
                let code = "";
                process.stdin.setEncoding("utf8");
                process.stdin.on("readable", function () {
                    const chunk = process.stdin.read();
                    if (chunk !== null)
                        code += chunk;
                });
                process.stdin.on("end", function () {
                    resolve(code);
                });
                process.stdin.on("error", reject);
            });
        }
        function stdin() {
            return __awaiter(this, void 0, void 0, function* () {
                const code = yield readStdin();
                const res = yield util.transform(cliOptions.filename, code, defaults_1.default({
                    sourceFileName: "stdin",
                }, swcOptions));
                output([res]);
            });
        }
        function walk(filenames) {
            return __awaiter(this, void 0, void 0, function* () {
                const _filenames = [];
                filenames.forEach(function (filename) {
                    if (!fs_1.default.existsSync(filename))
                        return;
                    const stat = fs_1.default.statSync(filename);
                    if (stat.isDirectory()) {
                        const dirname = filename;
                        util
                            .readdirForCompilable(filename, cliOptions.includeDotfiles, cliOptions.extensions)
                            .forEach(function (filename) {
                            _filenames.push(path_1.default.join(dirname, filename));
                        });
                    }
                    else {
                        _filenames.push(filename);
                    }
                });
                const results = yield Promise.all(_filenames.map(function (filename) {
                    return __awaiter(this, void 0, void 0, function* () {
                        let sourceFilename = filename;
                        if (cliOptions.outFile) {
                            sourceFilename = path_1.default.relative(path_1.default.dirname(cliOptions.outFile), sourceFilename);
                        }
                        sourceFilename = slash_1.default(sourceFilename);
                        try {
                            return yield util.compile(filename, defaults_1.default({
                                sourceFileName: sourceFilename,
                                // Since we're compiling everything to be merged together,
                                // "inline" applies to the final output file, but to the individual
                                // files being concatenated.
                                sourceMaps: swcOptions.sourceMaps === "inline"
                                    ? true
                                    : swcOptions.sourceMaps,
                            }, swcOptions));
                        }
                        catch (err) {
                            if (!cliOptions.watch) {
                                throw err;
                            }
                            console.error(err);
                            return null;
                        }
                    });
                }));
                output(results);
            });
        }
        function files(filenames) {
            return __awaiter(this, void 0, void 0, function* () {
                yield walk(filenames);
                if (cliOptions.watch) {
                    const chokidar = util.requireChokidar();
                    chokidar
                        .watch(filenames, {
                        persistent: true,
                        ignoreInitial: true,
                        awaitWriteFinish: {
                            stabilityThreshold: 50,
                            pollInterval: 10,
                        },
                    })
                        .on("all", function (type, filename) {
                        if (!util.isCompilableExtension(filename, cliOptions.extensions)) {
                            return;
                        }
                        if (type === "add" || type === "change") {
                            if (cliOptions.verbose) {
                                console.log(type + " " + filename);
                            }
                            walk(filenames).catch(err => {
                                console.error(err);
                            });
                        }
                    });
                }
            });
        }
        if (cliOptions.filenames.length) {
            yield files(cliOptions.filenames);
        }
        else {
            yield stdin();
        }
    });
}
exports.default = default_1;
