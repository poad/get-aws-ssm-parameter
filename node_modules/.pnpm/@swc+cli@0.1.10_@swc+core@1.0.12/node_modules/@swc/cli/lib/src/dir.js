"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const defaults_1 = __importDefault(require("lodash/defaults"));
// @ts-ignore
const output_file_sync_1 = __importDefault(require("output-file-sync"));
const mkdirp_1 = require("mkdirp");
const slash_1 = __importDefault(require("slash"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const util = __importStar(require("./util"));
function default_1({ cliOptions, swcOptions }) {
    return __awaiter(this, void 0, void 0, function* () {
        const filenames = cliOptions.filenames;
        function write(src, base) {
            return __awaiter(this, void 0, void 0, function* () {
                let relative = path_1.default.relative(base, src);
                if (!util.isCompilableExtension(relative, cliOptions.extensions)) {
                    return false;
                }
                // remove extension and then append back on .js
                relative = util.adjustRelative(relative, cliOptions.keepFileExtension);
                const dest = getDest(relative, base);
                try {
                    const res = yield util.compile(src, defaults_1.default({
                        sourceFileName: slash_1.default(path_1.default.relative(dest + "/..", src)),
                    }, swcOptions));
                    if (!res)
                        return false;
                    let code = res.code;
                    // we've requested explicit sourcemaps to be written to disk
                    if (res.map) {
                        let map = JSON.parse(res.map);
                        // TODO: Handle inline source map
                        const mapLoc = dest + ".map";
                        code = util.addSourceMappingUrl(code, mapLoc);
                        map.file = path_1.default.basename(relative);
                        output_file_sync_1.default(mapLoc, JSON.stringify(map));
                    }
                    output_file_sync_1.default(dest, code);
                    util.chmod(src, dest);
                    if (cliOptions.verbose) {
                        console.log(src + " -> " + dest);
                    }
                    return true;
                }
                catch (err) {
                    if (cliOptions.watch) {
                        console.error(err);
                        return false;
                    }
                    throw err;
                }
            });
        }
        function getDest(filename, base) {
            if (cliOptions.relative) {
                return path_1.default.join(base, cliOptions.outDir, filename);
            }
            return path_1.default.join(cliOptions.outDir, filename);
        }
        function handleFile(src, base) {
            return __awaiter(this, void 0, void 0, function* () {
                const written = yield write(src, base);
                if (!written && cliOptions.copyFiles) {
                    const filename = path_1.default.relative(base, src);
                    const dest = getDest(filename, base);
                    output_file_sync_1.default(dest, fs_1.default.readFileSync(src));
                    util.chmod(src, dest);
                }
                return written;
            });
        }
        function handle(filenameOrDir) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!fs_1.default.existsSync(filenameOrDir))
                    return 0;
                const stat = fs_1.default.statSync(filenameOrDir);
                if (stat.isDirectory()) {
                    const dirname = filenameOrDir;
                    let count = 0;
                    const files = util.readdir(dirname, cliOptions.includeDotfiles);
                    for (const filename of files) {
                        const src = path_1.default.join(dirname, filename);
                        const written = yield handleFile(src, dirname);
                        if (written)
                            count += 1;
                    }
                    return count;
                }
                else {
                    const filename = filenameOrDir;
                    const written = yield handleFile(filename, path_1.default.dirname(filename));
                    return written ? 1 : 0;
                }
            });
        }
        if (cliOptions.deleteDirOnStart) {
            util.deleteDir(cliOptions.outDir);
        }
        mkdirp_1.sync(cliOptions.outDir);
        let compiledFiles = 0;
        for (const filename of cliOptions.filenames) {
            compiledFiles += yield handle(filename);
        }
        console.log(`Successfully compiled ${compiledFiles} ${compiledFiles !== 1 ? "files" : "file"} with swc.`);
        if (cliOptions.watch) {
            const chokidar = util.requireChokidar();
            filenames.forEach(function (filenameOrDir) {
                const watcher = chokidar.watch(filenameOrDir, {
                    persistent: true,
                    ignoreInitial: true,
                    awaitWriteFinish: {
                        stabilityThreshold: 50,
                        pollInterval: 10,
                    },
                });
                ["add", "change"].forEach(function (type) {
                    watcher.on(type, function (filename) {
                        handleFile(filename, filename === filenameOrDir
                            ? path_1.default.dirname(filenameOrDir)
                            : filenameOrDir).catch(err => {
                            console.error(err);
                        });
                    });
                });
            });
        }
    });
}
exports.default = default_1;
