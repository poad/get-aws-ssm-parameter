import { HttpRequest as __HttpRequest } from "@aws-sdk/protocol-http";
import { decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectString as __expectString, parseEpochTimestamp as __parseEpochTimestamp, throwDefaultError, } from "@aws-sdk/smithy-client";
import { v4 as generateIdempotencyToken } from "uuid";
import { AlreadyExistsException, AssociatedInstances, AssociationAlreadyExists, AssociationDoesNotExist, AssociationExecutionDoesNotExist, AssociationLimitExceeded, AutomationExecutionNotFoundException, DocumentAlreadyExists, DocumentLimitExceeded, DoesNotExistException, DuplicateInstanceId, IdempotentParameterMismatch, InternalServerError, InvalidActivation, InvalidActivationId, InvalidAssociationVersion, InvalidCommandId, InvalidDeleteInventoryParametersException, InvalidDeletionIdException, InvalidDocument, InvalidDocumentContent, InvalidDocumentOperation, InvalidDocumentSchemaVersion, InvalidDocumentVersion, InvalidFilter, InvalidFilterKey, InvalidFilterValue, InvalidInstanceId, InvalidInstanceInformationFilterValue, InvalidInventoryRequestException, InvalidNextToken, InvalidOptionException, InvalidOutputLocation, InvalidParameters, InvalidPermissionType, InvalidResourceId, InvalidResourceType, InvalidSchedule, InvalidTag, InvalidTarget, InvalidTargetMaps, InvalidTypeNameException, MaxDocumentSizeExceeded, OpsItemAccessDeniedException, OpsItemAlreadyExistsException, OpsItemInvalidParameterException, OpsItemLimitExceededException, OpsItemNotFoundException, OpsItemRelatedItemAlreadyExistsException, OpsMetadataAlreadyExistsException, OpsMetadataInvalidArgumentException, OpsMetadataLimitExceededException, OpsMetadataNotFoundException, OpsMetadataTooManyUpdatesException, ParameterNotFound, ResourceDataSyncAlreadyExistsException, ResourceDataSyncCountExceededException, ResourceDataSyncInvalidConfigurationException, ResourceDataSyncNotFoundException, ResourceInUseException, ResourceLimitExceededException, ResourcePolicyConflictException, ResourcePolicyInvalidParameterException, TargetInUseException, TooManyTagsError, TooManyUpdates, UnsupportedOperatingSystem, UnsupportedPlatformType, } from "../models/models_0";
import { AssociationVersionLimitExceeded, AutomationDefinitionNotApprovedException, AutomationDefinitionNotFoundException, AutomationDefinitionVersionNotFoundException, AutomationExecutionLimitExceededException, AutomationStepNotFoundException, ComplianceTypeCountLimitExceededException, CustomSchemaCountLimitExceededException, DocumentPermissionLimit, FeatureNotAvailableException, HierarchyLevelLimitExceededException, HierarchyTypeMismatchException, IncompatiblePolicyException, InvalidAggregatorException, InvalidAllowedPatternException, InvalidAssociation, InvalidAutomationExecutionParametersException, InvalidAutomationSignalException, InvalidAutomationStatusUpdateException, InvalidDocumentType, InvalidFilterOption, InvalidInventoryGroupException, InvalidInventoryItemContextException, InvalidItemContentException, InvalidKeyId, InvalidNotificationConfig, InvalidOutputFolder, InvalidPluginName, InvalidPolicyAttributeException, InvalidPolicyTypeException, InvalidResultAttributeException, InvalidRole, InvocationDoesNotExist, ItemContentMismatchException, ItemSizeLimitExceededException, OpsItemRelatedItemAssociationNotFoundException, ParameterAlreadyExists, ParameterLimitExceeded, ParameterMaxVersionLimitExceeded, ParameterPatternMismatchException, ParameterVersionLabelLimitExceeded, ParameterVersionNotFound, PoliciesLimitExceededException, ResourcePolicyLimitExceededException, ServiceSettingNotFound, SubTypeCountLimitExceededException, TargetNotConnected, TotalSizeLimitExceededException, UnsupportedCalendarException, UnsupportedFeatureRequiredException, UnsupportedInventoryItemContextException, UnsupportedInventorySchemaVersionException, UnsupportedParameterType, } from "../models/models_1";
import { DocumentVersionLimitExceeded, DuplicateDocumentContent, DuplicateDocumentVersionName, InvalidUpdate, OpsMetadataKeyLimitExceededException, ResourceDataSyncConflictException, StatusUnchanged, } from "../models/models_2";
import { SSMServiceException as __BaseException } from "../models/SSMServiceException";
export const se_AddTagsToResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.AddTagsToResource",
    };
    let body;
    body = JSON.stringify(se_AddTagsToResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateOpsItemRelatedItemCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.AssociateOpsItemRelatedItem",
    };
    let body;
    body = JSON.stringify(se_AssociateOpsItemRelatedItemRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelCommandCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.CancelCommand",
    };
    let body;
    body = JSON.stringify(se_CancelCommandRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelMaintenanceWindowExecutionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.CancelMaintenanceWindowExecution",
    };
    let body;
    body = JSON.stringify(se_CancelMaintenanceWindowExecutionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateActivationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.CreateActivation",
    };
    let body;
    body = JSON.stringify(se_CreateActivationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateAssociationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.CreateAssociation",
    };
    let body;
    body = JSON.stringify(se_CreateAssociationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateAssociationBatchCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.CreateAssociationBatch",
    };
    let body;
    body = JSON.stringify(se_CreateAssociationBatchRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateDocumentCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.CreateDocument",
    };
    let body;
    body = JSON.stringify(se_CreateDocumentRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateMaintenanceWindowCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.CreateMaintenanceWindow",
    };
    let body;
    body = JSON.stringify(se_CreateMaintenanceWindowRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateOpsItemCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.CreateOpsItem",
    };
    let body;
    body = JSON.stringify(se_CreateOpsItemRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateOpsMetadataCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.CreateOpsMetadata",
    };
    let body;
    body = JSON.stringify(se_CreateOpsMetadataRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreatePatchBaselineCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.CreatePatchBaseline",
    };
    let body;
    body = JSON.stringify(se_CreatePatchBaselineRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateResourceDataSyncCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.CreateResourceDataSync",
    };
    let body;
    body = JSON.stringify(se_CreateResourceDataSyncRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteActivationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DeleteActivation",
    };
    let body;
    body = JSON.stringify(se_DeleteActivationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteAssociationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DeleteAssociation",
    };
    let body;
    body = JSON.stringify(se_DeleteAssociationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteDocumentCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DeleteDocument",
    };
    let body;
    body = JSON.stringify(se_DeleteDocumentRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteInventoryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DeleteInventory",
    };
    let body;
    body = JSON.stringify(se_DeleteInventoryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteMaintenanceWindowCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DeleteMaintenanceWindow",
    };
    let body;
    body = JSON.stringify(se_DeleteMaintenanceWindowRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteOpsMetadataCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DeleteOpsMetadata",
    };
    let body;
    body = JSON.stringify(se_DeleteOpsMetadataRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteParameterCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DeleteParameter",
    };
    let body;
    body = JSON.stringify(se_DeleteParameterRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteParametersCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DeleteParameters",
    };
    let body;
    body = JSON.stringify(se_DeleteParametersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeletePatchBaselineCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DeletePatchBaseline",
    };
    let body;
    body = JSON.stringify(se_DeletePatchBaselineRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteResourceDataSyncCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DeleteResourceDataSync",
    };
    let body;
    body = JSON.stringify(se_DeleteResourceDataSyncRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteResourcePolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DeleteResourcePolicy",
    };
    let body;
    body = JSON.stringify(se_DeleteResourcePolicyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeregisterManagedInstanceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DeregisterManagedInstance",
    };
    let body;
    body = JSON.stringify(se_DeregisterManagedInstanceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeregisterPatchBaselineForPatchGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DeregisterPatchBaselineForPatchGroup",
    };
    let body;
    body = JSON.stringify(se_DeregisterPatchBaselineForPatchGroupRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeregisterTargetFromMaintenanceWindowCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DeregisterTargetFromMaintenanceWindow",
    };
    let body;
    body = JSON.stringify(se_DeregisterTargetFromMaintenanceWindowRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeregisterTaskFromMaintenanceWindowCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DeregisterTaskFromMaintenanceWindow",
    };
    let body;
    body = JSON.stringify(se_DeregisterTaskFromMaintenanceWindowRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeActivationsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeActivations",
    };
    let body;
    body = JSON.stringify(se_DescribeActivationsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAssociationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeAssociation",
    };
    let body;
    body = JSON.stringify(se_DescribeAssociationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAssociationExecutionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeAssociationExecutions",
    };
    let body;
    body = JSON.stringify(se_DescribeAssociationExecutionsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAssociationExecutionTargetsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeAssociationExecutionTargets",
    };
    let body;
    body = JSON.stringify(se_DescribeAssociationExecutionTargetsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAutomationExecutionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeAutomationExecutions",
    };
    let body;
    body = JSON.stringify(se_DescribeAutomationExecutionsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAutomationStepExecutionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeAutomationStepExecutions",
    };
    let body;
    body = JSON.stringify(se_DescribeAutomationStepExecutionsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAvailablePatchesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeAvailablePatches",
    };
    let body;
    body = JSON.stringify(se_DescribeAvailablePatchesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDocumentCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeDocument",
    };
    let body;
    body = JSON.stringify(se_DescribeDocumentRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDocumentPermissionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeDocumentPermission",
    };
    let body;
    body = JSON.stringify(se_DescribeDocumentPermissionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeEffectiveInstanceAssociationsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeEffectiveInstanceAssociations",
    };
    let body;
    body = JSON.stringify(se_DescribeEffectiveInstanceAssociationsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeEffectivePatchesForPatchBaselineCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeEffectivePatchesForPatchBaseline",
    };
    let body;
    body = JSON.stringify(se_DescribeEffectivePatchesForPatchBaselineRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstanceAssociationsStatusCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeInstanceAssociationsStatus",
    };
    let body;
    body = JSON.stringify(se_DescribeInstanceAssociationsStatusRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstanceInformationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeInstanceInformation",
    };
    let body;
    body = JSON.stringify(se_DescribeInstanceInformationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstancePatchesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeInstancePatches",
    };
    let body;
    body = JSON.stringify(se_DescribeInstancePatchesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstancePatchStatesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeInstancePatchStates",
    };
    let body;
    body = JSON.stringify(se_DescribeInstancePatchStatesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstancePatchStatesForPatchGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeInstancePatchStatesForPatchGroup",
    };
    let body;
    body = JSON.stringify(se_DescribeInstancePatchStatesForPatchGroupRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInventoryDeletionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeInventoryDeletions",
    };
    let body;
    body = JSON.stringify(se_DescribeInventoryDeletionsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeMaintenanceWindowExecutionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeMaintenanceWindowExecutions",
    };
    let body;
    body = JSON.stringify(se_DescribeMaintenanceWindowExecutionsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeMaintenanceWindowExecutionTaskInvocationsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeMaintenanceWindowExecutionTaskInvocations",
    };
    let body;
    body = JSON.stringify(se_DescribeMaintenanceWindowExecutionTaskInvocationsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeMaintenanceWindowExecutionTasksCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeMaintenanceWindowExecutionTasks",
    };
    let body;
    body = JSON.stringify(se_DescribeMaintenanceWindowExecutionTasksRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeMaintenanceWindowsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeMaintenanceWindows",
    };
    let body;
    body = JSON.stringify(se_DescribeMaintenanceWindowsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeMaintenanceWindowScheduleCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeMaintenanceWindowSchedule",
    };
    let body;
    body = JSON.stringify(se_DescribeMaintenanceWindowScheduleRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeMaintenanceWindowsForTargetCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeMaintenanceWindowsForTarget",
    };
    let body;
    body = JSON.stringify(se_DescribeMaintenanceWindowsForTargetRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeMaintenanceWindowTargetsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeMaintenanceWindowTargets",
    };
    let body;
    body = JSON.stringify(se_DescribeMaintenanceWindowTargetsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeMaintenanceWindowTasksCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeMaintenanceWindowTasks",
    };
    let body;
    body = JSON.stringify(se_DescribeMaintenanceWindowTasksRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeOpsItemsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeOpsItems",
    };
    let body;
    body = JSON.stringify(se_DescribeOpsItemsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeParametersCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeParameters",
    };
    let body;
    body = JSON.stringify(se_DescribeParametersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribePatchBaselinesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribePatchBaselines",
    };
    let body;
    body = JSON.stringify(se_DescribePatchBaselinesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribePatchGroupsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribePatchGroups",
    };
    let body;
    body = JSON.stringify(se_DescribePatchGroupsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribePatchGroupStateCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribePatchGroupState",
    };
    let body;
    body = JSON.stringify(se_DescribePatchGroupStateRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribePatchPropertiesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribePatchProperties",
    };
    let body;
    body = JSON.stringify(se_DescribePatchPropertiesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSessionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DescribeSessions",
    };
    let body;
    body = JSON.stringify(se_DescribeSessionsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateOpsItemRelatedItemCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.DisassociateOpsItemRelatedItem",
    };
    let body;
    body = JSON.stringify(se_DisassociateOpsItemRelatedItemRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetAutomationExecutionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetAutomationExecution",
    };
    let body;
    body = JSON.stringify(se_GetAutomationExecutionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetCalendarStateCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetCalendarState",
    };
    let body;
    body = JSON.stringify(se_GetCalendarStateRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetCommandInvocationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetCommandInvocation",
    };
    let body;
    body = JSON.stringify(se_GetCommandInvocationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetConnectionStatusCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetConnectionStatus",
    };
    let body;
    body = JSON.stringify(se_GetConnectionStatusRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetDefaultPatchBaselineCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetDefaultPatchBaseline",
    };
    let body;
    body = JSON.stringify(se_GetDefaultPatchBaselineRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetDeployablePatchSnapshotForInstanceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetDeployablePatchSnapshotForInstance",
    };
    let body;
    body = JSON.stringify(se_GetDeployablePatchSnapshotForInstanceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetDocumentCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetDocument",
    };
    let body;
    body = JSON.stringify(se_GetDocumentRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetInventoryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetInventory",
    };
    let body;
    body = JSON.stringify(se_GetInventoryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetInventorySchemaCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetInventorySchema",
    };
    let body;
    body = JSON.stringify(se_GetInventorySchemaRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetMaintenanceWindowCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetMaintenanceWindow",
    };
    let body;
    body = JSON.stringify(se_GetMaintenanceWindowRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetMaintenanceWindowExecutionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetMaintenanceWindowExecution",
    };
    let body;
    body = JSON.stringify(se_GetMaintenanceWindowExecutionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetMaintenanceWindowExecutionTaskCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetMaintenanceWindowExecutionTask",
    };
    let body;
    body = JSON.stringify(se_GetMaintenanceWindowExecutionTaskRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetMaintenanceWindowExecutionTaskInvocationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetMaintenanceWindowExecutionTaskInvocation",
    };
    let body;
    body = JSON.stringify(se_GetMaintenanceWindowExecutionTaskInvocationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetMaintenanceWindowTaskCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetMaintenanceWindowTask",
    };
    let body;
    body = JSON.stringify(se_GetMaintenanceWindowTaskRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetOpsItemCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetOpsItem",
    };
    let body;
    body = JSON.stringify(se_GetOpsItemRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetOpsMetadataCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetOpsMetadata",
    };
    let body;
    body = JSON.stringify(se_GetOpsMetadataRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetOpsSummaryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetOpsSummary",
    };
    let body;
    body = JSON.stringify(se_GetOpsSummaryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetParameterCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetParameter",
    };
    let body;
    body = JSON.stringify(se_GetParameterRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetParameterHistoryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetParameterHistory",
    };
    let body;
    body = JSON.stringify(se_GetParameterHistoryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetParametersCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetParameters",
    };
    let body;
    body = JSON.stringify(se_GetParametersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetParametersByPathCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetParametersByPath",
    };
    let body;
    body = JSON.stringify(se_GetParametersByPathRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetPatchBaselineCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetPatchBaseline",
    };
    let body;
    body = JSON.stringify(se_GetPatchBaselineRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetPatchBaselineForPatchGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetPatchBaselineForPatchGroup",
    };
    let body;
    body = JSON.stringify(se_GetPatchBaselineForPatchGroupRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetResourcePoliciesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetResourcePolicies",
    };
    let body;
    body = JSON.stringify(se_GetResourcePoliciesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetServiceSettingCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.GetServiceSetting",
    };
    let body;
    body = JSON.stringify(se_GetServiceSettingRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_LabelParameterVersionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.LabelParameterVersion",
    };
    let body;
    body = JSON.stringify(se_LabelParameterVersionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListAssociationsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ListAssociations",
    };
    let body;
    body = JSON.stringify(se_ListAssociationsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListAssociationVersionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ListAssociationVersions",
    };
    let body;
    body = JSON.stringify(se_ListAssociationVersionsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListCommandInvocationsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ListCommandInvocations",
    };
    let body;
    body = JSON.stringify(se_ListCommandInvocationsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListCommandsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ListCommands",
    };
    let body;
    body = JSON.stringify(se_ListCommandsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListComplianceItemsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ListComplianceItems",
    };
    let body;
    body = JSON.stringify(se_ListComplianceItemsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListComplianceSummariesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ListComplianceSummaries",
    };
    let body;
    body = JSON.stringify(se_ListComplianceSummariesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListDocumentMetadataHistoryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ListDocumentMetadataHistory",
    };
    let body;
    body = JSON.stringify(se_ListDocumentMetadataHistoryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListDocumentsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ListDocuments",
    };
    let body;
    body = JSON.stringify(se_ListDocumentsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListDocumentVersionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ListDocumentVersions",
    };
    let body;
    body = JSON.stringify(se_ListDocumentVersionsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListInventoryEntriesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ListInventoryEntries",
    };
    let body;
    body = JSON.stringify(se_ListInventoryEntriesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListOpsItemEventsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ListOpsItemEvents",
    };
    let body;
    body = JSON.stringify(se_ListOpsItemEventsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListOpsItemRelatedItemsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ListOpsItemRelatedItems",
    };
    let body;
    body = JSON.stringify(se_ListOpsItemRelatedItemsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListOpsMetadataCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ListOpsMetadata",
    };
    let body;
    body = JSON.stringify(se_ListOpsMetadataRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListResourceComplianceSummariesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ListResourceComplianceSummaries",
    };
    let body;
    body = JSON.stringify(se_ListResourceComplianceSummariesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListResourceDataSyncCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ListResourceDataSync",
    };
    let body;
    body = JSON.stringify(se_ListResourceDataSyncRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ListTagsForResource",
    };
    let body;
    body = JSON.stringify(se_ListTagsForResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyDocumentPermissionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ModifyDocumentPermission",
    };
    let body;
    body = JSON.stringify(se_ModifyDocumentPermissionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutComplianceItemsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.PutComplianceItems",
    };
    let body;
    body = JSON.stringify(se_PutComplianceItemsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutInventoryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.PutInventory",
    };
    let body;
    body = JSON.stringify(se_PutInventoryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutParameterCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.PutParameter",
    };
    let body;
    body = JSON.stringify(se_PutParameterRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutResourcePolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.PutResourcePolicy",
    };
    let body;
    body = JSON.stringify(se_PutResourcePolicyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RegisterDefaultPatchBaselineCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.RegisterDefaultPatchBaseline",
    };
    let body;
    body = JSON.stringify(se_RegisterDefaultPatchBaselineRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RegisterPatchBaselineForPatchGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.RegisterPatchBaselineForPatchGroup",
    };
    let body;
    body = JSON.stringify(se_RegisterPatchBaselineForPatchGroupRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RegisterTargetWithMaintenanceWindowCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.RegisterTargetWithMaintenanceWindow",
    };
    let body;
    body = JSON.stringify(se_RegisterTargetWithMaintenanceWindowRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RegisterTaskWithMaintenanceWindowCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.RegisterTaskWithMaintenanceWindow",
    };
    let body;
    body = JSON.stringify(se_RegisterTaskWithMaintenanceWindowRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RemoveTagsFromResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.RemoveTagsFromResource",
    };
    let body;
    body = JSON.stringify(se_RemoveTagsFromResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResetServiceSettingCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ResetServiceSetting",
    };
    let body;
    body = JSON.stringify(se_ResetServiceSettingRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResumeSessionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.ResumeSession",
    };
    let body;
    body = JSON.stringify(se_ResumeSessionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SendAutomationSignalCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.SendAutomationSignal",
    };
    let body;
    body = JSON.stringify(se_SendAutomationSignalRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SendCommandCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.SendCommand",
    };
    let body;
    body = JSON.stringify(se_SendCommandRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartAssociationsOnceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.StartAssociationsOnce",
    };
    let body;
    body = JSON.stringify(se_StartAssociationsOnceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartAutomationExecutionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.StartAutomationExecution",
    };
    let body;
    body = JSON.stringify(se_StartAutomationExecutionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartChangeRequestExecutionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.StartChangeRequestExecution",
    };
    let body;
    body = JSON.stringify(se_StartChangeRequestExecutionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartSessionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.StartSession",
    };
    let body;
    body = JSON.stringify(se_StartSessionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StopAutomationExecutionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.StopAutomationExecution",
    };
    let body;
    body = JSON.stringify(se_StopAutomationExecutionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TerminateSessionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.TerminateSession",
    };
    let body;
    body = JSON.stringify(se_TerminateSessionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UnlabelParameterVersionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.UnlabelParameterVersion",
    };
    let body;
    body = JSON.stringify(se_UnlabelParameterVersionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateAssociationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.UpdateAssociation",
    };
    let body;
    body = JSON.stringify(se_UpdateAssociationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateAssociationStatusCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.UpdateAssociationStatus",
    };
    let body;
    body = JSON.stringify(se_UpdateAssociationStatusRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateDocumentCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.UpdateDocument",
    };
    let body;
    body = JSON.stringify(se_UpdateDocumentRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateDocumentDefaultVersionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.UpdateDocumentDefaultVersion",
    };
    let body;
    body = JSON.stringify(se_UpdateDocumentDefaultVersionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateDocumentMetadataCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.UpdateDocumentMetadata",
    };
    let body;
    body = JSON.stringify(se_UpdateDocumentMetadataRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateMaintenanceWindowCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.UpdateMaintenanceWindow",
    };
    let body;
    body = JSON.stringify(se_UpdateMaintenanceWindowRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateMaintenanceWindowTargetCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.UpdateMaintenanceWindowTarget",
    };
    let body;
    body = JSON.stringify(se_UpdateMaintenanceWindowTargetRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateMaintenanceWindowTaskCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.UpdateMaintenanceWindowTask",
    };
    let body;
    body = JSON.stringify(se_UpdateMaintenanceWindowTaskRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateManagedInstanceRoleCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.UpdateManagedInstanceRole",
    };
    let body;
    body = JSON.stringify(se_UpdateManagedInstanceRoleRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateOpsItemCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.UpdateOpsItem",
    };
    let body;
    body = JSON.stringify(se_UpdateOpsItemRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateOpsMetadataCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.UpdateOpsMetadata",
    };
    let body;
    body = JSON.stringify(se_UpdateOpsMetadataRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdatePatchBaselineCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.UpdatePatchBaseline",
    };
    let body;
    body = JSON.stringify(se_UpdatePatchBaselineRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateResourceDataSyncCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.UpdateResourceDataSync",
    };
    let body;
    body = JSON.stringify(se_UpdateResourceDataSyncRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateServiceSettingCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonSSM.UpdateServiceSetting",
    };
    let body;
    body = JSON.stringify(se_UpdateServiceSettingRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_AddTagsToResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AddTagsToResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AddTagsToResourceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_AddTagsToResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidResourceId":
        case "com.amazonaws.ssm#InvalidResourceId":
            throw await de_InvalidResourceIdRes(parsedOutput, context);
        case "InvalidResourceType":
        case "com.amazonaws.ssm#InvalidResourceType":
            throw await de_InvalidResourceTypeRes(parsedOutput, context);
        case "TooManyTagsError":
        case "com.amazonaws.ssm#TooManyTagsError":
            throw await de_TooManyTagsErrorRes(parsedOutput, context);
        case "TooManyUpdates":
        case "com.amazonaws.ssm#TooManyUpdates":
            throw await de_TooManyUpdatesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_AssociateOpsItemRelatedItemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AssociateOpsItemRelatedItemCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssociateOpsItemRelatedItemResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_AssociateOpsItemRelatedItemCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "OpsItemInvalidParameterException":
        case "com.amazonaws.ssm#OpsItemInvalidParameterException":
            throw await de_OpsItemInvalidParameterExceptionRes(parsedOutput, context);
        case "OpsItemLimitExceededException":
        case "com.amazonaws.ssm#OpsItemLimitExceededException":
            throw await de_OpsItemLimitExceededExceptionRes(parsedOutput, context);
        case "OpsItemNotFoundException":
        case "com.amazonaws.ssm#OpsItemNotFoundException":
            throw await de_OpsItemNotFoundExceptionRes(parsedOutput, context);
        case "OpsItemRelatedItemAlreadyExistsException":
        case "com.amazonaws.ssm#OpsItemRelatedItemAlreadyExistsException":
            throw await de_OpsItemRelatedItemAlreadyExistsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_CancelCommandCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CancelCommandCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CancelCommandResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_CancelCommandCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DuplicateInstanceId":
        case "com.amazonaws.ssm#DuplicateInstanceId":
            throw await de_DuplicateInstanceIdRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidCommandId":
        case "com.amazonaws.ssm#InvalidCommandId":
            throw await de_InvalidCommandIdRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_CancelMaintenanceWindowExecutionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CancelMaintenanceWindowExecutionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CancelMaintenanceWindowExecutionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_CancelMaintenanceWindowExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_CreateActivationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateActivationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateActivationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_CreateActivationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidParameters":
        case "com.amazonaws.ssm#InvalidParameters":
            throw await de_InvalidParametersRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_CreateAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateAssociationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateAssociationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_CreateAssociationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AssociationAlreadyExists":
        case "com.amazonaws.ssm#AssociationAlreadyExists":
            throw await de_AssociationAlreadyExistsRes(parsedOutput, context);
        case "AssociationLimitExceeded":
        case "com.amazonaws.ssm#AssociationLimitExceeded":
            throw await de_AssociationLimitExceededRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidDocumentVersion":
        case "com.amazonaws.ssm#InvalidDocumentVersion":
            throw await de_InvalidDocumentVersionRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        case "InvalidOutputLocation":
        case "com.amazonaws.ssm#InvalidOutputLocation":
            throw await de_InvalidOutputLocationRes(parsedOutput, context);
        case "InvalidParameters":
        case "com.amazonaws.ssm#InvalidParameters":
            throw await de_InvalidParametersRes(parsedOutput, context);
        case "InvalidSchedule":
        case "com.amazonaws.ssm#InvalidSchedule":
            throw await de_InvalidScheduleRes(parsedOutput, context);
        case "InvalidTag":
        case "com.amazonaws.ssm#InvalidTag":
            throw await de_InvalidTagRes(parsedOutput, context);
        case "InvalidTarget":
        case "com.amazonaws.ssm#InvalidTarget":
            throw await de_InvalidTargetRes(parsedOutput, context);
        case "InvalidTargetMaps":
        case "com.amazonaws.ssm#InvalidTargetMaps":
            throw await de_InvalidTargetMapsRes(parsedOutput, context);
        case "UnsupportedPlatformType":
        case "com.amazonaws.ssm#UnsupportedPlatformType":
            throw await de_UnsupportedPlatformTypeRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_CreateAssociationBatchCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateAssociationBatchCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateAssociationBatchResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_CreateAssociationBatchCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AssociationLimitExceeded":
        case "com.amazonaws.ssm#AssociationLimitExceeded":
            throw await de_AssociationLimitExceededRes(parsedOutput, context);
        case "DuplicateInstanceId":
        case "com.amazonaws.ssm#DuplicateInstanceId":
            throw await de_DuplicateInstanceIdRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidDocumentVersion":
        case "com.amazonaws.ssm#InvalidDocumentVersion":
            throw await de_InvalidDocumentVersionRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        case "InvalidOutputLocation":
        case "com.amazonaws.ssm#InvalidOutputLocation":
            throw await de_InvalidOutputLocationRes(parsedOutput, context);
        case "InvalidParameters":
        case "com.amazonaws.ssm#InvalidParameters":
            throw await de_InvalidParametersRes(parsedOutput, context);
        case "InvalidSchedule":
        case "com.amazonaws.ssm#InvalidSchedule":
            throw await de_InvalidScheduleRes(parsedOutput, context);
        case "InvalidTarget":
        case "com.amazonaws.ssm#InvalidTarget":
            throw await de_InvalidTargetRes(parsedOutput, context);
        case "InvalidTargetMaps":
        case "com.amazonaws.ssm#InvalidTargetMaps":
            throw await de_InvalidTargetMapsRes(parsedOutput, context);
        case "UnsupportedPlatformType":
        case "com.amazonaws.ssm#UnsupportedPlatformType":
            throw await de_UnsupportedPlatformTypeRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_CreateDocumentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateDocumentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateDocumentResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_CreateDocumentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DocumentAlreadyExists":
        case "com.amazonaws.ssm#DocumentAlreadyExists":
            throw await de_DocumentAlreadyExistsRes(parsedOutput, context);
        case "DocumentLimitExceeded":
        case "com.amazonaws.ssm#DocumentLimitExceeded":
            throw await de_DocumentLimitExceededRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocumentContent":
        case "com.amazonaws.ssm#InvalidDocumentContent":
            throw await de_InvalidDocumentContentRes(parsedOutput, context);
        case "InvalidDocumentSchemaVersion":
        case "com.amazonaws.ssm#InvalidDocumentSchemaVersion":
            throw await de_InvalidDocumentSchemaVersionRes(parsedOutput, context);
        case "MaxDocumentSizeExceeded":
        case "com.amazonaws.ssm#MaxDocumentSizeExceeded":
            throw await de_MaxDocumentSizeExceededRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_CreateMaintenanceWindowCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateMaintenanceWindowCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateMaintenanceWindowResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_CreateMaintenanceWindowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IdempotentParameterMismatch":
        case "com.amazonaws.ssm#IdempotentParameterMismatch":
            throw await de_IdempotentParameterMismatchRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ResourceLimitExceededException":
        case "com.amazonaws.ssm#ResourceLimitExceededException":
            throw await de_ResourceLimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_CreateOpsItemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateOpsItemCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateOpsItemResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_CreateOpsItemCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "OpsItemAccessDeniedException":
        case "com.amazonaws.ssm#OpsItemAccessDeniedException":
            throw await de_OpsItemAccessDeniedExceptionRes(parsedOutput, context);
        case "OpsItemAlreadyExistsException":
        case "com.amazonaws.ssm#OpsItemAlreadyExistsException":
            throw await de_OpsItemAlreadyExistsExceptionRes(parsedOutput, context);
        case "OpsItemInvalidParameterException":
        case "com.amazonaws.ssm#OpsItemInvalidParameterException":
            throw await de_OpsItemInvalidParameterExceptionRes(parsedOutput, context);
        case "OpsItemLimitExceededException":
        case "com.amazonaws.ssm#OpsItemLimitExceededException":
            throw await de_OpsItemLimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_CreateOpsMetadataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateOpsMetadataCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateOpsMetadataResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_CreateOpsMetadataCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "OpsMetadataAlreadyExistsException":
        case "com.amazonaws.ssm#OpsMetadataAlreadyExistsException":
            throw await de_OpsMetadataAlreadyExistsExceptionRes(parsedOutput, context);
        case "OpsMetadataInvalidArgumentException":
        case "com.amazonaws.ssm#OpsMetadataInvalidArgumentException":
            throw await de_OpsMetadataInvalidArgumentExceptionRes(parsedOutput, context);
        case "OpsMetadataLimitExceededException":
        case "com.amazonaws.ssm#OpsMetadataLimitExceededException":
            throw await de_OpsMetadataLimitExceededExceptionRes(parsedOutput, context);
        case "OpsMetadataTooManyUpdatesException":
        case "com.amazonaws.ssm#OpsMetadataTooManyUpdatesException":
            throw await de_OpsMetadataTooManyUpdatesExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_CreatePatchBaselineCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreatePatchBaselineCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreatePatchBaselineResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_CreatePatchBaselineCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IdempotentParameterMismatch":
        case "com.amazonaws.ssm#IdempotentParameterMismatch":
            throw await de_IdempotentParameterMismatchRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ResourceLimitExceededException":
        case "com.amazonaws.ssm#ResourceLimitExceededException":
            throw await de_ResourceLimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_CreateResourceDataSyncCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateResourceDataSyncCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateResourceDataSyncResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_CreateResourceDataSyncCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ResourceDataSyncAlreadyExistsException":
        case "com.amazonaws.ssm#ResourceDataSyncAlreadyExistsException":
            throw await de_ResourceDataSyncAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceDataSyncCountExceededException":
        case "com.amazonaws.ssm#ResourceDataSyncCountExceededException":
            throw await de_ResourceDataSyncCountExceededExceptionRes(parsedOutput, context);
        case "ResourceDataSyncInvalidConfigurationException":
        case "com.amazonaws.ssm#ResourceDataSyncInvalidConfigurationException":
            throw await de_ResourceDataSyncInvalidConfigurationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DeleteActivationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteActivationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteActivationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DeleteActivationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidActivation":
        case "com.amazonaws.ssm#InvalidActivation":
            throw await de_InvalidActivationRes(parsedOutput, context);
        case "InvalidActivationId":
        case "com.amazonaws.ssm#InvalidActivationId":
            throw await de_InvalidActivationIdRes(parsedOutput, context);
        case "TooManyUpdates":
        case "com.amazonaws.ssm#TooManyUpdates":
            throw await de_TooManyUpdatesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DeleteAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteAssociationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteAssociationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DeleteAssociationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AssociationDoesNotExist":
        case "com.amazonaws.ssm#AssociationDoesNotExist":
            throw await de_AssociationDoesNotExistRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        case "TooManyUpdates":
        case "com.amazonaws.ssm#TooManyUpdates":
            throw await de_TooManyUpdatesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DeleteDocumentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteDocumentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteDocumentResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DeleteDocumentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AssociatedInstances":
        case "com.amazonaws.ssm#AssociatedInstances":
            throw await de_AssociatedInstancesRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidDocumentOperation":
        case "com.amazonaws.ssm#InvalidDocumentOperation":
            throw await de_InvalidDocumentOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DeleteInventoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteInventoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteInventoryResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DeleteInventoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDeleteInventoryParametersException":
        case "com.amazonaws.ssm#InvalidDeleteInventoryParametersException":
            throw await de_InvalidDeleteInventoryParametersExceptionRes(parsedOutput, context);
        case "InvalidInventoryRequestException":
        case "com.amazonaws.ssm#InvalidInventoryRequestException":
            throw await de_InvalidInventoryRequestExceptionRes(parsedOutput, context);
        case "InvalidOptionException":
        case "com.amazonaws.ssm#InvalidOptionException":
            throw await de_InvalidOptionExceptionRes(parsedOutput, context);
        case "InvalidTypeNameException":
        case "com.amazonaws.ssm#InvalidTypeNameException":
            throw await de_InvalidTypeNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DeleteMaintenanceWindowCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteMaintenanceWindowCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteMaintenanceWindowResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DeleteMaintenanceWindowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DeleteOpsMetadataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteOpsMetadataCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteOpsMetadataResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DeleteOpsMetadataCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "OpsMetadataInvalidArgumentException":
        case "com.amazonaws.ssm#OpsMetadataInvalidArgumentException":
            throw await de_OpsMetadataInvalidArgumentExceptionRes(parsedOutput, context);
        case "OpsMetadataNotFoundException":
        case "com.amazonaws.ssm#OpsMetadataNotFoundException":
            throw await de_OpsMetadataNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DeleteParameterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteParameterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteParameterResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DeleteParameterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ParameterNotFound":
        case "com.amazonaws.ssm#ParameterNotFound":
            throw await de_ParameterNotFoundRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DeleteParametersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteParametersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteParametersResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DeleteParametersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DeletePatchBaselineCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeletePatchBaselineCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeletePatchBaselineResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DeletePatchBaselineCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ResourceInUseException":
        case "com.amazonaws.ssm#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DeleteResourceDataSyncCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteResourceDataSyncCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteResourceDataSyncResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DeleteResourceDataSyncCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ResourceDataSyncInvalidConfigurationException":
        case "com.amazonaws.ssm#ResourceDataSyncInvalidConfigurationException":
            throw await de_ResourceDataSyncInvalidConfigurationExceptionRes(parsedOutput, context);
        case "ResourceDataSyncNotFoundException":
        case "com.amazonaws.ssm#ResourceDataSyncNotFoundException":
            throw await de_ResourceDataSyncNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DeleteResourcePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteResourcePolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteResourcePolicyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DeleteResourcePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ResourcePolicyConflictException":
        case "com.amazonaws.ssm#ResourcePolicyConflictException":
            throw await de_ResourcePolicyConflictExceptionRes(parsedOutput, context);
        case "ResourcePolicyInvalidParameterException":
        case "com.amazonaws.ssm#ResourcePolicyInvalidParameterException":
            throw await de_ResourcePolicyInvalidParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DeregisterManagedInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeregisterManagedInstanceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeregisterManagedInstanceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DeregisterManagedInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DeregisterPatchBaselineForPatchGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeregisterPatchBaselineForPatchGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeregisterPatchBaselineForPatchGroupResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DeregisterPatchBaselineForPatchGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidResourceId":
        case "com.amazonaws.ssm#InvalidResourceId":
            throw await de_InvalidResourceIdRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DeregisterTargetFromMaintenanceWindowCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeregisterTargetFromMaintenanceWindowCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeregisterTargetFromMaintenanceWindowResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DeregisterTargetFromMaintenanceWindowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "TargetInUseException":
        case "com.amazonaws.ssm#TargetInUseException":
            throw await de_TargetInUseExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DeregisterTaskFromMaintenanceWindowCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeregisterTaskFromMaintenanceWindowCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeregisterTaskFromMaintenanceWindowResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DeregisterTaskFromMaintenanceWindowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeActivationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeActivationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeActivationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeActivationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidFilter":
        case "com.amazonaws.ssm#InvalidFilter":
            throw await de_InvalidFilterRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAssociationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAssociationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeAssociationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AssociationDoesNotExist":
        case "com.amazonaws.ssm#AssociationDoesNotExist":
            throw await de_AssociationDoesNotExistRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidAssociationVersion":
        case "com.amazonaws.ssm#InvalidAssociationVersion":
            throw await de_InvalidAssociationVersionRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeAssociationExecutionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAssociationExecutionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAssociationExecutionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeAssociationExecutionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AssociationDoesNotExist":
        case "com.amazonaws.ssm#AssociationDoesNotExist":
            throw await de_AssociationDoesNotExistRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeAssociationExecutionTargetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAssociationExecutionTargetsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAssociationExecutionTargetsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeAssociationExecutionTargetsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AssociationDoesNotExist":
        case "com.amazonaws.ssm#AssociationDoesNotExist":
            throw await de_AssociationDoesNotExistRes(parsedOutput, context);
        case "AssociationExecutionDoesNotExist":
        case "com.amazonaws.ssm#AssociationExecutionDoesNotExist":
            throw await de_AssociationExecutionDoesNotExistRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeAutomationExecutionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAutomationExecutionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAutomationExecutionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeAutomationExecutionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidFilterKey":
        case "com.amazonaws.ssm#InvalidFilterKey":
            throw await de_InvalidFilterKeyRes(parsedOutput, context);
        case "InvalidFilterValue":
        case "com.amazonaws.ssm#InvalidFilterValue":
            throw await de_InvalidFilterValueRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeAutomationStepExecutionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAutomationStepExecutionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAutomationStepExecutionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeAutomationStepExecutionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AutomationExecutionNotFoundException":
        case "com.amazonaws.ssm#AutomationExecutionNotFoundException":
            throw await de_AutomationExecutionNotFoundExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidFilterKey":
        case "com.amazonaws.ssm#InvalidFilterKey":
            throw await de_InvalidFilterKeyRes(parsedOutput, context);
        case "InvalidFilterValue":
        case "com.amazonaws.ssm#InvalidFilterValue":
            throw await de_InvalidFilterValueRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeAvailablePatchesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAvailablePatchesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAvailablePatchesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeAvailablePatchesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeDocumentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeDocumentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeDocumentResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeDocumentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidDocumentVersion":
        case "com.amazonaws.ssm#InvalidDocumentVersion":
            throw await de_InvalidDocumentVersionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeDocumentPermissionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeDocumentPermissionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeDocumentPermissionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeDocumentPermissionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidDocumentOperation":
        case "com.amazonaws.ssm#InvalidDocumentOperation":
            throw await de_InvalidDocumentOperationRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "InvalidPermissionType":
        case "com.amazonaws.ssm#InvalidPermissionType":
            throw await de_InvalidPermissionTypeRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeEffectiveInstanceAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeEffectiveInstanceAssociationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeEffectiveInstanceAssociationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeEffectiveInstanceAssociationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeEffectivePatchesForPatchBaselineCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeEffectivePatchesForPatchBaselineCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeEffectivePatchesForPatchBaselineResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeEffectivePatchesForPatchBaselineCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidResourceId":
        case "com.amazonaws.ssm#InvalidResourceId":
            throw await de_InvalidResourceIdRes(parsedOutput, context);
        case "UnsupportedOperatingSystem":
        case "com.amazonaws.ssm#UnsupportedOperatingSystem":
            throw await de_UnsupportedOperatingSystemRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeInstanceAssociationsStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeInstanceAssociationsStatusCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInstanceAssociationsStatusResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeInstanceAssociationsStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeInstanceInformationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeInstanceInformationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInstanceInformationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeInstanceInformationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidFilterKey":
        case "com.amazonaws.ssm#InvalidFilterKey":
            throw await de_InvalidFilterKeyRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        case "InvalidInstanceInformationFilterValue":
        case "com.amazonaws.ssm#InvalidInstanceInformationFilterValue":
            throw await de_InvalidInstanceInformationFilterValueRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeInstancePatchesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeInstancePatchesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInstancePatchesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeInstancePatchesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidFilter":
        case "com.amazonaws.ssm#InvalidFilter":
            throw await de_InvalidFilterRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeInstancePatchStatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeInstancePatchStatesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInstancePatchStatesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeInstancePatchStatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeInstancePatchStatesForPatchGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeInstancePatchStatesForPatchGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInstancePatchStatesForPatchGroupResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeInstancePatchStatesForPatchGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidFilter":
        case "com.amazonaws.ssm#InvalidFilter":
            throw await de_InvalidFilterRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeInventoryDeletionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeInventoryDeletionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInventoryDeletionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeInventoryDeletionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDeletionIdException":
        case "com.amazonaws.ssm#InvalidDeletionIdException":
            throw await de_InvalidDeletionIdExceptionRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeMaintenanceWindowExecutionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeMaintenanceWindowExecutionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeMaintenanceWindowExecutionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeMaintenanceWindowExecutionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeMaintenanceWindowExecutionTaskInvocationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeMaintenanceWindowExecutionTaskInvocationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeMaintenanceWindowExecutionTaskInvocationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeMaintenanceWindowExecutionTaskInvocationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeMaintenanceWindowExecutionTasksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeMaintenanceWindowExecutionTasksCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeMaintenanceWindowExecutionTasksResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeMaintenanceWindowExecutionTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeMaintenanceWindowsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeMaintenanceWindowsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeMaintenanceWindowsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeMaintenanceWindowsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeMaintenanceWindowScheduleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeMaintenanceWindowScheduleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeMaintenanceWindowScheduleResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeMaintenanceWindowScheduleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeMaintenanceWindowsForTargetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeMaintenanceWindowsForTargetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeMaintenanceWindowsForTargetResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeMaintenanceWindowsForTargetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeMaintenanceWindowTargetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeMaintenanceWindowTargetsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeMaintenanceWindowTargetsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeMaintenanceWindowTargetsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeMaintenanceWindowTasksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeMaintenanceWindowTasksCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeMaintenanceWindowTasksResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeMaintenanceWindowTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeOpsItemsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeOpsItemsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeOpsItemsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeOpsItemsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeParametersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeParametersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeParametersResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeParametersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidFilterKey":
        case "com.amazonaws.ssm#InvalidFilterKey":
            throw await de_InvalidFilterKeyRes(parsedOutput, context);
        case "InvalidFilterOption":
        case "com.amazonaws.ssm#InvalidFilterOption":
            throw await de_InvalidFilterOptionRes(parsedOutput, context);
        case "InvalidFilterValue":
        case "com.amazonaws.ssm#InvalidFilterValue":
            throw await de_InvalidFilterValueRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribePatchBaselinesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribePatchBaselinesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribePatchBaselinesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribePatchBaselinesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribePatchGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribePatchGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribePatchGroupsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribePatchGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribePatchGroupStateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribePatchGroupStateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribePatchGroupStateResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribePatchGroupStateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribePatchPropertiesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribePatchPropertiesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribePatchPropertiesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribePatchPropertiesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DescribeSessionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeSessionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSessionsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DescribeSessionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidFilterKey":
        case "com.amazonaws.ssm#InvalidFilterKey":
            throw await de_InvalidFilterKeyRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_DisassociateOpsItemRelatedItemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DisassociateOpsItemRelatedItemCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisassociateOpsItemRelatedItemResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_DisassociateOpsItemRelatedItemCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "OpsItemInvalidParameterException":
        case "com.amazonaws.ssm#OpsItemInvalidParameterException":
            throw await de_OpsItemInvalidParameterExceptionRes(parsedOutput, context);
        case "OpsItemNotFoundException":
        case "com.amazonaws.ssm#OpsItemNotFoundException":
            throw await de_OpsItemNotFoundExceptionRes(parsedOutput, context);
        case "OpsItemRelatedItemAssociationNotFoundException":
        case "com.amazonaws.ssm#OpsItemRelatedItemAssociationNotFoundException":
            throw await de_OpsItemRelatedItemAssociationNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetAutomationExecutionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetAutomationExecutionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAutomationExecutionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetAutomationExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AutomationExecutionNotFoundException":
        case "com.amazonaws.ssm#AutomationExecutionNotFoundException":
            throw await de_AutomationExecutionNotFoundExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetCalendarStateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetCalendarStateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetCalendarStateResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetCalendarStateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidDocumentType":
        case "com.amazonaws.ssm#InvalidDocumentType":
            throw await de_InvalidDocumentTypeRes(parsedOutput, context);
        case "UnsupportedCalendarException":
        case "com.amazonaws.ssm#UnsupportedCalendarException":
            throw await de_UnsupportedCalendarExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetCommandInvocationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetCommandInvocationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetCommandInvocationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetCommandInvocationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidCommandId":
        case "com.amazonaws.ssm#InvalidCommandId":
            throw await de_InvalidCommandIdRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        case "InvalidPluginName":
        case "com.amazonaws.ssm#InvalidPluginName":
            throw await de_InvalidPluginNameRes(parsedOutput, context);
        case "InvocationDoesNotExist":
        case "com.amazonaws.ssm#InvocationDoesNotExist":
            throw await de_InvocationDoesNotExistRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetConnectionStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetConnectionStatusCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetConnectionStatusResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetConnectionStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetDefaultPatchBaselineCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetDefaultPatchBaselineCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDefaultPatchBaselineResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetDefaultPatchBaselineCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetDeployablePatchSnapshotForInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetDeployablePatchSnapshotForInstanceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDeployablePatchSnapshotForInstanceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetDeployablePatchSnapshotForInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "UnsupportedFeatureRequiredException":
        case "com.amazonaws.ssm#UnsupportedFeatureRequiredException":
            throw await de_UnsupportedFeatureRequiredExceptionRes(parsedOutput, context);
        case "UnsupportedOperatingSystem":
        case "com.amazonaws.ssm#UnsupportedOperatingSystem":
            throw await de_UnsupportedOperatingSystemRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetDocumentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetDocumentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDocumentResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetDocumentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidDocumentVersion":
        case "com.amazonaws.ssm#InvalidDocumentVersion":
            throw await de_InvalidDocumentVersionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetInventoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetInventoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetInventoryResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetInventoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidAggregatorException":
        case "com.amazonaws.ssm#InvalidAggregatorException":
            throw await de_InvalidAggregatorExceptionRes(parsedOutput, context);
        case "InvalidFilter":
        case "com.amazonaws.ssm#InvalidFilter":
            throw await de_InvalidFilterRes(parsedOutput, context);
        case "InvalidInventoryGroupException":
        case "com.amazonaws.ssm#InvalidInventoryGroupException":
            throw await de_InvalidInventoryGroupExceptionRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "InvalidResultAttributeException":
        case "com.amazonaws.ssm#InvalidResultAttributeException":
            throw await de_InvalidResultAttributeExceptionRes(parsedOutput, context);
        case "InvalidTypeNameException":
        case "com.amazonaws.ssm#InvalidTypeNameException":
            throw await de_InvalidTypeNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetInventorySchemaCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetInventorySchemaCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetInventorySchemaResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetInventorySchemaCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "InvalidTypeNameException":
        case "com.amazonaws.ssm#InvalidTypeNameException":
            throw await de_InvalidTypeNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetMaintenanceWindowCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMaintenanceWindowCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMaintenanceWindowResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetMaintenanceWindowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetMaintenanceWindowExecutionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMaintenanceWindowExecutionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMaintenanceWindowExecutionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetMaintenanceWindowExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetMaintenanceWindowExecutionTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMaintenanceWindowExecutionTaskCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMaintenanceWindowExecutionTaskResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetMaintenanceWindowExecutionTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetMaintenanceWindowExecutionTaskInvocationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMaintenanceWindowExecutionTaskInvocationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMaintenanceWindowExecutionTaskInvocationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetMaintenanceWindowExecutionTaskInvocationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetMaintenanceWindowTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMaintenanceWindowTaskCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMaintenanceWindowTaskResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetMaintenanceWindowTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetOpsItemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetOpsItemCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetOpsItemResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetOpsItemCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "OpsItemAccessDeniedException":
        case "com.amazonaws.ssm#OpsItemAccessDeniedException":
            throw await de_OpsItemAccessDeniedExceptionRes(parsedOutput, context);
        case "OpsItemNotFoundException":
        case "com.amazonaws.ssm#OpsItemNotFoundException":
            throw await de_OpsItemNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetOpsMetadataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetOpsMetadataCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetOpsMetadataResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetOpsMetadataCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "OpsMetadataInvalidArgumentException":
        case "com.amazonaws.ssm#OpsMetadataInvalidArgumentException":
            throw await de_OpsMetadataInvalidArgumentExceptionRes(parsedOutput, context);
        case "OpsMetadataNotFoundException":
        case "com.amazonaws.ssm#OpsMetadataNotFoundException":
            throw await de_OpsMetadataNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetOpsSummaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetOpsSummaryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetOpsSummaryResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetOpsSummaryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidAggregatorException":
        case "com.amazonaws.ssm#InvalidAggregatorException":
            throw await de_InvalidAggregatorExceptionRes(parsedOutput, context);
        case "InvalidFilter":
        case "com.amazonaws.ssm#InvalidFilter":
            throw await de_InvalidFilterRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "InvalidTypeNameException":
        case "com.amazonaws.ssm#InvalidTypeNameException":
            throw await de_InvalidTypeNameExceptionRes(parsedOutput, context);
        case "ResourceDataSyncNotFoundException":
        case "com.amazonaws.ssm#ResourceDataSyncNotFoundException":
            throw await de_ResourceDataSyncNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetParameterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetParameterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetParameterResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetParameterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidKeyId":
        case "com.amazonaws.ssm#InvalidKeyId":
            throw await de_InvalidKeyIdRes(parsedOutput, context);
        case "ParameterNotFound":
        case "com.amazonaws.ssm#ParameterNotFound":
            throw await de_ParameterNotFoundRes(parsedOutput, context);
        case "ParameterVersionNotFound":
        case "com.amazonaws.ssm#ParameterVersionNotFound":
            throw await de_ParameterVersionNotFoundRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetParameterHistoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetParameterHistoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetParameterHistoryResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetParameterHistoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidKeyId":
        case "com.amazonaws.ssm#InvalidKeyId":
            throw await de_InvalidKeyIdRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "ParameterNotFound":
        case "com.amazonaws.ssm#ParameterNotFound":
            throw await de_ParameterNotFoundRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetParametersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetParametersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetParametersResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetParametersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidKeyId":
        case "com.amazonaws.ssm#InvalidKeyId":
            throw await de_InvalidKeyIdRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetParametersByPathCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetParametersByPathCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetParametersByPathResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetParametersByPathCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidFilterKey":
        case "com.amazonaws.ssm#InvalidFilterKey":
            throw await de_InvalidFilterKeyRes(parsedOutput, context);
        case "InvalidFilterOption":
        case "com.amazonaws.ssm#InvalidFilterOption":
            throw await de_InvalidFilterOptionRes(parsedOutput, context);
        case "InvalidFilterValue":
        case "com.amazonaws.ssm#InvalidFilterValue":
            throw await de_InvalidFilterValueRes(parsedOutput, context);
        case "InvalidKeyId":
        case "com.amazonaws.ssm#InvalidKeyId":
            throw await de_InvalidKeyIdRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetPatchBaselineCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetPatchBaselineCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetPatchBaselineResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetPatchBaselineCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidResourceId":
        case "com.amazonaws.ssm#InvalidResourceId":
            throw await de_InvalidResourceIdRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetPatchBaselineForPatchGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetPatchBaselineForPatchGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetPatchBaselineForPatchGroupResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetPatchBaselineForPatchGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetResourcePoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetResourcePoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetResourcePoliciesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetResourcePoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ResourcePolicyInvalidParameterException":
        case "com.amazonaws.ssm#ResourcePolicyInvalidParameterException":
            throw await de_ResourcePolicyInvalidParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_GetServiceSettingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetServiceSettingCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetServiceSettingResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_GetServiceSettingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ServiceSettingNotFound":
        case "com.amazonaws.ssm#ServiceSettingNotFound":
            throw await de_ServiceSettingNotFoundRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_LabelParameterVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_LabelParameterVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_LabelParameterVersionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_LabelParameterVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ParameterNotFound":
        case "com.amazonaws.ssm#ParameterNotFound":
            throw await de_ParameterNotFoundRes(parsedOutput, context);
        case "ParameterVersionLabelLimitExceeded":
        case "com.amazonaws.ssm#ParameterVersionLabelLimitExceeded":
            throw await de_ParameterVersionLabelLimitExceededRes(parsedOutput, context);
        case "ParameterVersionNotFound":
        case "com.amazonaws.ssm#ParameterVersionNotFound":
            throw await de_ParameterVersionNotFoundRes(parsedOutput, context);
        case "TooManyUpdates":
        case "com.amazonaws.ssm#TooManyUpdates":
            throw await de_TooManyUpdatesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ListAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAssociationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAssociationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ListAssociationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ListAssociationVersionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAssociationVersionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAssociationVersionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ListAssociationVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AssociationDoesNotExist":
        case "com.amazonaws.ssm#AssociationDoesNotExist":
            throw await de_AssociationDoesNotExistRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ListCommandInvocationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListCommandInvocationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListCommandInvocationsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ListCommandInvocationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidCommandId":
        case "com.amazonaws.ssm#InvalidCommandId":
            throw await de_InvalidCommandIdRes(parsedOutput, context);
        case "InvalidFilterKey":
        case "com.amazonaws.ssm#InvalidFilterKey":
            throw await de_InvalidFilterKeyRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ListCommandsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListCommandsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListCommandsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ListCommandsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidCommandId":
        case "com.amazonaws.ssm#InvalidCommandId":
            throw await de_InvalidCommandIdRes(parsedOutput, context);
        case "InvalidFilterKey":
        case "com.amazonaws.ssm#InvalidFilterKey":
            throw await de_InvalidFilterKeyRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ListComplianceItemsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListComplianceItemsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListComplianceItemsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ListComplianceItemsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidFilter":
        case "com.amazonaws.ssm#InvalidFilter":
            throw await de_InvalidFilterRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "InvalidResourceId":
        case "com.amazonaws.ssm#InvalidResourceId":
            throw await de_InvalidResourceIdRes(parsedOutput, context);
        case "InvalidResourceType":
        case "com.amazonaws.ssm#InvalidResourceType":
            throw await de_InvalidResourceTypeRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ListComplianceSummariesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListComplianceSummariesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListComplianceSummariesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ListComplianceSummariesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidFilter":
        case "com.amazonaws.ssm#InvalidFilter":
            throw await de_InvalidFilterRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ListDocumentMetadataHistoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListDocumentMetadataHistoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListDocumentMetadataHistoryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ListDocumentMetadataHistoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidDocumentVersion":
        case "com.amazonaws.ssm#InvalidDocumentVersion":
            throw await de_InvalidDocumentVersionRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ListDocumentsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListDocumentsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListDocumentsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ListDocumentsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidFilterKey":
        case "com.amazonaws.ssm#InvalidFilterKey":
            throw await de_InvalidFilterKeyRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ListDocumentVersionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListDocumentVersionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListDocumentVersionsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ListDocumentVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ListInventoryEntriesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListInventoryEntriesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListInventoryEntriesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ListInventoryEntriesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidFilter":
        case "com.amazonaws.ssm#InvalidFilter":
            throw await de_InvalidFilterRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "InvalidTypeNameException":
        case "com.amazonaws.ssm#InvalidTypeNameException":
            throw await de_InvalidTypeNameExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ListOpsItemEventsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListOpsItemEventsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListOpsItemEventsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ListOpsItemEventsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "OpsItemInvalidParameterException":
        case "com.amazonaws.ssm#OpsItemInvalidParameterException":
            throw await de_OpsItemInvalidParameterExceptionRes(parsedOutput, context);
        case "OpsItemLimitExceededException":
        case "com.amazonaws.ssm#OpsItemLimitExceededException":
            throw await de_OpsItemLimitExceededExceptionRes(parsedOutput, context);
        case "OpsItemNotFoundException":
        case "com.amazonaws.ssm#OpsItemNotFoundException":
            throw await de_OpsItemNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ListOpsItemRelatedItemsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListOpsItemRelatedItemsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListOpsItemRelatedItemsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ListOpsItemRelatedItemsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "OpsItemInvalidParameterException":
        case "com.amazonaws.ssm#OpsItemInvalidParameterException":
            throw await de_OpsItemInvalidParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ListOpsMetadataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListOpsMetadataCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListOpsMetadataResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ListOpsMetadataCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "OpsMetadataInvalidArgumentException":
        case "com.amazonaws.ssm#OpsMetadataInvalidArgumentException":
            throw await de_OpsMetadataInvalidArgumentExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ListResourceComplianceSummariesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListResourceComplianceSummariesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListResourceComplianceSummariesResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ListResourceComplianceSummariesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidFilter":
        case "com.amazonaws.ssm#InvalidFilter":
            throw await de_InvalidFilterRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ListResourceDataSyncCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListResourceDataSyncCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListResourceDataSyncResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ListResourceDataSyncCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.ssm#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "ResourceDataSyncInvalidConfigurationException":
        case "com.amazonaws.ssm#ResourceDataSyncInvalidConfigurationException":
            throw await de_ResourceDataSyncInvalidConfigurationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListTagsForResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListTagsForResourceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidResourceId":
        case "com.amazonaws.ssm#InvalidResourceId":
            throw await de_InvalidResourceIdRes(parsedOutput, context);
        case "InvalidResourceType":
        case "com.amazonaws.ssm#InvalidResourceType":
            throw await de_InvalidResourceTypeRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ModifyDocumentPermissionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ModifyDocumentPermissionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyDocumentPermissionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ModifyDocumentPermissionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DocumentLimitExceeded":
        case "com.amazonaws.ssm#DocumentLimitExceeded":
            throw await de_DocumentLimitExceededRes(parsedOutput, context);
        case "DocumentPermissionLimit":
        case "com.amazonaws.ssm#DocumentPermissionLimit":
            throw await de_DocumentPermissionLimitRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidPermissionType":
        case "com.amazonaws.ssm#InvalidPermissionType":
            throw await de_InvalidPermissionTypeRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_PutComplianceItemsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutComplianceItemsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutComplianceItemsResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_PutComplianceItemsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ComplianceTypeCountLimitExceededException":
        case "com.amazonaws.ssm#ComplianceTypeCountLimitExceededException":
            throw await de_ComplianceTypeCountLimitExceededExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidItemContentException":
        case "com.amazonaws.ssm#InvalidItemContentException":
            throw await de_InvalidItemContentExceptionRes(parsedOutput, context);
        case "InvalidResourceId":
        case "com.amazonaws.ssm#InvalidResourceId":
            throw await de_InvalidResourceIdRes(parsedOutput, context);
        case "InvalidResourceType":
        case "com.amazonaws.ssm#InvalidResourceType":
            throw await de_InvalidResourceTypeRes(parsedOutput, context);
        case "ItemSizeLimitExceededException":
        case "com.amazonaws.ssm#ItemSizeLimitExceededException":
            throw await de_ItemSizeLimitExceededExceptionRes(parsedOutput, context);
        case "TotalSizeLimitExceededException":
        case "com.amazonaws.ssm#TotalSizeLimitExceededException":
            throw await de_TotalSizeLimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_PutInventoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutInventoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutInventoryResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_PutInventoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CustomSchemaCountLimitExceededException":
        case "com.amazonaws.ssm#CustomSchemaCountLimitExceededException":
            throw await de_CustomSchemaCountLimitExceededExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        case "InvalidInventoryItemContextException":
        case "com.amazonaws.ssm#InvalidInventoryItemContextException":
            throw await de_InvalidInventoryItemContextExceptionRes(parsedOutput, context);
        case "InvalidItemContentException":
        case "com.amazonaws.ssm#InvalidItemContentException":
            throw await de_InvalidItemContentExceptionRes(parsedOutput, context);
        case "InvalidTypeNameException":
        case "com.amazonaws.ssm#InvalidTypeNameException":
            throw await de_InvalidTypeNameExceptionRes(parsedOutput, context);
        case "ItemContentMismatchException":
        case "com.amazonaws.ssm#ItemContentMismatchException":
            throw await de_ItemContentMismatchExceptionRes(parsedOutput, context);
        case "ItemSizeLimitExceededException":
        case "com.amazonaws.ssm#ItemSizeLimitExceededException":
            throw await de_ItemSizeLimitExceededExceptionRes(parsedOutput, context);
        case "SubTypeCountLimitExceededException":
        case "com.amazonaws.ssm#SubTypeCountLimitExceededException":
            throw await de_SubTypeCountLimitExceededExceptionRes(parsedOutput, context);
        case "TotalSizeLimitExceededException":
        case "com.amazonaws.ssm#TotalSizeLimitExceededException":
            throw await de_TotalSizeLimitExceededExceptionRes(parsedOutput, context);
        case "UnsupportedInventoryItemContextException":
        case "com.amazonaws.ssm#UnsupportedInventoryItemContextException":
            throw await de_UnsupportedInventoryItemContextExceptionRes(parsedOutput, context);
        case "UnsupportedInventorySchemaVersionException":
        case "com.amazonaws.ssm#UnsupportedInventorySchemaVersionException":
            throw await de_UnsupportedInventorySchemaVersionExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_PutParameterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutParameterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutParameterResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_PutParameterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "HierarchyLevelLimitExceededException":
        case "com.amazonaws.ssm#HierarchyLevelLimitExceededException":
            throw await de_HierarchyLevelLimitExceededExceptionRes(parsedOutput, context);
        case "HierarchyTypeMismatchException":
        case "com.amazonaws.ssm#HierarchyTypeMismatchException":
            throw await de_HierarchyTypeMismatchExceptionRes(parsedOutput, context);
        case "IncompatiblePolicyException":
        case "com.amazonaws.ssm#IncompatiblePolicyException":
            throw await de_IncompatiblePolicyExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidAllowedPatternException":
        case "com.amazonaws.ssm#InvalidAllowedPatternException":
            throw await de_InvalidAllowedPatternExceptionRes(parsedOutput, context);
        case "InvalidKeyId":
        case "com.amazonaws.ssm#InvalidKeyId":
            throw await de_InvalidKeyIdRes(parsedOutput, context);
        case "InvalidPolicyAttributeException":
        case "com.amazonaws.ssm#InvalidPolicyAttributeException":
            throw await de_InvalidPolicyAttributeExceptionRes(parsedOutput, context);
        case "InvalidPolicyTypeException":
        case "com.amazonaws.ssm#InvalidPolicyTypeException":
            throw await de_InvalidPolicyTypeExceptionRes(parsedOutput, context);
        case "ParameterAlreadyExists":
        case "com.amazonaws.ssm#ParameterAlreadyExists":
            throw await de_ParameterAlreadyExistsRes(parsedOutput, context);
        case "ParameterLimitExceeded":
        case "com.amazonaws.ssm#ParameterLimitExceeded":
            throw await de_ParameterLimitExceededRes(parsedOutput, context);
        case "ParameterMaxVersionLimitExceeded":
        case "com.amazonaws.ssm#ParameterMaxVersionLimitExceeded":
            throw await de_ParameterMaxVersionLimitExceededRes(parsedOutput, context);
        case "ParameterPatternMismatchException":
        case "com.amazonaws.ssm#ParameterPatternMismatchException":
            throw await de_ParameterPatternMismatchExceptionRes(parsedOutput, context);
        case "PoliciesLimitExceededException":
        case "com.amazonaws.ssm#PoliciesLimitExceededException":
            throw await de_PoliciesLimitExceededExceptionRes(parsedOutput, context);
        case "TooManyUpdates":
        case "com.amazonaws.ssm#TooManyUpdates":
            throw await de_TooManyUpdatesRes(parsedOutput, context);
        case "UnsupportedParameterType":
        case "com.amazonaws.ssm#UnsupportedParameterType":
            throw await de_UnsupportedParameterTypeRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_PutResourcePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutResourcePolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutResourcePolicyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_PutResourcePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ResourcePolicyConflictException":
        case "com.amazonaws.ssm#ResourcePolicyConflictException":
            throw await de_ResourcePolicyConflictExceptionRes(parsedOutput, context);
        case "ResourcePolicyInvalidParameterException":
        case "com.amazonaws.ssm#ResourcePolicyInvalidParameterException":
            throw await de_ResourcePolicyInvalidParameterExceptionRes(parsedOutput, context);
        case "ResourcePolicyLimitExceededException":
        case "com.amazonaws.ssm#ResourcePolicyLimitExceededException":
            throw await de_ResourcePolicyLimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_RegisterDefaultPatchBaselineCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RegisterDefaultPatchBaselineCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RegisterDefaultPatchBaselineResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_RegisterDefaultPatchBaselineCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidResourceId":
        case "com.amazonaws.ssm#InvalidResourceId":
            throw await de_InvalidResourceIdRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_RegisterPatchBaselineForPatchGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RegisterPatchBaselineForPatchGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RegisterPatchBaselineForPatchGroupResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_RegisterPatchBaselineForPatchGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.ssm#AlreadyExistsException":
            throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidResourceId":
        case "com.amazonaws.ssm#InvalidResourceId":
            throw await de_InvalidResourceIdRes(parsedOutput, context);
        case "ResourceLimitExceededException":
        case "com.amazonaws.ssm#ResourceLimitExceededException":
            throw await de_ResourceLimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_RegisterTargetWithMaintenanceWindowCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RegisterTargetWithMaintenanceWindowCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RegisterTargetWithMaintenanceWindowResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_RegisterTargetWithMaintenanceWindowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "IdempotentParameterMismatch":
        case "com.amazonaws.ssm#IdempotentParameterMismatch":
            throw await de_IdempotentParameterMismatchRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ResourceLimitExceededException":
        case "com.amazonaws.ssm#ResourceLimitExceededException":
            throw await de_ResourceLimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_RegisterTaskWithMaintenanceWindowCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RegisterTaskWithMaintenanceWindowCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RegisterTaskWithMaintenanceWindowResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_RegisterTaskWithMaintenanceWindowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "FeatureNotAvailableException":
        case "com.amazonaws.ssm#FeatureNotAvailableException":
            throw await de_FeatureNotAvailableExceptionRes(parsedOutput, context);
        case "IdempotentParameterMismatch":
        case "com.amazonaws.ssm#IdempotentParameterMismatch":
            throw await de_IdempotentParameterMismatchRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ResourceLimitExceededException":
        case "com.amazonaws.ssm#ResourceLimitExceededException":
            throw await de_ResourceLimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_RemoveTagsFromResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RemoveTagsFromResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RemoveTagsFromResourceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_RemoveTagsFromResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidResourceId":
        case "com.amazonaws.ssm#InvalidResourceId":
            throw await de_InvalidResourceIdRes(parsedOutput, context);
        case "InvalidResourceType":
        case "com.amazonaws.ssm#InvalidResourceType":
            throw await de_InvalidResourceTypeRes(parsedOutput, context);
        case "TooManyUpdates":
        case "com.amazonaws.ssm#TooManyUpdates":
            throw await de_TooManyUpdatesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ResetServiceSettingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ResetServiceSettingCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ResetServiceSettingResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ResetServiceSettingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ServiceSettingNotFound":
        case "com.amazonaws.ssm#ServiceSettingNotFound":
            throw await de_ServiceSettingNotFoundRes(parsedOutput, context);
        case "TooManyUpdates":
        case "com.amazonaws.ssm#TooManyUpdates":
            throw await de_TooManyUpdatesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_ResumeSessionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ResumeSessionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ResumeSessionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_ResumeSessionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_SendAutomationSignalCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SendAutomationSignalCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SendAutomationSignalResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_SendAutomationSignalCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AutomationExecutionNotFoundException":
        case "com.amazonaws.ssm#AutomationExecutionNotFoundException":
            throw await de_AutomationExecutionNotFoundExceptionRes(parsedOutput, context);
        case "AutomationStepNotFoundException":
        case "com.amazonaws.ssm#AutomationStepNotFoundException":
            throw await de_AutomationStepNotFoundExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidAutomationSignalException":
        case "com.amazonaws.ssm#InvalidAutomationSignalException":
            throw await de_InvalidAutomationSignalExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_SendCommandCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SendCommandCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SendCommandResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_SendCommandCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DuplicateInstanceId":
        case "com.amazonaws.ssm#DuplicateInstanceId":
            throw await de_DuplicateInstanceIdRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidDocumentVersion":
        case "com.amazonaws.ssm#InvalidDocumentVersion":
            throw await de_InvalidDocumentVersionRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        case "InvalidNotificationConfig":
        case "com.amazonaws.ssm#InvalidNotificationConfig":
            throw await de_InvalidNotificationConfigRes(parsedOutput, context);
        case "InvalidOutputFolder":
        case "com.amazonaws.ssm#InvalidOutputFolder":
            throw await de_InvalidOutputFolderRes(parsedOutput, context);
        case "InvalidParameters":
        case "com.amazonaws.ssm#InvalidParameters":
            throw await de_InvalidParametersRes(parsedOutput, context);
        case "InvalidRole":
        case "com.amazonaws.ssm#InvalidRole":
            throw await de_InvalidRoleRes(parsedOutput, context);
        case "MaxDocumentSizeExceeded":
        case "com.amazonaws.ssm#MaxDocumentSizeExceeded":
            throw await de_MaxDocumentSizeExceededRes(parsedOutput, context);
        case "UnsupportedPlatformType":
        case "com.amazonaws.ssm#UnsupportedPlatformType":
            throw await de_UnsupportedPlatformTypeRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_StartAssociationsOnceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StartAssociationsOnceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartAssociationsOnceResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_StartAssociationsOnceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AssociationDoesNotExist":
        case "com.amazonaws.ssm#AssociationDoesNotExist":
            throw await de_AssociationDoesNotExistRes(parsedOutput, context);
        case "InvalidAssociation":
        case "com.amazonaws.ssm#InvalidAssociation":
            throw await de_InvalidAssociationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_StartAutomationExecutionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StartAutomationExecutionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartAutomationExecutionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_StartAutomationExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AutomationDefinitionNotFoundException":
        case "com.amazonaws.ssm#AutomationDefinitionNotFoundException":
            throw await de_AutomationDefinitionNotFoundExceptionRes(parsedOutput, context);
        case "AutomationDefinitionVersionNotFoundException":
        case "com.amazonaws.ssm#AutomationDefinitionVersionNotFoundException":
            throw await de_AutomationDefinitionVersionNotFoundExceptionRes(parsedOutput, context);
        case "AutomationExecutionLimitExceededException":
        case "com.amazonaws.ssm#AutomationExecutionLimitExceededException":
            throw await de_AutomationExecutionLimitExceededExceptionRes(parsedOutput, context);
        case "IdempotentParameterMismatch":
        case "com.amazonaws.ssm#IdempotentParameterMismatch":
            throw await de_IdempotentParameterMismatchRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidAutomationExecutionParametersException":
        case "com.amazonaws.ssm#InvalidAutomationExecutionParametersException":
            throw await de_InvalidAutomationExecutionParametersExceptionRes(parsedOutput, context);
        case "InvalidTarget":
        case "com.amazonaws.ssm#InvalidTarget":
            throw await de_InvalidTargetRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_StartChangeRequestExecutionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StartChangeRequestExecutionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartChangeRequestExecutionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_StartChangeRequestExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AutomationDefinitionNotApprovedException":
        case "com.amazonaws.ssm#AutomationDefinitionNotApprovedException":
            throw await de_AutomationDefinitionNotApprovedExceptionRes(parsedOutput, context);
        case "AutomationDefinitionNotFoundException":
        case "com.amazonaws.ssm#AutomationDefinitionNotFoundException":
            throw await de_AutomationDefinitionNotFoundExceptionRes(parsedOutput, context);
        case "AutomationDefinitionVersionNotFoundException":
        case "com.amazonaws.ssm#AutomationDefinitionVersionNotFoundException":
            throw await de_AutomationDefinitionVersionNotFoundExceptionRes(parsedOutput, context);
        case "AutomationExecutionLimitExceededException":
        case "com.amazonaws.ssm#AutomationExecutionLimitExceededException":
            throw await de_AutomationExecutionLimitExceededExceptionRes(parsedOutput, context);
        case "IdempotentParameterMismatch":
        case "com.amazonaws.ssm#IdempotentParameterMismatch":
            throw await de_IdempotentParameterMismatchRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidAutomationExecutionParametersException":
        case "com.amazonaws.ssm#InvalidAutomationExecutionParametersException":
            throw await de_InvalidAutomationExecutionParametersExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_StartSessionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StartSessionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartSessionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_StartSessionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "TargetNotConnected":
        case "com.amazonaws.ssm#TargetNotConnected":
            throw await de_TargetNotConnectedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_StopAutomationExecutionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StopAutomationExecutionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StopAutomationExecutionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_StopAutomationExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AutomationExecutionNotFoundException":
        case "com.amazonaws.ssm#AutomationExecutionNotFoundException":
            throw await de_AutomationExecutionNotFoundExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidAutomationStatusUpdateException":
        case "com.amazonaws.ssm#InvalidAutomationStatusUpdateException":
            throw await de_InvalidAutomationStatusUpdateExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_TerminateSessionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TerminateSessionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TerminateSessionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_TerminateSessionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_UnlabelParameterVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UnlabelParameterVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UnlabelParameterVersionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_UnlabelParameterVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ParameterNotFound":
        case "com.amazonaws.ssm#ParameterNotFound":
            throw await de_ParameterNotFoundRes(parsedOutput, context);
        case "ParameterVersionNotFound":
        case "com.amazonaws.ssm#ParameterVersionNotFound":
            throw await de_ParameterVersionNotFoundRes(parsedOutput, context);
        case "TooManyUpdates":
        case "com.amazonaws.ssm#TooManyUpdates":
            throw await de_TooManyUpdatesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_UpdateAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateAssociationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateAssociationResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_UpdateAssociationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AssociationDoesNotExist":
        case "com.amazonaws.ssm#AssociationDoesNotExist":
            throw await de_AssociationDoesNotExistRes(parsedOutput, context);
        case "AssociationVersionLimitExceeded":
        case "com.amazonaws.ssm#AssociationVersionLimitExceeded":
            throw await de_AssociationVersionLimitExceededRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidAssociationVersion":
        case "com.amazonaws.ssm#InvalidAssociationVersion":
            throw await de_InvalidAssociationVersionRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidDocumentVersion":
        case "com.amazonaws.ssm#InvalidDocumentVersion":
            throw await de_InvalidDocumentVersionRes(parsedOutput, context);
        case "InvalidOutputLocation":
        case "com.amazonaws.ssm#InvalidOutputLocation":
            throw await de_InvalidOutputLocationRes(parsedOutput, context);
        case "InvalidParameters":
        case "com.amazonaws.ssm#InvalidParameters":
            throw await de_InvalidParametersRes(parsedOutput, context);
        case "InvalidSchedule":
        case "com.amazonaws.ssm#InvalidSchedule":
            throw await de_InvalidScheduleRes(parsedOutput, context);
        case "InvalidTarget":
        case "com.amazonaws.ssm#InvalidTarget":
            throw await de_InvalidTargetRes(parsedOutput, context);
        case "InvalidTargetMaps":
        case "com.amazonaws.ssm#InvalidTargetMaps":
            throw await de_InvalidTargetMapsRes(parsedOutput, context);
        case "InvalidUpdate":
        case "com.amazonaws.ssm#InvalidUpdate":
            throw await de_InvalidUpdateRes(parsedOutput, context);
        case "TooManyUpdates":
        case "com.amazonaws.ssm#TooManyUpdates":
            throw await de_TooManyUpdatesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_UpdateAssociationStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateAssociationStatusCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateAssociationStatusResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_UpdateAssociationStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AssociationDoesNotExist":
        case "com.amazonaws.ssm#AssociationDoesNotExist":
            throw await de_AssociationDoesNotExistRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        case "StatusUnchanged":
        case "com.amazonaws.ssm#StatusUnchanged":
            throw await de_StatusUnchangedRes(parsedOutput, context);
        case "TooManyUpdates":
        case "com.amazonaws.ssm#TooManyUpdates":
            throw await de_TooManyUpdatesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_UpdateDocumentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateDocumentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateDocumentResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_UpdateDocumentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DocumentVersionLimitExceeded":
        case "com.amazonaws.ssm#DocumentVersionLimitExceeded":
            throw await de_DocumentVersionLimitExceededRes(parsedOutput, context);
        case "DuplicateDocumentContent":
        case "com.amazonaws.ssm#DuplicateDocumentContent":
            throw await de_DuplicateDocumentContentRes(parsedOutput, context);
        case "DuplicateDocumentVersionName":
        case "com.amazonaws.ssm#DuplicateDocumentVersionName":
            throw await de_DuplicateDocumentVersionNameRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidDocumentContent":
        case "com.amazonaws.ssm#InvalidDocumentContent":
            throw await de_InvalidDocumentContentRes(parsedOutput, context);
        case "InvalidDocumentOperation":
        case "com.amazonaws.ssm#InvalidDocumentOperation":
            throw await de_InvalidDocumentOperationRes(parsedOutput, context);
        case "InvalidDocumentSchemaVersion":
        case "com.amazonaws.ssm#InvalidDocumentSchemaVersion":
            throw await de_InvalidDocumentSchemaVersionRes(parsedOutput, context);
        case "InvalidDocumentVersion":
        case "com.amazonaws.ssm#InvalidDocumentVersion":
            throw await de_InvalidDocumentVersionRes(parsedOutput, context);
        case "MaxDocumentSizeExceeded":
        case "com.amazonaws.ssm#MaxDocumentSizeExceeded":
            throw await de_MaxDocumentSizeExceededRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_UpdateDocumentDefaultVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateDocumentDefaultVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateDocumentDefaultVersionResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_UpdateDocumentDefaultVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidDocumentSchemaVersion":
        case "com.amazonaws.ssm#InvalidDocumentSchemaVersion":
            throw await de_InvalidDocumentSchemaVersionRes(parsedOutput, context);
        case "InvalidDocumentVersion":
        case "com.amazonaws.ssm#InvalidDocumentVersion":
            throw await de_InvalidDocumentVersionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_UpdateDocumentMetadataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateDocumentMetadataCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateDocumentMetadataResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_UpdateDocumentMetadataCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidDocument":
        case "com.amazonaws.ssm#InvalidDocument":
            throw await de_InvalidDocumentRes(parsedOutput, context);
        case "InvalidDocumentOperation":
        case "com.amazonaws.ssm#InvalidDocumentOperation":
            throw await de_InvalidDocumentOperationRes(parsedOutput, context);
        case "InvalidDocumentVersion":
        case "com.amazonaws.ssm#InvalidDocumentVersion":
            throw await de_InvalidDocumentVersionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_UpdateMaintenanceWindowCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateMaintenanceWindowCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateMaintenanceWindowResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_UpdateMaintenanceWindowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_UpdateMaintenanceWindowTargetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateMaintenanceWindowTargetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateMaintenanceWindowTargetResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_UpdateMaintenanceWindowTargetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_UpdateMaintenanceWindowTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateMaintenanceWindowTaskCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateMaintenanceWindowTaskResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_UpdateMaintenanceWindowTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_UpdateManagedInstanceRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateManagedInstanceRoleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateManagedInstanceRoleResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_UpdateManagedInstanceRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "InvalidInstanceId":
        case "com.amazonaws.ssm#InvalidInstanceId":
            throw await de_InvalidInstanceIdRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_UpdateOpsItemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateOpsItemCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateOpsItemResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_UpdateOpsItemCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "OpsItemAccessDeniedException":
        case "com.amazonaws.ssm#OpsItemAccessDeniedException":
            throw await de_OpsItemAccessDeniedExceptionRes(parsedOutput, context);
        case "OpsItemAlreadyExistsException":
        case "com.amazonaws.ssm#OpsItemAlreadyExistsException":
            throw await de_OpsItemAlreadyExistsExceptionRes(parsedOutput, context);
        case "OpsItemInvalidParameterException":
        case "com.amazonaws.ssm#OpsItemInvalidParameterException":
            throw await de_OpsItemInvalidParameterExceptionRes(parsedOutput, context);
        case "OpsItemLimitExceededException":
        case "com.amazonaws.ssm#OpsItemLimitExceededException":
            throw await de_OpsItemLimitExceededExceptionRes(parsedOutput, context);
        case "OpsItemNotFoundException":
        case "com.amazonaws.ssm#OpsItemNotFoundException":
            throw await de_OpsItemNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_UpdateOpsMetadataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateOpsMetadataCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateOpsMetadataResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_UpdateOpsMetadataCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "OpsMetadataInvalidArgumentException":
        case "com.amazonaws.ssm#OpsMetadataInvalidArgumentException":
            throw await de_OpsMetadataInvalidArgumentExceptionRes(parsedOutput, context);
        case "OpsMetadataKeyLimitExceededException":
        case "com.amazonaws.ssm#OpsMetadataKeyLimitExceededException":
            throw await de_OpsMetadataKeyLimitExceededExceptionRes(parsedOutput, context);
        case "OpsMetadataNotFoundException":
        case "com.amazonaws.ssm#OpsMetadataNotFoundException":
            throw await de_OpsMetadataNotFoundExceptionRes(parsedOutput, context);
        case "OpsMetadataTooManyUpdatesException":
        case "com.amazonaws.ssm#OpsMetadataTooManyUpdatesException":
            throw await de_OpsMetadataTooManyUpdatesExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_UpdatePatchBaselineCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdatePatchBaselineCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdatePatchBaselineResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_UpdatePatchBaselineCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DoesNotExistException":
        case "com.amazonaws.ssm#DoesNotExistException":
            throw await de_DoesNotExistExceptionRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_UpdateResourceDataSyncCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateResourceDataSyncCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateResourceDataSyncResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_UpdateResourceDataSyncCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ResourceDataSyncConflictException":
        case "com.amazonaws.ssm#ResourceDataSyncConflictException":
            throw await de_ResourceDataSyncConflictExceptionRes(parsedOutput, context);
        case "ResourceDataSyncInvalidConfigurationException":
        case "com.amazonaws.ssm#ResourceDataSyncInvalidConfigurationException":
            throw await de_ResourceDataSyncInvalidConfigurationExceptionRes(parsedOutput, context);
        case "ResourceDataSyncNotFoundException":
        case "com.amazonaws.ssm#ResourceDataSyncNotFoundException":
            throw await de_ResourceDataSyncNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const de_UpdateServiceSettingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateServiceSettingCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateServiceSettingResult(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const de_UpdateServiceSettingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerError":
        case "com.amazonaws.ssm#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "ServiceSettingNotFound":
        case "com.amazonaws.ssm#ServiceSettingNotFound":
            throw await de_ServiceSettingNotFoundRes(parsedOutput, context);
        case "TooManyUpdates":
        case "com.amazonaws.ssm#TooManyUpdates":
            throw await de_TooManyUpdatesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
const de_AlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AlreadyExistsException(body, context);
    const exception = new AlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AssociatedInstancesRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AssociatedInstances(body, context);
    const exception = new AssociatedInstances({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AssociationAlreadyExistsRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AssociationAlreadyExists(body, context);
    const exception = new AssociationAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AssociationDoesNotExistRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AssociationDoesNotExist(body, context);
    const exception = new AssociationDoesNotExist({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AssociationExecutionDoesNotExistRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AssociationExecutionDoesNotExist(body, context);
    const exception = new AssociationExecutionDoesNotExist({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AssociationLimitExceededRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AssociationLimitExceeded(body, context);
    const exception = new AssociationLimitExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AssociationVersionLimitExceededRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AssociationVersionLimitExceeded(body, context);
    const exception = new AssociationVersionLimitExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AutomationDefinitionNotApprovedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AutomationDefinitionNotApprovedException(body, context);
    const exception = new AutomationDefinitionNotApprovedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AutomationDefinitionNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AutomationDefinitionNotFoundException(body, context);
    const exception = new AutomationDefinitionNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AutomationDefinitionVersionNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AutomationDefinitionVersionNotFoundException(body, context);
    const exception = new AutomationDefinitionVersionNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AutomationExecutionLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AutomationExecutionLimitExceededException(body, context);
    const exception = new AutomationExecutionLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AutomationExecutionNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AutomationExecutionNotFoundException(body, context);
    const exception = new AutomationExecutionNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AutomationStepNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AutomationStepNotFoundException(body, context);
    const exception = new AutomationStepNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ComplianceTypeCountLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ComplianceTypeCountLimitExceededException(body, context);
    const exception = new ComplianceTypeCountLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CustomSchemaCountLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CustomSchemaCountLimitExceededException(body, context);
    const exception = new CustomSchemaCountLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DocumentAlreadyExistsRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DocumentAlreadyExists(body, context);
    const exception = new DocumentAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DocumentLimitExceededRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DocumentLimitExceeded(body, context);
    const exception = new DocumentLimitExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DocumentPermissionLimitRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DocumentPermissionLimit(body, context);
    const exception = new DocumentPermissionLimit({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DocumentVersionLimitExceededRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DocumentVersionLimitExceeded(body, context);
    const exception = new DocumentVersionLimitExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DoesNotExistExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DoesNotExistException(body, context);
    const exception = new DoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DuplicateDocumentContentRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateDocumentContent(body, context);
    const exception = new DuplicateDocumentContent({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DuplicateDocumentVersionNameRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateDocumentVersionName(body, context);
    const exception = new DuplicateDocumentVersionName({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DuplicateInstanceIdRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateInstanceId(body, context);
    const exception = new DuplicateInstanceId({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_FeatureNotAvailableExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_FeatureNotAvailableException(body, context);
    const exception = new FeatureNotAvailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_HierarchyLevelLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_HierarchyLevelLimitExceededException(body, context);
    const exception = new HierarchyLevelLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_HierarchyTypeMismatchExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_HierarchyTypeMismatchException(body, context);
    const exception = new HierarchyTypeMismatchException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_IdempotentParameterMismatchRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IdempotentParameterMismatch(body, context);
    const exception = new IdempotentParameterMismatch({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_IncompatiblePolicyExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IncompatiblePolicyException(body, context);
    const exception = new IncompatiblePolicyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InternalServerErrorRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InternalServerError(body, context);
    const exception = new InternalServerError({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidActivationRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidActivation(body, context);
    const exception = new InvalidActivation({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidActivationIdRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidActivationId(body, context);
    const exception = new InvalidActivationId({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidAggregatorExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidAggregatorException(body, context);
    const exception = new InvalidAggregatorException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidAllowedPatternExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidAllowedPatternException(body, context);
    const exception = new InvalidAllowedPatternException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidAssociationRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidAssociation(body, context);
    const exception = new InvalidAssociation({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidAssociationVersionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidAssociationVersion(body, context);
    const exception = new InvalidAssociationVersion({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidAutomationExecutionParametersExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidAutomationExecutionParametersException(body, context);
    const exception = new InvalidAutomationExecutionParametersException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidAutomationSignalExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidAutomationSignalException(body, context);
    const exception = new InvalidAutomationSignalException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidAutomationStatusUpdateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidAutomationStatusUpdateException(body, context);
    const exception = new InvalidAutomationStatusUpdateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidCommandIdRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidCommandId(body, context);
    const exception = new InvalidCommandId({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDeleteInventoryParametersExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidDeleteInventoryParametersException(body, context);
    const exception = new InvalidDeleteInventoryParametersException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDeletionIdExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidDeletionIdException(body, context);
    const exception = new InvalidDeletionIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDocumentRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidDocument(body, context);
    const exception = new InvalidDocument({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDocumentContentRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidDocumentContent(body, context);
    const exception = new InvalidDocumentContent({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDocumentOperationRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidDocumentOperation(body, context);
    const exception = new InvalidDocumentOperation({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDocumentSchemaVersionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidDocumentSchemaVersion(body, context);
    const exception = new InvalidDocumentSchemaVersion({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDocumentTypeRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidDocumentType(body, context);
    const exception = new InvalidDocumentType({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDocumentVersionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidDocumentVersion(body, context);
    const exception = new InvalidDocumentVersion({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidFilterRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidFilter(body, context);
    const exception = new InvalidFilter({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidFilterKeyRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidFilterKey(body, context);
    const exception = new InvalidFilterKey({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidFilterOptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidFilterOption(body, context);
    const exception = new InvalidFilterOption({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidFilterValueRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidFilterValue(body, context);
    const exception = new InvalidFilterValue({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidInstanceIdRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidInstanceId(body, context);
    const exception = new InvalidInstanceId({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidInstanceInformationFilterValueRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidInstanceInformationFilterValue(body, context);
    const exception = new InvalidInstanceInformationFilterValue({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidInventoryGroupExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidInventoryGroupException(body, context);
    const exception = new InvalidInventoryGroupException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidInventoryItemContextExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidInventoryItemContextException(body, context);
    const exception = new InvalidInventoryItemContextException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidInventoryRequestExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidInventoryRequestException(body, context);
    const exception = new InvalidInventoryRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidItemContentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidItemContentException(body, context);
    const exception = new InvalidItemContentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidKeyIdRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidKeyId(body, context);
    const exception = new InvalidKeyId({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidNextTokenRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidNextToken(body, context);
    const exception = new InvalidNextToken({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidNotificationConfigRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidNotificationConfig(body, context);
    const exception = new InvalidNotificationConfig({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidOptionExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidOptionException(body, context);
    const exception = new InvalidOptionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidOutputFolderRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidOutputFolder(body, context);
    const exception = new InvalidOutputFolder({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidOutputLocationRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidOutputLocation(body, context);
    const exception = new InvalidOutputLocation({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidParametersRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidParameters(body, context);
    const exception = new InvalidParameters({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidPermissionTypeRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidPermissionType(body, context);
    const exception = new InvalidPermissionType({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidPluginNameRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidPluginName(body, context);
    const exception = new InvalidPluginName({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidPolicyAttributeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidPolicyAttributeException(body, context);
    const exception = new InvalidPolicyAttributeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidPolicyTypeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidPolicyTypeException(body, context);
    const exception = new InvalidPolicyTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidResourceIdRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidResourceId(body, context);
    const exception = new InvalidResourceId({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidResourceTypeRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidResourceType(body, context);
    const exception = new InvalidResourceType({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidResultAttributeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidResultAttributeException(body, context);
    const exception = new InvalidResultAttributeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidRoleRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidRole(body, context);
    const exception = new InvalidRole({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidScheduleRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidSchedule(body, context);
    const exception = new InvalidSchedule({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidTagRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidTag(body, context);
    const exception = new InvalidTag({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidTargetRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidTarget(body, context);
    const exception = new InvalidTarget({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidTargetMapsRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidTargetMaps(body, context);
    const exception = new InvalidTargetMaps({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidTypeNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidTypeNameException(body, context);
    const exception = new InvalidTypeNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidUpdateRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidUpdate(body, context);
    const exception = new InvalidUpdate({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvocationDoesNotExistRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvocationDoesNotExist(body, context);
    const exception = new InvocationDoesNotExist({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ItemContentMismatchExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ItemContentMismatchException(body, context);
    const exception = new ItemContentMismatchException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ItemSizeLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ItemSizeLimitExceededException(body, context);
    const exception = new ItemSizeLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_MaxDocumentSizeExceededRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_MaxDocumentSizeExceeded(body, context);
    const exception = new MaxDocumentSizeExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_OpsItemAccessDeniedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_OpsItemAccessDeniedException(body, context);
    const exception = new OpsItemAccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_OpsItemAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_OpsItemAlreadyExistsException(body, context);
    const exception = new OpsItemAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_OpsItemInvalidParameterExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_OpsItemInvalidParameterException(body, context);
    const exception = new OpsItemInvalidParameterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_OpsItemLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_OpsItemLimitExceededException(body, context);
    const exception = new OpsItemLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_OpsItemNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_OpsItemNotFoundException(body, context);
    const exception = new OpsItemNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_OpsItemRelatedItemAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_OpsItemRelatedItemAlreadyExistsException(body, context);
    const exception = new OpsItemRelatedItemAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_OpsItemRelatedItemAssociationNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_OpsItemRelatedItemAssociationNotFoundException(body, context);
    const exception = new OpsItemRelatedItemAssociationNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_OpsMetadataAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_OpsMetadataAlreadyExistsException(body, context);
    const exception = new OpsMetadataAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_OpsMetadataInvalidArgumentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_OpsMetadataInvalidArgumentException(body, context);
    const exception = new OpsMetadataInvalidArgumentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_OpsMetadataKeyLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_OpsMetadataKeyLimitExceededException(body, context);
    const exception = new OpsMetadataKeyLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_OpsMetadataLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_OpsMetadataLimitExceededException(body, context);
    const exception = new OpsMetadataLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_OpsMetadataNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_OpsMetadataNotFoundException(body, context);
    const exception = new OpsMetadataNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_OpsMetadataTooManyUpdatesExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_OpsMetadataTooManyUpdatesException(body, context);
    const exception = new OpsMetadataTooManyUpdatesException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ParameterAlreadyExistsRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ParameterAlreadyExists(body, context);
    const exception = new ParameterAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ParameterLimitExceededRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ParameterLimitExceeded(body, context);
    const exception = new ParameterLimitExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ParameterMaxVersionLimitExceededRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ParameterMaxVersionLimitExceeded(body, context);
    const exception = new ParameterMaxVersionLimitExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ParameterNotFoundRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ParameterNotFound(body, context);
    const exception = new ParameterNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ParameterPatternMismatchExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ParameterPatternMismatchException(body, context);
    const exception = new ParameterPatternMismatchException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ParameterVersionLabelLimitExceededRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ParameterVersionLabelLimitExceeded(body, context);
    const exception = new ParameterVersionLabelLimitExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ParameterVersionNotFoundRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ParameterVersionNotFound(body, context);
    const exception = new ParameterVersionNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_PoliciesLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PoliciesLimitExceededException(body, context);
    const exception = new PoliciesLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceDataSyncAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceDataSyncAlreadyExistsException(body, context);
    const exception = new ResourceDataSyncAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceDataSyncConflictExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceDataSyncConflictException(body, context);
    const exception = new ResourceDataSyncConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceDataSyncCountExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceDataSyncCountExceededException(body, context);
    const exception = new ResourceDataSyncCountExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceDataSyncInvalidConfigurationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceDataSyncInvalidConfigurationException(body, context);
    const exception = new ResourceDataSyncInvalidConfigurationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceDataSyncNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceDataSyncNotFoundException(body, context);
    const exception = new ResourceDataSyncNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceInUseException(body, context);
    const exception = new ResourceInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceLimitExceededException(body, context);
    const exception = new ResourceLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourcePolicyConflictExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourcePolicyConflictException(body, context);
    const exception = new ResourcePolicyConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourcePolicyInvalidParameterExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourcePolicyInvalidParameterException(body, context);
    const exception = new ResourcePolicyInvalidParameterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourcePolicyLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourcePolicyLimitExceededException(body, context);
    const exception = new ResourcePolicyLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServiceSettingNotFoundRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ServiceSettingNotFound(body, context);
    const exception = new ServiceSettingNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_StatusUnchangedRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_StatusUnchanged(body, context);
    const exception = new StatusUnchanged({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubTypeCountLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SubTypeCountLimitExceededException(body, context);
    const exception = new SubTypeCountLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TargetInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TargetInUseException(body, context);
    const exception = new TargetInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TargetNotConnectedRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TargetNotConnected(body, context);
    const exception = new TargetNotConnected({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyTagsErrorRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyTagsError(body, context);
    const exception = new TooManyTagsError({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyUpdatesRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyUpdates(body, context);
    const exception = new TooManyUpdates({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TotalSizeLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TotalSizeLimitExceededException(body, context);
    const exception = new TotalSizeLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnsupportedCalendarExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnsupportedCalendarException(body, context);
    const exception = new UnsupportedCalendarException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnsupportedFeatureRequiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnsupportedFeatureRequiredException(body, context);
    const exception = new UnsupportedFeatureRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnsupportedInventoryItemContextExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnsupportedInventoryItemContextException(body, context);
    const exception = new UnsupportedInventoryItemContextException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnsupportedInventorySchemaVersionExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnsupportedInventorySchemaVersionException(body, context);
    const exception = new UnsupportedInventorySchemaVersionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnsupportedOperatingSystemRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnsupportedOperatingSystem(body, context);
    const exception = new UnsupportedOperatingSystem({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnsupportedParameterTypeRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnsupportedParameterType(body, context);
    const exception = new UnsupportedParameterType({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnsupportedPlatformTypeRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnsupportedPlatformType(body, context);
    const exception = new UnsupportedPlatformType({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_AccountIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_Accounts = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_AddTagsToResourceRequest = (input, context) => {
    return {
        ...(input.ResourceId != null && { ResourceId: input.ResourceId }),
        ...(input.ResourceType != null && { ResourceType: input.ResourceType }),
        ...(input.Tags != null && { Tags: se_TagList(input.Tags, context) }),
    };
};
const se_Alarm = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const se_AlarmConfiguration = (input, context) => {
    return {
        ...(input.Alarms != null && { Alarms: se_AlarmList(input.Alarms, context) }),
        ...(input.IgnorePollAlarmFailure != null && { IgnorePollAlarmFailure: input.IgnorePollAlarmFailure }),
    };
};
const se_AlarmList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Alarm(entry, context);
    });
};
const se_AssociateOpsItemRelatedItemRequest = (input, context) => {
    return {
        ...(input.AssociationType != null && { AssociationType: input.AssociationType }),
        ...(input.OpsItemId != null && { OpsItemId: input.OpsItemId }),
        ...(input.ResourceType != null && { ResourceType: input.ResourceType }),
        ...(input.ResourceUri != null && { ResourceUri: input.ResourceUri }),
    };
};
const se_AssociationExecutionFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Type != null && { Type: input.Type }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const se_AssociationExecutionFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AssociationExecutionFilter(entry, context);
    });
};
const se_AssociationExecutionTargetsFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const se_AssociationExecutionTargetsFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AssociationExecutionTargetsFilter(entry, context);
    });
};
const se_AssociationFilter = (input, context) => {
    return {
        ...(input.key != null && { key: input.key }),
        ...(input.value != null && { value: input.value }),
    };
};
const se_AssociationFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AssociationFilter(entry, context);
    });
};
const se_AssociationIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_AssociationStatus = (input, context) => {
    return {
        ...(input.AdditionalInfo != null && { AdditionalInfo: input.AdditionalInfo }),
        ...(input.Date != null && { Date: Math.round(input.Date.getTime() / 1000) }),
        ...(input.Message != null && { Message: input.Message }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const se_AttachmentsSource = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Values != null && { Values: se_AttachmentsSourceValues(input.Values, context) }),
    };
};
const se_AttachmentsSourceList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AttachmentsSource(entry, context);
    });
};
const se_AttachmentsSourceValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_AutomationExecutionFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Values != null && { Values: se_AutomationExecutionFilterValueList(input.Values, context) }),
    };
};
const se_AutomationExecutionFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AutomationExecutionFilter(entry, context);
    });
};
const se_AutomationExecutionFilterValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_AutomationParameterMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_AutomationParameterValueList(value, context);
        return acc;
    }, {});
};
const se_AutomationParameterValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_BaselineOverride = (input, context) => {
    return {
        ...(input.ApprovalRules != null && { ApprovalRules: se_PatchRuleGroup(input.ApprovalRules, context) }),
        ...(input.ApprovedPatches != null && { ApprovedPatches: se_PatchIdList(input.ApprovedPatches, context) }),
        ...(input.ApprovedPatchesComplianceLevel != null && {
            ApprovedPatchesComplianceLevel: input.ApprovedPatchesComplianceLevel,
        }),
        ...(input.ApprovedPatchesEnableNonSecurity != null && {
            ApprovedPatchesEnableNonSecurity: input.ApprovedPatchesEnableNonSecurity,
        }),
        ...(input.GlobalFilters != null && { GlobalFilters: se_PatchFilterGroup(input.GlobalFilters, context) }),
        ...(input.OperatingSystem != null && { OperatingSystem: input.OperatingSystem }),
        ...(input.RejectedPatches != null && { RejectedPatches: se_PatchIdList(input.RejectedPatches, context) }),
        ...(input.RejectedPatchesAction != null && { RejectedPatchesAction: input.RejectedPatchesAction }),
        ...(input.Sources != null && { Sources: se_PatchSourceList(input.Sources, context) }),
    };
};
const se_CalendarNameOrARNList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_CancelCommandRequest = (input, context) => {
    return {
        ...(input.CommandId != null && { CommandId: input.CommandId }),
        ...(input.InstanceIds != null && { InstanceIds: se_InstanceIdList(input.InstanceIds, context) }),
    };
};
const se_CancelMaintenanceWindowExecutionRequest = (input, context) => {
    return {
        ...(input.WindowExecutionId != null && { WindowExecutionId: input.WindowExecutionId }),
    };
};
const se_CloudWatchOutputConfig = (input, context) => {
    return {
        ...(input.CloudWatchLogGroupName != null && { CloudWatchLogGroupName: input.CloudWatchLogGroupName }),
        ...(input.CloudWatchOutputEnabled != null && { CloudWatchOutputEnabled: input.CloudWatchOutputEnabled }),
    };
};
const se_CommandFilter = (input, context) => {
    return {
        ...(input.key != null && { key: input.key }),
        ...(input.value != null && { value: input.value }),
    };
};
const se_CommandFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_CommandFilter(entry, context);
    });
};
const se_ComplianceExecutionSummary = (input, context) => {
    return {
        ...(input.ExecutionId != null && { ExecutionId: input.ExecutionId }),
        ...(input.ExecutionTime != null && { ExecutionTime: Math.round(input.ExecutionTime.getTime() / 1000) }),
        ...(input.ExecutionType != null && { ExecutionType: input.ExecutionType }),
    };
};
const se_ComplianceItemDetails = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const se_ComplianceItemEntry = (input, context) => {
    return {
        ...(input.Details != null && { Details: se_ComplianceItemDetails(input.Details, context) }),
        ...(input.Id != null && { Id: input.Id }),
        ...(input.Severity != null && { Severity: input.Severity }),
        ...(input.Status != null && { Status: input.Status }),
        ...(input.Title != null && { Title: input.Title }),
    };
};
const se_ComplianceItemEntryList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ComplianceItemEntry(entry, context);
    });
};
const se_ComplianceResourceIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_ComplianceResourceTypeList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_ComplianceStringFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Type != null && { Type: input.Type }),
        ...(input.Values != null && { Values: se_ComplianceStringFilterValueList(input.Values, context) }),
    };
};
const se_ComplianceStringFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ComplianceStringFilter(entry, context);
    });
};
const se_ComplianceStringFilterValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_CreateActivationRequest = (input, context) => {
    return {
        ...(input.DefaultInstanceName != null && { DefaultInstanceName: input.DefaultInstanceName }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.ExpirationDate != null && { ExpirationDate: Math.round(input.ExpirationDate.getTime() / 1000) }),
        ...(input.IamRole != null && { IamRole: input.IamRole }),
        ...(input.RegistrationLimit != null && { RegistrationLimit: input.RegistrationLimit }),
        ...(input.RegistrationMetadata != null && {
            RegistrationMetadata: se_RegistrationMetadataList(input.RegistrationMetadata, context),
        }),
        ...(input.Tags != null && { Tags: se_TagList(input.Tags, context) }),
    };
};
const se_CreateAssociationBatchRequest = (input, context) => {
    return {
        ...(input.Entries != null && { Entries: se_CreateAssociationBatchRequestEntries(input.Entries, context) }),
    };
};
const se_CreateAssociationBatchRequestEntries = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_CreateAssociationBatchRequestEntry(entry, context);
    });
};
const se_CreateAssociationBatchRequestEntry = (input, context) => {
    return {
        ...(input.AlarmConfiguration != null && {
            AlarmConfiguration: se_AlarmConfiguration(input.AlarmConfiguration, context),
        }),
        ...(input.ApplyOnlyAtCronInterval != null && { ApplyOnlyAtCronInterval: input.ApplyOnlyAtCronInterval }),
        ...(input.AssociationName != null && { AssociationName: input.AssociationName }),
        ...(input.AutomationTargetParameterName != null && {
            AutomationTargetParameterName: input.AutomationTargetParameterName,
        }),
        ...(input.CalendarNames != null && { CalendarNames: se_CalendarNameOrARNList(input.CalendarNames, context) }),
        ...(input.ComplianceSeverity != null && { ComplianceSeverity: input.ComplianceSeverity }),
        ...(input.DocumentVersion != null && { DocumentVersion: input.DocumentVersion }),
        ...(input.InstanceId != null && { InstanceId: input.InstanceId }),
        ...(input.MaxConcurrency != null && { MaxConcurrency: input.MaxConcurrency }),
        ...(input.MaxErrors != null && { MaxErrors: input.MaxErrors }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OutputLocation != null && {
            OutputLocation: se_InstanceAssociationOutputLocation(input.OutputLocation, context),
        }),
        ...(input.Parameters != null && { Parameters: se_Parameters(input.Parameters, context) }),
        ...(input.ScheduleExpression != null && { ScheduleExpression: input.ScheduleExpression }),
        ...(input.ScheduleOffset != null && { ScheduleOffset: input.ScheduleOffset }),
        ...(input.SyncCompliance != null && { SyncCompliance: input.SyncCompliance }),
        ...(input.TargetLocations != null && { TargetLocations: se_TargetLocations(input.TargetLocations, context) }),
        ...(input.TargetMaps != null && { TargetMaps: se_TargetMaps(input.TargetMaps, context) }),
        ...(input.Targets != null && { Targets: se_Targets(input.Targets, context) }),
    };
};
const se_CreateAssociationRequest = (input, context) => {
    return {
        ...(input.AlarmConfiguration != null && {
            AlarmConfiguration: se_AlarmConfiguration(input.AlarmConfiguration, context),
        }),
        ...(input.ApplyOnlyAtCronInterval != null && { ApplyOnlyAtCronInterval: input.ApplyOnlyAtCronInterval }),
        ...(input.AssociationName != null && { AssociationName: input.AssociationName }),
        ...(input.AutomationTargetParameterName != null && {
            AutomationTargetParameterName: input.AutomationTargetParameterName,
        }),
        ...(input.CalendarNames != null && { CalendarNames: se_CalendarNameOrARNList(input.CalendarNames, context) }),
        ...(input.ComplianceSeverity != null && { ComplianceSeverity: input.ComplianceSeverity }),
        ...(input.DocumentVersion != null && { DocumentVersion: input.DocumentVersion }),
        ...(input.InstanceId != null && { InstanceId: input.InstanceId }),
        ...(input.MaxConcurrency != null && { MaxConcurrency: input.MaxConcurrency }),
        ...(input.MaxErrors != null && { MaxErrors: input.MaxErrors }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OutputLocation != null && {
            OutputLocation: se_InstanceAssociationOutputLocation(input.OutputLocation, context),
        }),
        ...(input.Parameters != null && { Parameters: se_Parameters(input.Parameters, context) }),
        ...(input.ScheduleExpression != null && { ScheduleExpression: input.ScheduleExpression }),
        ...(input.ScheduleOffset != null && { ScheduleOffset: input.ScheduleOffset }),
        ...(input.SyncCompliance != null && { SyncCompliance: input.SyncCompliance }),
        ...(input.Tags != null && { Tags: se_TagList(input.Tags, context) }),
        ...(input.TargetLocations != null && { TargetLocations: se_TargetLocations(input.TargetLocations, context) }),
        ...(input.TargetMaps != null && { TargetMaps: se_TargetMaps(input.TargetMaps, context) }),
        ...(input.Targets != null && { Targets: se_Targets(input.Targets, context) }),
    };
};
const se_CreateDocumentRequest = (input, context) => {
    return {
        ...(input.Attachments != null && { Attachments: se_AttachmentsSourceList(input.Attachments, context) }),
        ...(input.Content != null && { Content: input.Content }),
        ...(input.DisplayName != null && { DisplayName: input.DisplayName }),
        ...(input.DocumentFormat != null && { DocumentFormat: input.DocumentFormat }),
        ...(input.DocumentType != null && { DocumentType: input.DocumentType }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Requires != null && { Requires: se_DocumentRequiresList(input.Requires, context) }),
        ...(input.Tags != null && { Tags: se_TagList(input.Tags, context) }),
        ...(input.TargetType != null && { TargetType: input.TargetType }),
        ...(input.VersionName != null && { VersionName: input.VersionName }),
    };
};
const se_CreateMaintenanceWindowRequest = (input, context) => {
    return {
        ...(input.AllowUnassociatedTargets != null && { AllowUnassociatedTargets: input.AllowUnassociatedTargets }),
        ClientToken: input.ClientToken ?? generateIdempotencyToken(),
        ...(input.Cutoff != null && { Cutoff: input.Cutoff }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.Duration != null && { Duration: input.Duration }),
        ...(input.EndDate != null && { EndDate: input.EndDate }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Schedule != null && { Schedule: input.Schedule }),
        ...(input.ScheduleOffset != null && { ScheduleOffset: input.ScheduleOffset }),
        ...(input.ScheduleTimezone != null && { ScheduleTimezone: input.ScheduleTimezone }),
        ...(input.StartDate != null && { StartDate: input.StartDate }),
        ...(input.Tags != null && { Tags: se_TagList(input.Tags, context) }),
    };
};
const se_CreateOpsItemRequest = (input, context) => {
    return {
        ...(input.AccountId != null && { AccountId: input.AccountId }),
        ...(input.ActualEndTime != null && { ActualEndTime: Math.round(input.ActualEndTime.getTime() / 1000) }),
        ...(input.ActualStartTime != null && { ActualStartTime: Math.round(input.ActualStartTime.getTime() / 1000) }),
        ...(input.Category != null && { Category: input.Category }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.Notifications != null && { Notifications: se_OpsItemNotifications(input.Notifications, context) }),
        ...(input.OperationalData != null && {
            OperationalData: se_OpsItemOperationalData(input.OperationalData, context),
        }),
        ...(input.OpsItemType != null && { OpsItemType: input.OpsItemType }),
        ...(input.PlannedEndTime != null && { PlannedEndTime: Math.round(input.PlannedEndTime.getTime() / 1000) }),
        ...(input.PlannedStartTime != null && { PlannedStartTime: Math.round(input.PlannedStartTime.getTime() / 1000) }),
        ...(input.Priority != null && { Priority: input.Priority }),
        ...(input.RelatedOpsItems != null && { RelatedOpsItems: se_RelatedOpsItems(input.RelatedOpsItems, context) }),
        ...(input.Severity != null && { Severity: input.Severity }),
        ...(input.Source != null && { Source: input.Source }),
        ...(input.Tags != null && { Tags: se_TagList(input.Tags, context) }),
        ...(input.Title != null && { Title: input.Title }),
    };
};
const se_CreateOpsMetadataRequest = (input, context) => {
    return {
        ...(input.Metadata != null && { Metadata: se_MetadataMap(input.Metadata, context) }),
        ...(input.ResourceId != null && { ResourceId: input.ResourceId }),
        ...(input.Tags != null && { Tags: se_TagList(input.Tags, context) }),
    };
};
const se_CreatePatchBaselineRequest = (input, context) => {
    return {
        ...(input.ApprovalRules != null && { ApprovalRules: se_PatchRuleGroup(input.ApprovalRules, context) }),
        ...(input.ApprovedPatches != null && { ApprovedPatches: se_PatchIdList(input.ApprovedPatches, context) }),
        ...(input.ApprovedPatchesComplianceLevel != null && {
            ApprovedPatchesComplianceLevel: input.ApprovedPatchesComplianceLevel,
        }),
        ...(input.ApprovedPatchesEnableNonSecurity != null && {
            ApprovedPatchesEnableNonSecurity: input.ApprovedPatchesEnableNonSecurity,
        }),
        ClientToken: input.ClientToken ?? generateIdempotencyToken(),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.GlobalFilters != null && { GlobalFilters: se_PatchFilterGroup(input.GlobalFilters, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OperatingSystem != null && { OperatingSystem: input.OperatingSystem }),
        ...(input.RejectedPatches != null && { RejectedPatches: se_PatchIdList(input.RejectedPatches, context) }),
        ...(input.RejectedPatchesAction != null && { RejectedPatchesAction: input.RejectedPatchesAction }),
        ...(input.Sources != null && { Sources: se_PatchSourceList(input.Sources, context) }),
        ...(input.Tags != null && { Tags: se_TagList(input.Tags, context) }),
    };
};
const se_CreateResourceDataSyncRequest = (input, context) => {
    return {
        ...(input.S3Destination != null && {
            S3Destination: se_ResourceDataSyncS3Destination(input.S3Destination, context),
        }),
        ...(input.SyncName != null && { SyncName: input.SyncName }),
        ...(input.SyncSource != null && { SyncSource: se_ResourceDataSyncSource(input.SyncSource, context) }),
        ...(input.SyncType != null && { SyncType: input.SyncType }),
    };
};
const se_DeleteActivationRequest = (input, context) => {
    return {
        ...(input.ActivationId != null && { ActivationId: input.ActivationId }),
    };
};
const se_DeleteAssociationRequest = (input, context) => {
    return {
        ...(input.AssociationId != null && { AssociationId: input.AssociationId }),
        ...(input.InstanceId != null && { InstanceId: input.InstanceId }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const se_DeleteDocumentRequest = (input, context) => {
    return {
        ...(input.DocumentVersion != null && { DocumentVersion: input.DocumentVersion }),
        ...(input.Force != null && { Force: input.Force }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.VersionName != null && { VersionName: input.VersionName }),
    };
};
const se_DeleteInventoryRequest = (input, context) => {
    return {
        ClientToken: input.ClientToken ?? generateIdempotencyToken(),
        ...(input.DryRun != null && { DryRun: input.DryRun }),
        ...(input.SchemaDeleteOption != null && { SchemaDeleteOption: input.SchemaDeleteOption }),
        ...(input.TypeName != null && { TypeName: input.TypeName }),
    };
};
const se_DeleteMaintenanceWindowRequest = (input, context) => {
    return {
        ...(input.WindowId != null && { WindowId: input.WindowId }),
    };
};
const se_DeleteOpsMetadataRequest = (input, context) => {
    return {
        ...(input.OpsMetadataArn != null && { OpsMetadataArn: input.OpsMetadataArn }),
    };
};
const se_DeleteParameterRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const se_DeleteParametersRequest = (input, context) => {
    return {
        ...(input.Names != null && { Names: se_ParameterNameList(input.Names, context) }),
    };
};
const se_DeletePatchBaselineRequest = (input, context) => {
    return {
        ...(input.BaselineId != null && { BaselineId: input.BaselineId }),
    };
};
const se_DeleteResourceDataSyncRequest = (input, context) => {
    return {
        ...(input.SyncName != null && { SyncName: input.SyncName }),
        ...(input.SyncType != null && { SyncType: input.SyncType }),
    };
};
const se_DeleteResourcePolicyRequest = (input, context) => {
    return {
        ...(input.PolicyHash != null && { PolicyHash: input.PolicyHash }),
        ...(input.PolicyId != null && { PolicyId: input.PolicyId }),
        ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
    };
};
const se_DeregisterManagedInstanceRequest = (input, context) => {
    return {
        ...(input.InstanceId != null && { InstanceId: input.InstanceId }),
    };
};
const se_DeregisterPatchBaselineForPatchGroupRequest = (input, context) => {
    return {
        ...(input.BaselineId != null && { BaselineId: input.BaselineId }),
        ...(input.PatchGroup != null && { PatchGroup: input.PatchGroup }),
    };
};
const se_DeregisterTargetFromMaintenanceWindowRequest = (input, context) => {
    return {
        ...(input.Safe != null && { Safe: input.Safe }),
        ...(input.WindowId != null && { WindowId: input.WindowId }),
        ...(input.WindowTargetId != null && { WindowTargetId: input.WindowTargetId }),
    };
};
const se_DeregisterTaskFromMaintenanceWindowRequest = (input, context) => {
    return {
        ...(input.WindowId != null && { WindowId: input.WindowId }),
        ...(input.WindowTaskId != null && { WindowTaskId: input.WindowTaskId }),
    };
};
const se_DescribeActivationsFilter = (input, context) => {
    return {
        ...(input.FilterKey != null && { FilterKey: input.FilterKey }),
        ...(input.FilterValues != null && { FilterValues: se_StringList(input.FilterValues, context) }),
    };
};
const se_DescribeActivationsFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_DescribeActivationsFilter(entry, context);
    });
};
const se_DescribeActivationsRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_DescribeActivationsFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_DescribeAssociationExecutionsRequest = (input, context) => {
    return {
        ...(input.AssociationId != null && { AssociationId: input.AssociationId }),
        ...(input.Filters != null && { Filters: se_AssociationExecutionFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_DescribeAssociationExecutionTargetsRequest = (input, context) => {
    return {
        ...(input.AssociationId != null && { AssociationId: input.AssociationId }),
        ...(input.ExecutionId != null && { ExecutionId: input.ExecutionId }),
        ...(input.Filters != null && { Filters: se_AssociationExecutionTargetsFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_DescribeAssociationRequest = (input, context) => {
    return {
        ...(input.AssociationId != null && { AssociationId: input.AssociationId }),
        ...(input.AssociationVersion != null && { AssociationVersion: input.AssociationVersion }),
        ...(input.InstanceId != null && { InstanceId: input.InstanceId }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const se_DescribeAutomationExecutionsRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_AutomationExecutionFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_DescribeAutomationStepExecutionsRequest = (input, context) => {
    return {
        ...(input.AutomationExecutionId != null && { AutomationExecutionId: input.AutomationExecutionId }),
        ...(input.Filters != null && { Filters: se_StepExecutionFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.ReverseOrder != null && { ReverseOrder: input.ReverseOrder }),
    };
};
const se_DescribeAvailablePatchesRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_PatchOrchestratorFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_DescribeDocumentPermissionRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.PermissionType != null && { PermissionType: input.PermissionType }),
    };
};
const se_DescribeDocumentRequest = (input, context) => {
    return {
        ...(input.DocumentVersion != null && { DocumentVersion: input.DocumentVersion }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.VersionName != null && { VersionName: input.VersionName }),
    };
};
const se_DescribeEffectiveInstanceAssociationsRequest = (input, context) => {
    return {
        ...(input.InstanceId != null && { InstanceId: input.InstanceId }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_DescribeEffectivePatchesForPatchBaselineRequest = (input, context) => {
    return {
        ...(input.BaselineId != null && { BaselineId: input.BaselineId }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_DescribeInstanceAssociationsStatusRequest = (input, context) => {
    return {
        ...(input.InstanceId != null && { InstanceId: input.InstanceId }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_DescribeInstanceInformationRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_InstanceInformationStringFilterList(input.Filters, context) }),
        ...(input.InstanceInformationFilterList != null && {
            InstanceInformationFilterList: se_InstanceInformationFilterList(input.InstanceInformationFilterList, context),
        }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_DescribeInstancePatchesRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_PatchOrchestratorFilterList(input.Filters, context) }),
        ...(input.InstanceId != null && { InstanceId: input.InstanceId }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_DescribeInstancePatchStatesForPatchGroupRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_InstancePatchStateFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.PatchGroup != null && { PatchGroup: input.PatchGroup }),
    };
};
const se_DescribeInstancePatchStatesRequest = (input, context) => {
    return {
        ...(input.InstanceIds != null && { InstanceIds: se_InstanceIdList(input.InstanceIds, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_DescribeInventoryDeletionsRequest = (input, context) => {
    return {
        ...(input.DeletionId != null && { DeletionId: input.DeletionId }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_DescribeMaintenanceWindowExecutionsRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_MaintenanceWindowFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.WindowId != null && { WindowId: input.WindowId }),
    };
};
const se_DescribeMaintenanceWindowExecutionTaskInvocationsRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_MaintenanceWindowFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.TaskId != null && { TaskId: input.TaskId }),
        ...(input.WindowExecutionId != null && { WindowExecutionId: input.WindowExecutionId }),
    };
};
const se_DescribeMaintenanceWindowExecutionTasksRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_MaintenanceWindowFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.WindowExecutionId != null && { WindowExecutionId: input.WindowExecutionId }),
    };
};
const se_DescribeMaintenanceWindowScheduleRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_PatchOrchestratorFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.ResourceType != null && { ResourceType: input.ResourceType }),
        ...(input.Targets != null && { Targets: se_Targets(input.Targets, context) }),
        ...(input.WindowId != null && { WindowId: input.WindowId }),
    };
};
const se_DescribeMaintenanceWindowsForTargetRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.ResourceType != null && { ResourceType: input.ResourceType }),
        ...(input.Targets != null && { Targets: se_Targets(input.Targets, context) }),
    };
};
const se_DescribeMaintenanceWindowsRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_MaintenanceWindowFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_DescribeMaintenanceWindowTargetsRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_MaintenanceWindowFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.WindowId != null && { WindowId: input.WindowId }),
    };
};
const se_DescribeMaintenanceWindowTasksRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_MaintenanceWindowFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.WindowId != null && { WindowId: input.WindowId }),
    };
};
const se_DescribeOpsItemsRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.OpsItemFilters != null && { OpsItemFilters: se_OpsItemFilters(input.OpsItemFilters, context) }),
    };
};
const se_DescribeParametersRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_ParametersFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.ParameterFilters != null && {
            ParameterFilters: se_ParameterStringFilterList(input.ParameterFilters, context),
        }),
    };
};
const se_DescribePatchBaselinesRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_PatchOrchestratorFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_DescribePatchGroupsRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_PatchOrchestratorFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_DescribePatchGroupStateRequest = (input, context) => {
    return {
        ...(input.PatchGroup != null && { PatchGroup: input.PatchGroup }),
    };
};
const se_DescribePatchPropertiesRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.OperatingSystem != null && { OperatingSystem: input.OperatingSystem }),
        ...(input.PatchSet != null && { PatchSet: input.PatchSet }),
        ...(input.Property != null && { Property: input.Property }),
    };
};
const se_DescribeSessionsRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_SessionFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.State != null && { State: input.State }),
    };
};
const se_DisassociateOpsItemRelatedItemRequest = (input, context) => {
    return {
        ...(input.AssociationId != null && { AssociationId: input.AssociationId }),
        ...(input.OpsItemId != null && { OpsItemId: input.OpsItemId }),
    };
};
const se_DocumentFilter = (input, context) => {
    return {
        ...(input.key != null && { key: input.key }),
        ...(input.value != null && { value: input.value }),
    };
};
const se_DocumentFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_DocumentFilter(entry, context);
    });
};
const se_DocumentKeyValuesFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Values != null && { Values: se_DocumentKeyValuesFilterValues(input.Values, context) }),
    };
};
const se_DocumentKeyValuesFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_DocumentKeyValuesFilter(entry, context);
    });
};
const se_DocumentKeyValuesFilterValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_DocumentRequires = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
        ...(input.RequireType != null && { RequireType: input.RequireType }),
        ...(input.Version != null && { Version: input.Version }),
        ...(input.VersionName != null && { VersionName: input.VersionName }),
    };
};
const se_DocumentRequiresList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_DocumentRequires(entry, context);
    });
};
const se_DocumentReviewCommentList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_DocumentReviewCommentSource(entry, context);
    });
};
const se_DocumentReviewCommentSource = (input, context) => {
    return {
        ...(input.Content != null && { Content: input.Content }),
        ...(input.Type != null && { Type: input.Type }),
    };
};
const se_DocumentReviews = (input, context) => {
    return {
        ...(input.Action != null && { Action: input.Action }),
        ...(input.Comment != null && { Comment: se_DocumentReviewCommentList(input.Comment, context) }),
    };
};
const se_GetAutomationExecutionRequest = (input, context) => {
    return {
        ...(input.AutomationExecutionId != null && { AutomationExecutionId: input.AutomationExecutionId }),
    };
};
const se_GetCalendarStateRequest = (input, context) => {
    return {
        ...(input.AtTime != null && { AtTime: input.AtTime }),
        ...(input.CalendarNames != null && { CalendarNames: se_CalendarNameOrARNList(input.CalendarNames, context) }),
    };
};
const se_GetCommandInvocationRequest = (input, context) => {
    return {
        ...(input.CommandId != null && { CommandId: input.CommandId }),
        ...(input.InstanceId != null && { InstanceId: input.InstanceId }),
        ...(input.PluginName != null && { PluginName: input.PluginName }),
    };
};
const se_GetConnectionStatusRequest = (input, context) => {
    return {
        ...(input.Target != null && { Target: input.Target }),
    };
};
const se_GetDefaultPatchBaselineRequest = (input, context) => {
    return {
        ...(input.OperatingSystem != null && { OperatingSystem: input.OperatingSystem }),
    };
};
const se_GetDeployablePatchSnapshotForInstanceRequest = (input, context) => {
    return {
        ...(input.BaselineOverride != null && { BaselineOverride: se_BaselineOverride(input.BaselineOverride, context) }),
        ...(input.InstanceId != null && { InstanceId: input.InstanceId }),
        ...(input.SnapshotId != null && { SnapshotId: input.SnapshotId }),
    };
};
const se_GetDocumentRequest = (input, context) => {
    return {
        ...(input.DocumentFormat != null && { DocumentFormat: input.DocumentFormat }),
        ...(input.DocumentVersion != null && { DocumentVersion: input.DocumentVersion }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.VersionName != null && { VersionName: input.VersionName }),
    };
};
const se_GetInventoryRequest = (input, context) => {
    return {
        ...(input.Aggregators != null && { Aggregators: se_InventoryAggregatorList(input.Aggregators, context) }),
        ...(input.Filters != null && { Filters: se_InventoryFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.ResultAttributes != null && {
            ResultAttributes: se_ResultAttributeList(input.ResultAttributes, context),
        }),
    };
};
const se_GetInventorySchemaRequest = (input, context) => {
    return {
        ...(input.Aggregator != null && { Aggregator: input.Aggregator }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.SubType != null && { SubType: input.SubType }),
        ...(input.TypeName != null && { TypeName: input.TypeName }),
    };
};
const se_GetMaintenanceWindowExecutionRequest = (input, context) => {
    return {
        ...(input.WindowExecutionId != null && { WindowExecutionId: input.WindowExecutionId }),
    };
};
const se_GetMaintenanceWindowExecutionTaskInvocationRequest = (input, context) => {
    return {
        ...(input.InvocationId != null && { InvocationId: input.InvocationId }),
        ...(input.TaskId != null && { TaskId: input.TaskId }),
        ...(input.WindowExecutionId != null && { WindowExecutionId: input.WindowExecutionId }),
    };
};
const se_GetMaintenanceWindowExecutionTaskRequest = (input, context) => {
    return {
        ...(input.TaskId != null && { TaskId: input.TaskId }),
        ...(input.WindowExecutionId != null && { WindowExecutionId: input.WindowExecutionId }),
    };
};
const se_GetMaintenanceWindowRequest = (input, context) => {
    return {
        ...(input.WindowId != null && { WindowId: input.WindowId }),
    };
};
const se_GetMaintenanceWindowTaskRequest = (input, context) => {
    return {
        ...(input.WindowId != null && { WindowId: input.WindowId }),
        ...(input.WindowTaskId != null && { WindowTaskId: input.WindowTaskId }),
    };
};
const se_GetOpsItemRequest = (input, context) => {
    return {
        ...(input.OpsItemArn != null && { OpsItemArn: input.OpsItemArn }),
        ...(input.OpsItemId != null && { OpsItemId: input.OpsItemId }),
    };
};
const se_GetOpsMetadataRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.OpsMetadataArn != null && { OpsMetadataArn: input.OpsMetadataArn }),
    };
};
const se_GetOpsSummaryRequest = (input, context) => {
    return {
        ...(input.Aggregators != null && { Aggregators: se_OpsAggregatorList(input.Aggregators, context) }),
        ...(input.Filters != null && { Filters: se_OpsFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.ResultAttributes != null && {
            ResultAttributes: se_OpsResultAttributeList(input.ResultAttributes, context),
        }),
        ...(input.SyncName != null && { SyncName: input.SyncName }),
    };
};
const se_GetParameterHistoryRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.WithDecryption != null && { WithDecryption: input.WithDecryption }),
    };
};
const se_GetParameterRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
        ...(input.WithDecryption != null && { WithDecryption: input.WithDecryption }),
    };
};
const se_GetParametersByPathRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.ParameterFilters != null && {
            ParameterFilters: se_ParameterStringFilterList(input.ParameterFilters, context),
        }),
        ...(input.Path != null && { Path: input.Path }),
        ...(input.Recursive != null && { Recursive: input.Recursive }),
        ...(input.WithDecryption != null && { WithDecryption: input.WithDecryption }),
    };
};
const se_GetParametersRequest = (input, context) => {
    return {
        ...(input.Names != null && { Names: se_ParameterNameList(input.Names, context) }),
        ...(input.WithDecryption != null && { WithDecryption: input.WithDecryption }),
    };
};
const se_GetPatchBaselineForPatchGroupRequest = (input, context) => {
    return {
        ...(input.OperatingSystem != null && { OperatingSystem: input.OperatingSystem }),
        ...(input.PatchGroup != null && { PatchGroup: input.PatchGroup }),
    };
};
const se_GetPatchBaselineRequest = (input, context) => {
    return {
        ...(input.BaselineId != null && { BaselineId: input.BaselineId }),
    };
};
const se_GetResourcePoliciesRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
    };
};
const se_GetServiceSettingRequest = (input, context) => {
    return {
        ...(input.SettingId != null && { SettingId: input.SettingId }),
    };
};
const se_InstanceAssociationOutputLocation = (input, context) => {
    return {
        ...(input.S3Location != null && { S3Location: se_S3OutputLocation(input.S3Location, context) }),
    };
};
const se_InstanceIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_InstanceInformationFilter = (input, context) => {
    return {
        ...(input.key != null && { key: input.key }),
        ...(input.valueSet != null && { valueSet: se_InstanceInformationFilterValueSet(input.valueSet, context) }),
    };
};
const se_InstanceInformationFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_InstanceInformationFilter(entry, context);
    });
};
const se_InstanceInformationFilterValueSet = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_InstanceInformationStringFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Values != null && { Values: se_InstanceInformationFilterValueSet(input.Values, context) }),
    };
};
const se_InstanceInformationStringFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_InstanceInformationStringFilter(entry, context);
    });
};
const se_InstancePatchStateFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Type != null && { Type: input.Type }),
        ...(input.Values != null && { Values: se_InstancePatchStateFilterValues(input.Values, context) }),
    };
};
const se_InstancePatchStateFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_InstancePatchStateFilter(entry, context);
    });
};
const se_InstancePatchStateFilterValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_InventoryAggregator = (input, context) => {
    return {
        ...(input.Aggregators != null && { Aggregators: se_InventoryAggregatorList(input.Aggregators, context) }),
        ...(input.Expression != null && { Expression: input.Expression }),
        ...(input.Groups != null && { Groups: se_InventoryGroupList(input.Groups, context) }),
    };
};
const se_InventoryAggregatorList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_InventoryAggregator(entry, context);
    });
};
const se_InventoryFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Type != null && { Type: input.Type }),
        ...(input.Values != null && { Values: se_InventoryFilterValueList(input.Values, context) }),
    };
};
const se_InventoryFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_InventoryFilter(entry, context);
    });
};
const se_InventoryFilterValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_InventoryGroup = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_InventoryFilterList(input.Filters, context) }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const se_InventoryGroupList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_InventoryGroup(entry, context);
    });
};
const se_InventoryItem = (input, context) => {
    return {
        ...(input.CaptureTime != null && { CaptureTime: input.CaptureTime }),
        ...(input.Content != null && { Content: se_InventoryItemEntryList(input.Content, context) }),
        ...(input.ContentHash != null && { ContentHash: input.ContentHash }),
        ...(input.Context != null && { Context: se_InventoryItemContentContext(input.Context, context) }),
        ...(input.SchemaVersion != null && { SchemaVersion: input.SchemaVersion }),
        ...(input.TypeName != null && { TypeName: input.TypeName }),
    };
};
const se_InventoryItemContentContext = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const se_InventoryItemEntry = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const se_InventoryItemEntryList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_InventoryItemEntry(entry, context);
    });
};
const se_InventoryItemList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_InventoryItem(entry, context);
    });
};
const se_KeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_LabelParameterVersionRequest = (input, context) => {
    return {
        ...(input.Labels != null && { Labels: se_ParameterLabelList(input.Labels, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.ParameterVersion != null && { ParameterVersion: input.ParameterVersion }),
    };
};
const se_ListAssociationsRequest = (input, context) => {
    return {
        ...(input.AssociationFilterList != null && {
            AssociationFilterList: se_AssociationFilterList(input.AssociationFilterList, context),
        }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_ListAssociationVersionsRequest = (input, context) => {
    return {
        ...(input.AssociationId != null && { AssociationId: input.AssociationId }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_ListCommandInvocationsRequest = (input, context) => {
    return {
        ...(input.CommandId != null && { CommandId: input.CommandId }),
        ...(input.Details != null && { Details: input.Details }),
        ...(input.Filters != null && { Filters: se_CommandFilterList(input.Filters, context) }),
        ...(input.InstanceId != null && { InstanceId: input.InstanceId }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_ListCommandsRequest = (input, context) => {
    return {
        ...(input.CommandId != null && { CommandId: input.CommandId }),
        ...(input.Filters != null && { Filters: se_CommandFilterList(input.Filters, context) }),
        ...(input.InstanceId != null && { InstanceId: input.InstanceId }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_ListComplianceItemsRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_ComplianceStringFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.ResourceIds != null && { ResourceIds: se_ComplianceResourceIdList(input.ResourceIds, context) }),
        ...(input.ResourceTypes != null && { ResourceTypes: se_ComplianceResourceTypeList(input.ResourceTypes, context) }),
    };
};
const se_ListComplianceSummariesRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_ComplianceStringFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_ListDocumentMetadataHistoryRequest = (input, context) => {
    return {
        ...(input.DocumentVersion != null && { DocumentVersion: input.DocumentVersion }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.Metadata != null && { Metadata: input.Metadata }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_ListDocumentsRequest = (input, context) => {
    return {
        ...(input.DocumentFilterList != null && {
            DocumentFilterList: se_DocumentFilterList(input.DocumentFilterList, context),
        }),
        ...(input.Filters != null && { Filters: se_DocumentKeyValuesFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_ListDocumentVersionsRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_ListInventoryEntriesRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_InventoryFilterList(input.Filters, context) }),
        ...(input.InstanceId != null && { InstanceId: input.InstanceId }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.TypeName != null && { TypeName: input.TypeName }),
    };
};
const se_ListOpsItemEventsRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_OpsItemEventFilters(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_ListOpsItemRelatedItemsRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_OpsItemRelatedItemsFilters(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.OpsItemId != null && { OpsItemId: input.OpsItemId }),
    };
};
const se_ListOpsMetadataRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_OpsMetadataFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_ListResourceComplianceSummariesRequest = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: se_ComplianceStringFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const se_ListResourceDataSyncRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.SyncType != null && { SyncType: input.SyncType }),
    };
};
const se_ListTagsForResourceRequest = (input, context) => {
    return {
        ...(input.ResourceId != null && { ResourceId: input.ResourceId }),
        ...(input.ResourceType != null && { ResourceType: input.ResourceType }),
    };
};
const se_LoggingInfo = (input, context) => {
    return {
        ...(input.S3BucketName != null && { S3BucketName: input.S3BucketName }),
        ...(input.S3KeyPrefix != null && { S3KeyPrefix: input.S3KeyPrefix }),
        ...(input.S3Region != null && { S3Region: input.S3Region }),
    };
};
const se_MaintenanceWindowAutomationParameters = (input, context) => {
    return {
        ...(input.DocumentVersion != null && { DocumentVersion: input.DocumentVersion }),
        ...(input.Parameters != null && { Parameters: se_AutomationParameterMap(input.Parameters, context) }),
    };
};
const se_MaintenanceWindowFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Values != null && { Values: se_MaintenanceWindowFilterValues(input.Values, context) }),
    };
};
const se_MaintenanceWindowFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_MaintenanceWindowFilter(entry, context);
    });
};
const se_MaintenanceWindowFilterValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_MaintenanceWindowLambdaParameters = (input, context) => {
    return {
        ...(input.ClientContext != null && { ClientContext: input.ClientContext }),
        ...(input.Payload != null && { Payload: context.base64Encoder(input.Payload) }),
        ...(input.Qualifier != null && { Qualifier: input.Qualifier }),
    };
};
const se_MaintenanceWindowRunCommandParameters = (input, context) => {
    return {
        ...(input.CloudWatchOutputConfig != null && {
            CloudWatchOutputConfig: se_CloudWatchOutputConfig(input.CloudWatchOutputConfig, context),
        }),
        ...(input.Comment != null && { Comment: input.Comment }),
        ...(input.DocumentHash != null && { DocumentHash: input.DocumentHash }),
        ...(input.DocumentHashType != null && { DocumentHashType: input.DocumentHashType }),
        ...(input.DocumentVersion != null && { DocumentVersion: input.DocumentVersion }),
        ...(input.NotificationConfig != null && {
            NotificationConfig: se_NotificationConfig(input.NotificationConfig, context),
        }),
        ...(input.OutputS3BucketName != null && { OutputS3BucketName: input.OutputS3BucketName }),
        ...(input.OutputS3KeyPrefix != null && { OutputS3KeyPrefix: input.OutputS3KeyPrefix }),
        ...(input.Parameters != null && { Parameters: se_Parameters(input.Parameters, context) }),
        ...(input.ServiceRoleArn != null && { ServiceRoleArn: input.ServiceRoleArn }),
        ...(input.TimeoutSeconds != null && { TimeoutSeconds: input.TimeoutSeconds }),
    };
};
const se_MaintenanceWindowStepFunctionsParameters = (input, context) => {
    return {
        ...(input.Input != null && { Input: input.Input }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const se_MaintenanceWindowTaskInvocationParameters = (input, context) => {
    return {
        ...(input.Automation != null && {
            Automation: se_MaintenanceWindowAutomationParameters(input.Automation, context),
        }),
        ...(input.Lambda != null && { Lambda: se_MaintenanceWindowLambdaParameters(input.Lambda, context) }),
        ...(input.RunCommand != null && {
            RunCommand: se_MaintenanceWindowRunCommandParameters(input.RunCommand, context),
        }),
        ...(input.StepFunctions != null && {
            StepFunctions: se_MaintenanceWindowStepFunctionsParameters(input.StepFunctions, context),
        }),
    };
};
const se_MaintenanceWindowTaskParameters = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_MaintenanceWindowTaskParameterValueExpression(value, context);
        return acc;
    }, {});
};
const se_MaintenanceWindowTaskParameterValueExpression = (input, context) => {
    return {
        ...(input.Values != null && { Values: se_MaintenanceWindowTaskParameterValueList(input.Values, context) }),
    };
};
const se_MaintenanceWindowTaskParameterValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_MetadataKeysToDeleteList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_MetadataMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_MetadataValue(value, context);
        return acc;
    }, {});
};
const se_MetadataValue = (input, context) => {
    return {
        ...(input.Value != null && { Value: input.Value }),
    };
};
const se_ModifyDocumentPermissionRequest = (input, context) => {
    return {
        ...(input.AccountIdsToAdd != null && { AccountIdsToAdd: se_AccountIdList(input.AccountIdsToAdd, context) }),
        ...(input.AccountIdsToRemove != null && {
            AccountIdsToRemove: se_AccountIdList(input.AccountIdsToRemove, context),
        }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.PermissionType != null && { PermissionType: input.PermissionType }),
        ...(input.SharedDocumentVersion != null && { SharedDocumentVersion: input.SharedDocumentVersion }),
    };
};
const se_NotificationConfig = (input, context) => {
    return {
        ...(input.NotificationArn != null && { NotificationArn: input.NotificationArn }),
        ...(input.NotificationEvents != null && {
            NotificationEvents: se_NotificationEventList(input.NotificationEvents, context),
        }),
        ...(input.NotificationType != null && { NotificationType: input.NotificationType }),
    };
};
const se_NotificationEventList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_OpsAggregator = (input, context) => {
    return {
        ...(input.AggregatorType != null && { AggregatorType: input.AggregatorType }),
        ...(input.Aggregators != null && { Aggregators: se_OpsAggregatorList(input.Aggregators, context) }),
        ...(input.AttributeName != null && { AttributeName: input.AttributeName }),
        ...(input.Filters != null && { Filters: se_OpsFilterList(input.Filters, context) }),
        ...(input.TypeName != null && { TypeName: input.TypeName }),
        ...(input.Values != null && { Values: se_OpsAggregatorValueMap(input.Values, context) }),
    };
};
const se_OpsAggregatorList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_OpsAggregator(entry, context);
    });
};
const se_OpsAggregatorValueMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const se_OpsFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Type != null && { Type: input.Type }),
        ...(input.Values != null && { Values: se_OpsFilterValueList(input.Values, context) }),
    };
};
const se_OpsFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_OpsFilter(entry, context);
    });
};
const se_OpsFilterValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_OpsItemDataValue = (input, context) => {
    return {
        ...(input.Type != null && { Type: input.Type }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const se_OpsItemEventFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Operator != null && { Operator: input.Operator }),
        ...(input.Values != null && { Values: se_OpsItemEventFilterValues(input.Values, context) }),
    };
};
const se_OpsItemEventFilters = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_OpsItemEventFilter(entry, context);
    });
};
const se_OpsItemEventFilterValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_OpsItemFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Operator != null && { Operator: input.Operator }),
        ...(input.Values != null && { Values: se_OpsItemFilterValues(input.Values, context) }),
    };
};
const se_OpsItemFilters = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_OpsItemFilter(entry, context);
    });
};
const se_OpsItemFilterValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_OpsItemNotification = (input, context) => {
    return {
        ...(input.Arn != null && { Arn: input.Arn }),
    };
};
const se_OpsItemNotifications = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_OpsItemNotification(entry, context);
    });
};
const se_OpsItemOperationalData = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_OpsItemDataValue(value, context);
        return acc;
    }, {});
};
const se_OpsItemOpsDataKeysList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_OpsItemRelatedItemsFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Operator != null && { Operator: input.Operator }),
        ...(input.Values != null && { Values: se_OpsItemRelatedItemsFilterValues(input.Values, context) }),
    };
};
const se_OpsItemRelatedItemsFilters = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_OpsItemRelatedItemsFilter(entry, context);
    });
};
const se_OpsItemRelatedItemsFilterValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_OpsMetadataFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Values != null && { Values: se_OpsMetadataFilterValueList(input.Values, context) }),
    };
};
const se_OpsMetadataFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_OpsMetadataFilter(entry, context);
    });
};
const se_OpsMetadataFilterValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_OpsResultAttribute = (input, context) => {
    return {
        ...(input.TypeName != null && { TypeName: input.TypeName }),
    };
};
const se_OpsResultAttributeList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_OpsResultAttribute(entry, context);
    });
};
const se_ParameterLabelList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_ParameterNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_Parameters = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_ParameterValueList(value, context);
        return acc;
    }, {});
};
const se_ParametersFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Values != null && { Values: se_ParametersFilterValueList(input.Values, context) }),
    };
};
const se_ParametersFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ParametersFilter(entry, context);
    });
};
const se_ParametersFilterValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_ParameterStringFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Option != null && { Option: input.Option }),
        ...(input.Values != null && { Values: se_ParameterStringFilterValueList(input.Values, context) }),
    };
};
const se_ParameterStringFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ParameterStringFilter(entry, context);
    });
};
const se_ParameterStringFilterValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_ParameterValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_PatchFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Values != null && { Values: se_PatchFilterValueList(input.Values, context) }),
    };
};
const se_PatchFilterGroup = (input, context) => {
    return {
        ...(input.PatchFilters != null && { PatchFilters: se_PatchFilterList(input.PatchFilters, context) }),
    };
};
const se_PatchFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_PatchFilter(entry, context);
    });
};
const se_PatchFilterValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_PatchIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_PatchOrchestratorFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Values != null && { Values: se_PatchOrchestratorFilterValues(input.Values, context) }),
    };
};
const se_PatchOrchestratorFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_PatchOrchestratorFilter(entry, context);
    });
};
const se_PatchOrchestratorFilterValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_PatchRule = (input, context) => {
    return {
        ...(input.ApproveAfterDays != null && { ApproveAfterDays: input.ApproveAfterDays }),
        ...(input.ApproveUntilDate != null && { ApproveUntilDate: input.ApproveUntilDate }),
        ...(input.ComplianceLevel != null && { ComplianceLevel: input.ComplianceLevel }),
        ...(input.EnableNonSecurity != null && { EnableNonSecurity: input.EnableNonSecurity }),
        ...(input.PatchFilterGroup != null && { PatchFilterGroup: se_PatchFilterGroup(input.PatchFilterGroup, context) }),
    };
};
const se_PatchRuleGroup = (input, context) => {
    return {
        ...(input.PatchRules != null && { PatchRules: se_PatchRuleList(input.PatchRules, context) }),
    };
};
const se_PatchRuleList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_PatchRule(entry, context);
    });
};
const se_PatchSource = (input, context) => {
    return {
        ...(input.Configuration != null && { Configuration: input.Configuration }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Products != null && { Products: se_PatchSourceProductList(input.Products, context) }),
    };
};
const se_PatchSourceList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_PatchSource(entry, context);
    });
};
const se_PatchSourceProductList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_PutComplianceItemsRequest = (input, context) => {
    return {
        ...(input.ComplianceType != null && { ComplianceType: input.ComplianceType }),
        ...(input.ExecutionSummary != null && {
            ExecutionSummary: se_ComplianceExecutionSummary(input.ExecutionSummary, context),
        }),
        ...(input.ItemContentHash != null && { ItemContentHash: input.ItemContentHash }),
        ...(input.Items != null && { Items: se_ComplianceItemEntryList(input.Items, context) }),
        ...(input.ResourceId != null && { ResourceId: input.ResourceId }),
        ...(input.ResourceType != null && { ResourceType: input.ResourceType }),
        ...(input.UploadType != null && { UploadType: input.UploadType }),
    };
};
const se_PutInventoryRequest = (input, context) => {
    return {
        ...(input.InstanceId != null && { InstanceId: input.InstanceId }),
        ...(input.Items != null && { Items: se_InventoryItemList(input.Items, context) }),
    };
};
const se_PutParameterRequest = (input, context) => {
    return {
        ...(input.AllowedPattern != null && { AllowedPattern: input.AllowedPattern }),
        ...(input.DataType != null && { DataType: input.DataType }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Overwrite != null && { Overwrite: input.Overwrite }),
        ...(input.Policies != null && { Policies: input.Policies }),
        ...(input.Tags != null && { Tags: se_TagList(input.Tags, context) }),
        ...(input.Tier != null && { Tier: input.Tier }),
        ...(input.Type != null && { Type: input.Type }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const se_PutResourcePolicyRequest = (input, context) => {
    return {
        ...(input.Policy != null && { Policy: input.Policy }),
        ...(input.PolicyHash != null && { PolicyHash: input.PolicyHash }),
        ...(input.PolicyId != null && { PolicyId: input.PolicyId }),
        ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
    };
};
const se_Regions = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_RegisterDefaultPatchBaselineRequest = (input, context) => {
    return {
        ...(input.BaselineId != null && { BaselineId: input.BaselineId }),
    };
};
const se_RegisterPatchBaselineForPatchGroupRequest = (input, context) => {
    return {
        ...(input.BaselineId != null && { BaselineId: input.BaselineId }),
        ...(input.PatchGroup != null && { PatchGroup: input.PatchGroup }),
    };
};
const se_RegisterTargetWithMaintenanceWindowRequest = (input, context) => {
    return {
        ClientToken: input.ClientToken ?? generateIdempotencyToken(),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OwnerInformation != null && { OwnerInformation: input.OwnerInformation }),
        ...(input.ResourceType != null && { ResourceType: input.ResourceType }),
        ...(input.Targets != null && { Targets: se_Targets(input.Targets, context) }),
        ...(input.WindowId != null && { WindowId: input.WindowId }),
    };
};
const se_RegisterTaskWithMaintenanceWindowRequest = (input, context) => {
    return {
        ...(input.AlarmConfiguration != null && {
            AlarmConfiguration: se_AlarmConfiguration(input.AlarmConfiguration, context),
        }),
        ClientToken: input.ClientToken ?? generateIdempotencyToken(),
        ...(input.CutoffBehavior != null && { CutoffBehavior: input.CutoffBehavior }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.LoggingInfo != null && { LoggingInfo: se_LoggingInfo(input.LoggingInfo, context) }),
        ...(input.MaxConcurrency != null && { MaxConcurrency: input.MaxConcurrency }),
        ...(input.MaxErrors != null && { MaxErrors: input.MaxErrors }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Priority != null && { Priority: input.Priority }),
        ...(input.ServiceRoleArn != null && { ServiceRoleArn: input.ServiceRoleArn }),
        ...(input.Targets != null && { Targets: se_Targets(input.Targets, context) }),
        ...(input.TaskArn != null && { TaskArn: input.TaskArn }),
        ...(input.TaskInvocationParameters != null && {
            TaskInvocationParameters: se_MaintenanceWindowTaskInvocationParameters(input.TaskInvocationParameters, context),
        }),
        ...(input.TaskParameters != null && {
            TaskParameters: se_MaintenanceWindowTaskParameters(input.TaskParameters, context),
        }),
        ...(input.TaskType != null && { TaskType: input.TaskType }),
        ...(input.WindowId != null && { WindowId: input.WindowId }),
    };
};
const se_RegistrationMetadataItem = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const se_RegistrationMetadataList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_RegistrationMetadataItem(entry, context);
    });
};
const se_RelatedOpsItem = (input, context) => {
    return {
        ...(input.OpsItemId != null && { OpsItemId: input.OpsItemId }),
    };
};
const se_RelatedOpsItems = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_RelatedOpsItem(entry, context);
    });
};
const se_RemoveTagsFromResourceRequest = (input, context) => {
    return {
        ...(input.ResourceId != null && { ResourceId: input.ResourceId }),
        ...(input.ResourceType != null && { ResourceType: input.ResourceType }),
        ...(input.TagKeys != null && { TagKeys: se_KeyList(input.TagKeys, context) }),
    };
};
const se_ResetServiceSettingRequest = (input, context) => {
    return {
        ...(input.SettingId != null && { SettingId: input.SettingId }),
    };
};
const se_ResourceDataSyncAwsOrganizationsSource = (input, context) => {
    return {
        ...(input.OrganizationSourceType != null && { OrganizationSourceType: input.OrganizationSourceType }),
        ...(input.OrganizationalUnits != null && {
            OrganizationalUnits: se_ResourceDataSyncOrganizationalUnitList(input.OrganizationalUnits, context),
        }),
    };
};
const se_ResourceDataSyncDestinationDataSharing = (input, context) => {
    return {
        ...(input.DestinationDataSharingType != null && { DestinationDataSharingType: input.DestinationDataSharingType }),
    };
};
const se_ResourceDataSyncOrganizationalUnit = (input, context) => {
    return {
        ...(input.OrganizationalUnitId != null && { OrganizationalUnitId: input.OrganizationalUnitId }),
    };
};
const se_ResourceDataSyncOrganizationalUnitList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ResourceDataSyncOrganizationalUnit(entry, context);
    });
};
const se_ResourceDataSyncS3Destination = (input, context) => {
    return {
        ...(input.AWSKMSKeyARN != null && { AWSKMSKeyARN: input.AWSKMSKeyARN }),
        ...(input.BucketName != null && { BucketName: input.BucketName }),
        ...(input.DestinationDataSharing != null && {
            DestinationDataSharing: se_ResourceDataSyncDestinationDataSharing(input.DestinationDataSharing, context),
        }),
        ...(input.Prefix != null && { Prefix: input.Prefix }),
        ...(input.Region != null && { Region: input.Region }),
        ...(input.SyncFormat != null && { SyncFormat: input.SyncFormat }),
    };
};
const se_ResourceDataSyncSource = (input, context) => {
    return {
        ...(input.AwsOrganizationsSource != null && {
            AwsOrganizationsSource: se_ResourceDataSyncAwsOrganizationsSource(input.AwsOrganizationsSource, context),
        }),
        ...(input.EnableAllOpsDataSources != null && { EnableAllOpsDataSources: input.EnableAllOpsDataSources }),
        ...(input.IncludeFutureRegions != null && { IncludeFutureRegions: input.IncludeFutureRegions }),
        ...(input.SourceRegions != null && {
            SourceRegions: se_ResourceDataSyncSourceRegionList(input.SourceRegions, context),
        }),
        ...(input.SourceType != null && { SourceType: input.SourceType }),
    };
};
const se_ResourceDataSyncSourceRegionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_ResultAttribute = (input, context) => {
    return {
        ...(input.TypeName != null && { TypeName: input.TypeName }),
    };
};
const se_ResultAttributeList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ResultAttribute(entry, context);
    });
};
const se_ResumeSessionRequest = (input, context) => {
    return {
        ...(input.SessionId != null && { SessionId: input.SessionId }),
    };
};
const se_Runbook = (input, context) => {
    return {
        ...(input.DocumentName != null && { DocumentName: input.DocumentName }),
        ...(input.DocumentVersion != null && { DocumentVersion: input.DocumentVersion }),
        ...(input.MaxConcurrency != null && { MaxConcurrency: input.MaxConcurrency }),
        ...(input.MaxErrors != null && { MaxErrors: input.MaxErrors }),
        ...(input.Parameters != null && { Parameters: se_AutomationParameterMap(input.Parameters, context) }),
        ...(input.TargetLocations != null && { TargetLocations: se_TargetLocations(input.TargetLocations, context) }),
        ...(input.TargetMaps != null && { TargetMaps: se_TargetMaps(input.TargetMaps, context) }),
        ...(input.TargetParameterName != null && { TargetParameterName: input.TargetParameterName }),
        ...(input.Targets != null && { Targets: se_Targets(input.Targets, context) }),
    };
};
const se_Runbooks = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Runbook(entry, context);
    });
};
const se_S3OutputLocation = (input, context) => {
    return {
        ...(input.OutputS3BucketName != null && { OutputS3BucketName: input.OutputS3BucketName }),
        ...(input.OutputS3KeyPrefix != null && { OutputS3KeyPrefix: input.OutputS3KeyPrefix }),
        ...(input.OutputS3Region != null && { OutputS3Region: input.OutputS3Region }),
    };
};
const se_SendAutomationSignalRequest = (input, context) => {
    return {
        ...(input.AutomationExecutionId != null && { AutomationExecutionId: input.AutomationExecutionId }),
        ...(input.Payload != null && { Payload: se_AutomationParameterMap(input.Payload, context) }),
        ...(input.SignalType != null && { SignalType: input.SignalType }),
    };
};
const se_SendCommandRequest = (input, context) => {
    return {
        ...(input.AlarmConfiguration != null && {
            AlarmConfiguration: se_AlarmConfiguration(input.AlarmConfiguration, context),
        }),
        ...(input.CloudWatchOutputConfig != null && {
            CloudWatchOutputConfig: se_CloudWatchOutputConfig(input.CloudWatchOutputConfig, context),
        }),
        ...(input.Comment != null && { Comment: input.Comment }),
        ...(input.DocumentHash != null && { DocumentHash: input.DocumentHash }),
        ...(input.DocumentHashType != null && { DocumentHashType: input.DocumentHashType }),
        ...(input.DocumentName != null && { DocumentName: input.DocumentName }),
        ...(input.DocumentVersion != null && { DocumentVersion: input.DocumentVersion }),
        ...(input.InstanceIds != null && { InstanceIds: se_InstanceIdList(input.InstanceIds, context) }),
        ...(input.MaxConcurrency != null && { MaxConcurrency: input.MaxConcurrency }),
        ...(input.MaxErrors != null && { MaxErrors: input.MaxErrors }),
        ...(input.NotificationConfig != null && {
            NotificationConfig: se_NotificationConfig(input.NotificationConfig, context),
        }),
        ...(input.OutputS3BucketName != null && { OutputS3BucketName: input.OutputS3BucketName }),
        ...(input.OutputS3KeyPrefix != null && { OutputS3KeyPrefix: input.OutputS3KeyPrefix }),
        ...(input.OutputS3Region != null && { OutputS3Region: input.OutputS3Region }),
        ...(input.Parameters != null && { Parameters: se_Parameters(input.Parameters, context) }),
        ...(input.ServiceRoleArn != null && { ServiceRoleArn: input.ServiceRoleArn }),
        ...(input.Targets != null && { Targets: se_Targets(input.Targets, context) }),
        ...(input.TimeoutSeconds != null && { TimeoutSeconds: input.TimeoutSeconds }),
    };
};
const se_SessionFilter = (input, context) => {
    return {
        ...(input.key != null && { key: input.key }),
        ...(input.value != null && { value: input.value }),
    };
};
const se_SessionFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_SessionFilter(entry, context);
    });
};
const se_SessionManagerParameters = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_SessionManagerParameterValueList(value, context);
        return acc;
    }, {});
};
const se_SessionManagerParameterValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_StartAssociationsOnceRequest = (input, context) => {
    return {
        ...(input.AssociationIds != null && { AssociationIds: se_AssociationIdList(input.AssociationIds, context) }),
    };
};
const se_StartAutomationExecutionRequest = (input, context) => {
    return {
        ...(input.AlarmConfiguration != null && {
            AlarmConfiguration: se_AlarmConfiguration(input.AlarmConfiguration, context),
        }),
        ...(input.ClientToken != null && { ClientToken: input.ClientToken }),
        ...(input.DocumentName != null && { DocumentName: input.DocumentName }),
        ...(input.DocumentVersion != null && { DocumentVersion: input.DocumentVersion }),
        ...(input.MaxConcurrency != null && { MaxConcurrency: input.MaxConcurrency }),
        ...(input.MaxErrors != null && { MaxErrors: input.MaxErrors }),
        ...(input.Mode != null && { Mode: input.Mode }),
        ...(input.Parameters != null && { Parameters: se_AutomationParameterMap(input.Parameters, context) }),
        ...(input.Tags != null && { Tags: se_TagList(input.Tags, context) }),
        ...(input.TargetLocations != null && { TargetLocations: se_TargetLocations(input.TargetLocations, context) }),
        ...(input.TargetMaps != null && { TargetMaps: se_TargetMaps(input.TargetMaps, context) }),
        ...(input.TargetParameterName != null && { TargetParameterName: input.TargetParameterName }),
        ...(input.Targets != null && { Targets: se_Targets(input.Targets, context) }),
    };
};
const se_StartChangeRequestExecutionRequest = (input, context) => {
    return {
        ...(input.AutoApprove != null && { AutoApprove: input.AutoApprove }),
        ...(input.ChangeDetails != null && { ChangeDetails: input.ChangeDetails }),
        ...(input.ChangeRequestName != null && { ChangeRequestName: input.ChangeRequestName }),
        ...(input.ClientToken != null && { ClientToken: input.ClientToken }),
        ...(input.DocumentName != null && { DocumentName: input.DocumentName }),
        ...(input.DocumentVersion != null && { DocumentVersion: input.DocumentVersion }),
        ...(input.Parameters != null && { Parameters: se_AutomationParameterMap(input.Parameters, context) }),
        ...(input.Runbooks != null && { Runbooks: se_Runbooks(input.Runbooks, context) }),
        ...(input.ScheduledEndTime != null && { ScheduledEndTime: Math.round(input.ScheduledEndTime.getTime() / 1000) }),
        ...(input.ScheduledTime != null && { ScheduledTime: Math.round(input.ScheduledTime.getTime() / 1000) }),
        ...(input.Tags != null && { Tags: se_TagList(input.Tags, context) }),
    };
};
const se_StartSessionRequest = (input, context) => {
    return {
        ...(input.DocumentName != null && { DocumentName: input.DocumentName }),
        ...(input.Parameters != null && { Parameters: se_SessionManagerParameters(input.Parameters, context) }),
        ...(input.Reason != null && { Reason: input.Reason }),
        ...(input.Target != null && { Target: input.Target }),
    };
};
const se_StepExecutionFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Values != null && { Values: se_StepExecutionFilterValueList(input.Values, context) }),
    };
};
const se_StepExecutionFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_StepExecutionFilter(entry, context);
    });
};
const se_StepExecutionFilterValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_StopAutomationExecutionRequest = (input, context) => {
    return {
        ...(input.AutomationExecutionId != null && { AutomationExecutionId: input.AutomationExecutionId }),
        ...(input.Type != null && { Type: input.Type }),
    };
};
const se_StringList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_Tag = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const se_TagList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Tag(entry, context);
    });
};
const se_Target = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Values != null && { Values: se_TargetValues(input.Values, context) }),
    };
};
const se_TargetLocation = (input, context) => {
    return {
        ...(input.Accounts != null && { Accounts: se_Accounts(input.Accounts, context) }),
        ...(input.ExecutionRoleName != null && { ExecutionRoleName: input.ExecutionRoleName }),
        ...(input.Regions != null && { Regions: se_Regions(input.Regions, context) }),
        ...(input.TargetLocationAlarmConfiguration != null && {
            TargetLocationAlarmConfiguration: se_AlarmConfiguration(input.TargetLocationAlarmConfiguration, context),
        }),
        ...(input.TargetLocationMaxConcurrency != null && {
            TargetLocationMaxConcurrency: input.TargetLocationMaxConcurrency,
        }),
        ...(input.TargetLocationMaxErrors != null && { TargetLocationMaxErrors: input.TargetLocationMaxErrors }),
    };
};
const se_TargetLocations = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_TargetLocation(entry, context);
    });
};
const se_TargetMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_TargetMapValueList(value, context);
        return acc;
    }, {});
};
const se_TargetMaps = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_TargetMap(entry, context);
    });
};
const se_TargetMapValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_Targets = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Target(entry, context);
    });
};
const se_TargetValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const se_TerminateSessionRequest = (input, context) => {
    return {
        ...(input.SessionId != null && { SessionId: input.SessionId }),
    };
};
const se_UnlabelParameterVersionRequest = (input, context) => {
    return {
        ...(input.Labels != null && { Labels: se_ParameterLabelList(input.Labels, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.ParameterVersion != null && { ParameterVersion: input.ParameterVersion }),
    };
};
const se_UpdateAssociationRequest = (input, context) => {
    return {
        ...(input.AlarmConfiguration != null && {
            AlarmConfiguration: se_AlarmConfiguration(input.AlarmConfiguration, context),
        }),
        ...(input.ApplyOnlyAtCronInterval != null && { ApplyOnlyAtCronInterval: input.ApplyOnlyAtCronInterval }),
        ...(input.AssociationId != null && { AssociationId: input.AssociationId }),
        ...(input.AssociationName != null && { AssociationName: input.AssociationName }),
        ...(input.AssociationVersion != null && { AssociationVersion: input.AssociationVersion }),
        ...(input.AutomationTargetParameterName != null && {
            AutomationTargetParameterName: input.AutomationTargetParameterName,
        }),
        ...(input.CalendarNames != null && { CalendarNames: se_CalendarNameOrARNList(input.CalendarNames, context) }),
        ...(input.ComplianceSeverity != null && { ComplianceSeverity: input.ComplianceSeverity }),
        ...(input.DocumentVersion != null && { DocumentVersion: input.DocumentVersion }),
        ...(input.MaxConcurrency != null && { MaxConcurrency: input.MaxConcurrency }),
        ...(input.MaxErrors != null && { MaxErrors: input.MaxErrors }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OutputLocation != null && {
            OutputLocation: se_InstanceAssociationOutputLocation(input.OutputLocation, context),
        }),
        ...(input.Parameters != null && { Parameters: se_Parameters(input.Parameters, context) }),
        ...(input.ScheduleExpression != null && { ScheduleExpression: input.ScheduleExpression }),
        ...(input.ScheduleOffset != null && { ScheduleOffset: input.ScheduleOffset }),
        ...(input.SyncCompliance != null && { SyncCompliance: input.SyncCompliance }),
        ...(input.TargetLocations != null && { TargetLocations: se_TargetLocations(input.TargetLocations, context) }),
        ...(input.TargetMaps != null && { TargetMaps: se_TargetMaps(input.TargetMaps, context) }),
        ...(input.Targets != null && { Targets: se_Targets(input.Targets, context) }),
    };
};
const se_UpdateAssociationStatusRequest = (input, context) => {
    return {
        ...(input.AssociationStatus != null && {
            AssociationStatus: se_AssociationStatus(input.AssociationStatus, context),
        }),
        ...(input.InstanceId != null && { InstanceId: input.InstanceId }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const se_UpdateDocumentDefaultVersionRequest = (input, context) => {
    return {
        ...(input.DocumentVersion != null && { DocumentVersion: input.DocumentVersion }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const se_UpdateDocumentMetadataRequest = (input, context) => {
    return {
        ...(input.DocumentReviews != null && { DocumentReviews: se_DocumentReviews(input.DocumentReviews, context) }),
        ...(input.DocumentVersion != null && { DocumentVersion: input.DocumentVersion }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const se_UpdateDocumentRequest = (input, context) => {
    return {
        ...(input.Attachments != null && { Attachments: se_AttachmentsSourceList(input.Attachments, context) }),
        ...(input.Content != null && { Content: input.Content }),
        ...(input.DisplayName != null && { DisplayName: input.DisplayName }),
        ...(input.DocumentFormat != null && { DocumentFormat: input.DocumentFormat }),
        ...(input.DocumentVersion != null && { DocumentVersion: input.DocumentVersion }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.TargetType != null && { TargetType: input.TargetType }),
        ...(input.VersionName != null && { VersionName: input.VersionName }),
    };
};
const se_UpdateMaintenanceWindowRequest = (input, context) => {
    return {
        ...(input.AllowUnassociatedTargets != null && { AllowUnassociatedTargets: input.AllowUnassociatedTargets }),
        ...(input.Cutoff != null && { Cutoff: input.Cutoff }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.Duration != null && { Duration: input.Duration }),
        ...(input.Enabled != null && { Enabled: input.Enabled }),
        ...(input.EndDate != null && { EndDate: input.EndDate }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Replace != null && { Replace: input.Replace }),
        ...(input.Schedule != null && { Schedule: input.Schedule }),
        ...(input.ScheduleOffset != null && { ScheduleOffset: input.ScheduleOffset }),
        ...(input.ScheduleTimezone != null && { ScheduleTimezone: input.ScheduleTimezone }),
        ...(input.StartDate != null && { StartDate: input.StartDate }),
        ...(input.WindowId != null && { WindowId: input.WindowId }),
    };
};
const se_UpdateMaintenanceWindowTargetRequest = (input, context) => {
    return {
        ...(input.Description != null && { Description: input.Description }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OwnerInformation != null && { OwnerInformation: input.OwnerInformation }),
        ...(input.Replace != null && { Replace: input.Replace }),
        ...(input.Targets != null && { Targets: se_Targets(input.Targets, context) }),
        ...(input.WindowId != null && { WindowId: input.WindowId }),
        ...(input.WindowTargetId != null && { WindowTargetId: input.WindowTargetId }),
    };
};
const se_UpdateMaintenanceWindowTaskRequest = (input, context) => {
    return {
        ...(input.AlarmConfiguration != null && {
            AlarmConfiguration: se_AlarmConfiguration(input.AlarmConfiguration, context),
        }),
        ...(input.CutoffBehavior != null && { CutoffBehavior: input.CutoffBehavior }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.LoggingInfo != null && { LoggingInfo: se_LoggingInfo(input.LoggingInfo, context) }),
        ...(input.MaxConcurrency != null && { MaxConcurrency: input.MaxConcurrency }),
        ...(input.MaxErrors != null && { MaxErrors: input.MaxErrors }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Priority != null && { Priority: input.Priority }),
        ...(input.Replace != null && { Replace: input.Replace }),
        ...(input.ServiceRoleArn != null && { ServiceRoleArn: input.ServiceRoleArn }),
        ...(input.Targets != null && { Targets: se_Targets(input.Targets, context) }),
        ...(input.TaskArn != null && { TaskArn: input.TaskArn }),
        ...(input.TaskInvocationParameters != null && {
            TaskInvocationParameters: se_MaintenanceWindowTaskInvocationParameters(input.TaskInvocationParameters, context),
        }),
        ...(input.TaskParameters != null && {
            TaskParameters: se_MaintenanceWindowTaskParameters(input.TaskParameters, context),
        }),
        ...(input.WindowId != null && { WindowId: input.WindowId }),
        ...(input.WindowTaskId != null && { WindowTaskId: input.WindowTaskId }),
    };
};
const se_UpdateManagedInstanceRoleRequest = (input, context) => {
    return {
        ...(input.IamRole != null && { IamRole: input.IamRole }),
        ...(input.InstanceId != null && { InstanceId: input.InstanceId }),
    };
};
const se_UpdateOpsItemRequest = (input, context) => {
    return {
        ...(input.ActualEndTime != null && { ActualEndTime: Math.round(input.ActualEndTime.getTime() / 1000) }),
        ...(input.ActualStartTime != null && { ActualStartTime: Math.round(input.ActualStartTime.getTime() / 1000) }),
        ...(input.Category != null && { Category: input.Category }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.Notifications != null && { Notifications: se_OpsItemNotifications(input.Notifications, context) }),
        ...(input.OperationalData != null && {
            OperationalData: se_OpsItemOperationalData(input.OperationalData, context),
        }),
        ...(input.OperationalDataToDelete != null && {
            OperationalDataToDelete: se_OpsItemOpsDataKeysList(input.OperationalDataToDelete, context),
        }),
        ...(input.OpsItemArn != null && { OpsItemArn: input.OpsItemArn }),
        ...(input.OpsItemId != null && { OpsItemId: input.OpsItemId }),
        ...(input.PlannedEndTime != null && { PlannedEndTime: Math.round(input.PlannedEndTime.getTime() / 1000) }),
        ...(input.PlannedStartTime != null && { PlannedStartTime: Math.round(input.PlannedStartTime.getTime() / 1000) }),
        ...(input.Priority != null && { Priority: input.Priority }),
        ...(input.RelatedOpsItems != null && { RelatedOpsItems: se_RelatedOpsItems(input.RelatedOpsItems, context) }),
        ...(input.Severity != null && { Severity: input.Severity }),
        ...(input.Status != null && { Status: input.Status }),
        ...(input.Title != null && { Title: input.Title }),
    };
};
const se_UpdateOpsMetadataRequest = (input, context) => {
    return {
        ...(input.KeysToDelete != null && { KeysToDelete: se_MetadataKeysToDeleteList(input.KeysToDelete, context) }),
        ...(input.MetadataToUpdate != null && { MetadataToUpdate: se_MetadataMap(input.MetadataToUpdate, context) }),
        ...(input.OpsMetadataArn != null && { OpsMetadataArn: input.OpsMetadataArn }),
    };
};
const se_UpdatePatchBaselineRequest = (input, context) => {
    return {
        ...(input.ApprovalRules != null && { ApprovalRules: se_PatchRuleGroup(input.ApprovalRules, context) }),
        ...(input.ApprovedPatches != null && { ApprovedPatches: se_PatchIdList(input.ApprovedPatches, context) }),
        ...(input.ApprovedPatchesComplianceLevel != null && {
            ApprovedPatchesComplianceLevel: input.ApprovedPatchesComplianceLevel,
        }),
        ...(input.ApprovedPatchesEnableNonSecurity != null && {
            ApprovedPatchesEnableNonSecurity: input.ApprovedPatchesEnableNonSecurity,
        }),
        ...(input.BaselineId != null && { BaselineId: input.BaselineId }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.GlobalFilters != null && { GlobalFilters: se_PatchFilterGroup(input.GlobalFilters, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.RejectedPatches != null && { RejectedPatches: se_PatchIdList(input.RejectedPatches, context) }),
        ...(input.RejectedPatchesAction != null && { RejectedPatchesAction: input.RejectedPatchesAction }),
        ...(input.Replace != null && { Replace: input.Replace }),
        ...(input.Sources != null && { Sources: se_PatchSourceList(input.Sources, context) }),
    };
};
const se_UpdateResourceDataSyncRequest = (input, context) => {
    return {
        ...(input.SyncName != null && { SyncName: input.SyncName }),
        ...(input.SyncSource != null && { SyncSource: se_ResourceDataSyncSource(input.SyncSource, context) }),
        ...(input.SyncType != null && { SyncType: input.SyncType }),
    };
};
const se_UpdateServiceSettingRequest = (input, context) => {
    return {
        ...(input.SettingId != null && { SettingId: input.SettingId }),
        ...(input.SettingValue != null && { SettingValue: input.SettingValue }),
    };
};
const de_AccountIdList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_Accounts = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_AccountSharingInfo = (output, context) => {
    return {
        AccountId: __expectString(output.AccountId),
        SharedDocumentVersion: __expectString(output.SharedDocumentVersion),
    };
};
const de_AccountSharingInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_AccountSharingInfo(entry, context);
    });
    return retVal;
};
const de_Activation = (output, context) => {
    return {
        ActivationId: __expectString(output.ActivationId),
        CreatedDate: output.CreatedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedDate)))
            : undefined,
        DefaultInstanceName: __expectString(output.DefaultInstanceName),
        Description: __expectString(output.Description),
        ExpirationDate: output.ExpirationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ExpirationDate)))
            : undefined,
        Expired: __expectBoolean(output.Expired),
        IamRole: __expectString(output.IamRole),
        RegistrationLimit: __expectInt32(output.RegistrationLimit),
        RegistrationsCount: __expectInt32(output.RegistrationsCount),
        Tags: output.Tags != null ? de_TagList(output.Tags, context) : undefined,
    };
};
const de_ActivationList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_Activation(entry, context);
    });
    return retVal;
};
const de_AddTagsToResourceResult = (output, context) => {
    return {};
};
const de_Alarm = (output, context) => {
    return {
        Name: __expectString(output.Name),
    };
};
const de_AlarmConfiguration = (output, context) => {
    return {
        Alarms: output.Alarms != null ? de_AlarmList(output.Alarms, context) : undefined,
        IgnorePollAlarmFailure: __expectBoolean(output.IgnorePollAlarmFailure),
    };
};
const de_AlarmList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_Alarm(entry, context);
    });
    return retVal;
};
const de_AlarmStateInformation = (output, context) => {
    return {
        Name: __expectString(output.Name),
        State: __expectString(output.State),
    };
};
const de_AlarmStateInformationList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_AlarmStateInformation(entry, context);
    });
    return retVal;
};
const de_AlreadyExistsException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_AssociatedInstances = (output, context) => {
    return {};
};
const de_AssociateOpsItemRelatedItemResponse = (output, context) => {
    return {
        AssociationId: __expectString(output.AssociationId),
    };
};
const de_Association = (output, context) => {
    return {
        AssociationId: __expectString(output.AssociationId),
        AssociationName: __expectString(output.AssociationName),
        AssociationVersion: __expectString(output.AssociationVersion),
        DocumentVersion: __expectString(output.DocumentVersion),
        InstanceId: __expectString(output.InstanceId),
        LastExecutionDate: output.LastExecutionDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastExecutionDate)))
            : undefined,
        Name: __expectString(output.Name),
        Overview: output.Overview != null ? de_AssociationOverview(output.Overview, context) : undefined,
        ScheduleExpression: __expectString(output.ScheduleExpression),
        ScheduleOffset: __expectInt32(output.ScheduleOffset),
        TargetMaps: output.TargetMaps != null ? de_TargetMaps(output.TargetMaps, context) : undefined,
        Targets: output.Targets != null ? de_Targets(output.Targets, context) : undefined,
    };
};
const de_AssociationAlreadyExists = (output, context) => {
    return {};
};
const de_AssociationDescription = (output, context) => {
    return {
        AlarmConfiguration: output.AlarmConfiguration != null ? de_AlarmConfiguration(output.AlarmConfiguration, context) : undefined,
        ApplyOnlyAtCronInterval: __expectBoolean(output.ApplyOnlyAtCronInterval),
        AssociationId: __expectString(output.AssociationId),
        AssociationName: __expectString(output.AssociationName),
        AssociationVersion: __expectString(output.AssociationVersion),
        AutomationTargetParameterName: __expectString(output.AutomationTargetParameterName),
        CalendarNames: output.CalendarNames != null ? de_CalendarNameOrARNList(output.CalendarNames, context) : undefined,
        ComplianceSeverity: __expectString(output.ComplianceSeverity),
        Date: output.Date != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.Date))) : undefined,
        DocumentVersion: __expectString(output.DocumentVersion),
        InstanceId: __expectString(output.InstanceId),
        LastExecutionDate: output.LastExecutionDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastExecutionDate)))
            : undefined,
        LastSuccessfulExecutionDate: output.LastSuccessfulExecutionDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastSuccessfulExecutionDate)))
            : undefined,
        LastUpdateAssociationDate: output.LastUpdateAssociationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastUpdateAssociationDate)))
            : undefined,
        MaxConcurrency: __expectString(output.MaxConcurrency),
        MaxErrors: __expectString(output.MaxErrors),
        Name: __expectString(output.Name),
        OutputLocation: output.OutputLocation != null ? de_InstanceAssociationOutputLocation(output.OutputLocation, context) : undefined,
        Overview: output.Overview != null ? de_AssociationOverview(output.Overview, context) : undefined,
        Parameters: output.Parameters != null ? de_Parameters(output.Parameters, context) : undefined,
        ScheduleExpression: __expectString(output.ScheduleExpression),
        ScheduleOffset: __expectInt32(output.ScheduleOffset),
        Status: output.Status != null ? de_AssociationStatus(output.Status, context) : undefined,
        SyncCompliance: __expectString(output.SyncCompliance),
        TargetLocations: output.TargetLocations != null ? de_TargetLocations(output.TargetLocations, context) : undefined,
        TargetMaps: output.TargetMaps != null ? de_TargetMaps(output.TargetMaps, context) : undefined,
        Targets: output.Targets != null ? de_Targets(output.Targets, context) : undefined,
        TriggeredAlarms: output.TriggeredAlarms != null ? de_AlarmStateInformationList(output.TriggeredAlarms, context) : undefined,
    };
};
const de_AssociationDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_AssociationDescription(entry, context);
    });
    return retVal;
};
const de_AssociationDoesNotExist = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_AssociationExecution = (output, context) => {
    return {
        AlarmConfiguration: output.AlarmConfiguration != null ? de_AlarmConfiguration(output.AlarmConfiguration, context) : undefined,
        AssociationId: __expectString(output.AssociationId),
        AssociationVersion: __expectString(output.AssociationVersion),
        CreatedTime: output.CreatedTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedTime)))
            : undefined,
        DetailedStatus: __expectString(output.DetailedStatus),
        ExecutionId: __expectString(output.ExecutionId),
        LastExecutionDate: output.LastExecutionDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastExecutionDate)))
            : undefined,
        ResourceCountByStatus: __expectString(output.ResourceCountByStatus),
        Status: __expectString(output.Status),
        TriggeredAlarms: output.TriggeredAlarms != null ? de_AlarmStateInformationList(output.TriggeredAlarms, context) : undefined,
    };
};
const de_AssociationExecutionDoesNotExist = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_AssociationExecutionsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_AssociationExecution(entry, context);
    });
    return retVal;
};
const de_AssociationExecutionTarget = (output, context) => {
    return {
        AssociationId: __expectString(output.AssociationId),
        AssociationVersion: __expectString(output.AssociationVersion),
        DetailedStatus: __expectString(output.DetailedStatus),
        ExecutionId: __expectString(output.ExecutionId),
        LastExecutionDate: output.LastExecutionDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastExecutionDate)))
            : undefined,
        OutputSource: output.OutputSource != null ? de_OutputSource(output.OutputSource, context) : undefined,
        ResourceId: __expectString(output.ResourceId),
        ResourceType: __expectString(output.ResourceType),
        Status: __expectString(output.Status),
    };
};
const de_AssociationExecutionTargetsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_AssociationExecutionTarget(entry, context);
    });
    return retVal;
};
const de_AssociationLimitExceeded = (output, context) => {
    return {};
};
const de_AssociationList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_Association(entry, context);
    });
    return retVal;
};
const de_AssociationOverview = (output, context) => {
    return {
        AssociationStatusAggregatedCount: output.AssociationStatusAggregatedCount != null
            ? de_AssociationStatusAggregatedCount(output.AssociationStatusAggregatedCount, context)
            : undefined,
        DetailedStatus: __expectString(output.DetailedStatus),
        Status: __expectString(output.Status),
    };
};
const de_AssociationStatus = (output, context) => {
    return {
        AdditionalInfo: __expectString(output.AdditionalInfo),
        Date: output.Date != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.Date))) : undefined,
        Message: __expectString(output.Message),
        Name: __expectString(output.Name),
    };
};
const de_AssociationStatusAggregatedCount = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectInt32(value);
        return acc;
    }, {});
};
const de_AssociationVersionInfo = (output, context) => {
    return {
        ApplyOnlyAtCronInterval: __expectBoolean(output.ApplyOnlyAtCronInterval),
        AssociationId: __expectString(output.AssociationId),
        AssociationName: __expectString(output.AssociationName),
        AssociationVersion: __expectString(output.AssociationVersion),
        CalendarNames: output.CalendarNames != null ? de_CalendarNameOrARNList(output.CalendarNames, context) : undefined,
        ComplianceSeverity: __expectString(output.ComplianceSeverity),
        CreatedDate: output.CreatedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedDate)))
            : undefined,
        DocumentVersion: __expectString(output.DocumentVersion),
        MaxConcurrency: __expectString(output.MaxConcurrency),
        MaxErrors: __expectString(output.MaxErrors),
        Name: __expectString(output.Name),
        OutputLocation: output.OutputLocation != null ? de_InstanceAssociationOutputLocation(output.OutputLocation, context) : undefined,
        Parameters: output.Parameters != null ? de_Parameters(output.Parameters, context) : undefined,
        ScheduleExpression: __expectString(output.ScheduleExpression),
        ScheduleOffset: __expectInt32(output.ScheduleOffset),
        SyncCompliance: __expectString(output.SyncCompliance),
        TargetLocations: output.TargetLocations != null ? de_TargetLocations(output.TargetLocations, context) : undefined,
        TargetMaps: output.TargetMaps != null ? de_TargetMaps(output.TargetMaps, context) : undefined,
        Targets: output.Targets != null ? de_Targets(output.Targets, context) : undefined,
    };
};
const de_AssociationVersionLimitExceeded = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_AssociationVersionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_AssociationVersionInfo(entry, context);
    });
    return retVal;
};
const de_AttachmentContent = (output, context) => {
    return {
        Hash: __expectString(output.Hash),
        HashType: __expectString(output.HashType),
        Name: __expectString(output.Name),
        Size: __expectLong(output.Size),
        Url: __expectString(output.Url),
    };
};
const de_AttachmentContentList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_AttachmentContent(entry, context);
    });
    return retVal;
};
const de_AttachmentInformation = (output, context) => {
    return {
        Name: __expectString(output.Name),
    };
};
const de_AttachmentInformationList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_AttachmentInformation(entry, context);
    });
    return retVal;
};
const de_AutomationDefinitionNotApprovedException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_AutomationDefinitionNotFoundException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_AutomationDefinitionVersionNotFoundException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_AutomationExecution = (output, context) => {
    return {
        AlarmConfiguration: output.AlarmConfiguration != null ? de_AlarmConfiguration(output.AlarmConfiguration, context) : undefined,
        AssociationId: __expectString(output.AssociationId),
        AutomationExecutionId: __expectString(output.AutomationExecutionId),
        AutomationExecutionStatus: __expectString(output.AutomationExecutionStatus),
        AutomationSubtype: __expectString(output.AutomationSubtype),
        ChangeRequestName: __expectString(output.ChangeRequestName),
        CurrentAction: __expectString(output.CurrentAction),
        CurrentStepName: __expectString(output.CurrentStepName),
        DocumentName: __expectString(output.DocumentName),
        DocumentVersion: __expectString(output.DocumentVersion),
        ExecutedBy: __expectString(output.ExecutedBy),
        ExecutionEndTime: output.ExecutionEndTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ExecutionEndTime)))
            : undefined,
        ExecutionStartTime: output.ExecutionStartTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ExecutionStartTime)))
            : undefined,
        FailureMessage: __expectString(output.FailureMessage),
        MaxConcurrency: __expectString(output.MaxConcurrency),
        MaxErrors: __expectString(output.MaxErrors),
        Mode: __expectString(output.Mode),
        OpsItemId: __expectString(output.OpsItemId),
        Outputs: output.Outputs != null ? de_AutomationParameterMap(output.Outputs, context) : undefined,
        Parameters: output.Parameters != null ? de_AutomationParameterMap(output.Parameters, context) : undefined,
        ParentAutomationExecutionId: __expectString(output.ParentAutomationExecutionId),
        ProgressCounters: output.ProgressCounters != null ? de_ProgressCounters(output.ProgressCounters, context) : undefined,
        ResolvedTargets: output.ResolvedTargets != null ? de_ResolvedTargets(output.ResolvedTargets, context) : undefined,
        Runbooks: output.Runbooks != null ? de_Runbooks(output.Runbooks, context) : undefined,
        ScheduledTime: output.ScheduledTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ScheduledTime)))
            : undefined,
        StepExecutions: output.StepExecutions != null ? de_StepExecutionList(output.StepExecutions, context) : undefined,
        StepExecutionsTruncated: __expectBoolean(output.StepExecutionsTruncated),
        Target: __expectString(output.Target),
        TargetLocations: output.TargetLocations != null ? de_TargetLocations(output.TargetLocations, context) : undefined,
        TargetMaps: output.TargetMaps != null ? de_TargetMaps(output.TargetMaps, context) : undefined,
        TargetParameterName: __expectString(output.TargetParameterName),
        Targets: output.Targets != null ? de_Targets(output.Targets, context) : undefined,
        TriggeredAlarms: output.TriggeredAlarms != null ? de_AlarmStateInformationList(output.TriggeredAlarms, context) : undefined,
    };
};
const de_AutomationExecutionLimitExceededException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_AutomationExecutionMetadata = (output, context) => {
    return {
        AlarmConfiguration: output.AlarmConfiguration != null ? de_AlarmConfiguration(output.AlarmConfiguration, context) : undefined,
        AssociationId: __expectString(output.AssociationId),
        AutomationExecutionId: __expectString(output.AutomationExecutionId),
        AutomationExecutionStatus: __expectString(output.AutomationExecutionStatus),
        AutomationSubtype: __expectString(output.AutomationSubtype),
        AutomationType: __expectString(output.AutomationType),
        ChangeRequestName: __expectString(output.ChangeRequestName),
        CurrentAction: __expectString(output.CurrentAction),
        CurrentStepName: __expectString(output.CurrentStepName),
        DocumentName: __expectString(output.DocumentName),
        DocumentVersion: __expectString(output.DocumentVersion),
        ExecutedBy: __expectString(output.ExecutedBy),
        ExecutionEndTime: output.ExecutionEndTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ExecutionEndTime)))
            : undefined,
        ExecutionStartTime: output.ExecutionStartTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ExecutionStartTime)))
            : undefined,
        FailureMessage: __expectString(output.FailureMessage),
        LogFile: __expectString(output.LogFile),
        MaxConcurrency: __expectString(output.MaxConcurrency),
        MaxErrors: __expectString(output.MaxErrors),
        Mode: __expectString(output.Mode),
        OpsItemId: __expectString(output.OpsItemId),
        Outputs: output.Outputs != null ? de_AutomationParameterMap(output.Outputs, context) : undefined,
        ParentAutomationExecutionId: __expectString(output.ParentAutomationExecutionId),
        ResolvedTargets: output.ResolvedTargets != null ? de_ResolvedTargets(output.ResolvedTargets, context) : undefined,
        Runbooks: output.Runbooks != null ? de_Runbooks(output.Runbooks, context) : undefined,
        ScheduledTime: output.ScheduledTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ScheduledTime)))
            : undefined,
        Target: __expectString(output.Target),
        TargetMaps: output.TargetMaps != null ? de_TargetMaps(output.TargetMaps, context) : undefined,
        TargetParameterName: __expectString(output.TargetParameterName),
        Targets: output.Targets != null ? de_Targets(output.Targets, context) : undefined,
        TriggeredAlarms: output.TriggeredAlarms != null ? de_AlarmStateInformationList(output.TriggeredAlarms, context) : undefined,
    };
};
const de_AutomationExecutionMetadataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_AutomationExecutionMetadata(entry, context);
    });
    return retVal;
};
const de_AutomationExecutionNotFoundException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_AutomationParameterMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_AutomationParameterValueList(value, context);
        return acc;
    }, {});
};
const de_AutomationParameterValueList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_AutomationStepNotFoundException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_CalendarNameOrARNList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_CancelCommandResult = (output, context) => {
    return {};
};
const de_CancelMaintenanceWindowExecutionResult = (output, context) => {
    return {
        WindowExecutionId: __expectString(output.WindowExecutionId),
    };
};
const de_CategoryEnumList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_CategoryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_CloudWatchOutputConfig = (output, context) => {
    return {
        CloudWatchLogGroupName: __expectString(output.CloudWatchLogGroupName),
        CloudWatchOutputEnabled: __expectBoolean(output.CloudWatchOutputEnabled),
    };
};
const de_Command = (output, context) => {
    return {
        AlarmConfiguration: output.AlarmConfiguration != null ? de_AlarmConfiguration(output.AlarmConfiguration, context) : undefined,
        CloudWatchOutputConfig: output.CloudWatchOutputConfig != null
            ? de_CloudWatchOutputConfig(output.CloudWatchOutputConfig, context)
            : undefined,
        CommandId: __expectString(output.CommandId),
        Comment: __expectString(output.Comment),
        CompletedCount: __expectInt32(output.CompletedCount),
        DeliveryTimedOutCount: __expectInt32(output.DeliveryTimedOutCount),
        DocumentName: __expectString(output.DocumentName),
        DocumentVersion: __expectString(output.DocumentVersion),
        ErrorCount: __expectInt32(output.ErrorCount),
        ExpiresAfter: output.ExpiresAfter != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ExpiresAfter)))
            : undefined,
        InstanceIds: output.InstanceIds != null ? de_InstanceIdList(output.InstanceIds, context) : undefined,
        MaxConcurrency: __expectString(output.MaxConcurrency),
        MaxErrors: __expectString(output.MaxErrors),
        NotificationConfig: output.NotificationConfig != null ? de_NotificationConfig(output.NotificationConfig, context) : undefined,
        OutputS3BucketName: __expectString(output.OutputS3BucketName),
        OutputS3KeyPrefix: __expectString(output.OutputS3KeyPrefix),
        OutputS3Region: __expectString(output.OutputS3Region),
        Parameters: output.Parameters != null ? de_Parameters(output.Parameters, context) : undefined,
        RequestedDateTime: output.RequestedDateTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.RequestedDateTime)))
            : undefined,
        ServiceRole: __expectString(output.ServiceRole),
        Status: __expectString(output.Status),
        StatusDetails: __expectString(output.StatusDetails),
        TargetCount: __expectInt32(output.TargetCount),
        Targets: output.Targets != null ? de_Targets(output.Targets, context) : undefined,
        TimeoutSeconds: __expectInt32(output.TimeoutSeconds),
        TriggeredAlarms: output.TriggeredAlarms != null ? de_AlarmStateInformationList(output.TriggeredAlarms, context) : undefined,
    };
};
const de_CommandInvocation = (output, context) => {
    return {
        CloudWatchOutputConfig: output.CloudWatchOutputConfig != null
            ? de_CloudWatchOutputConfig(output.CloudWatchOutputConfig, context)
            : undefined,
        CommandId: __expectString(output.CommandId),
        CommandPlugins: output.CommandPlugins != null ? de_CommandPluginList(output.CommandPlugins, context) : undefined,
        Comment: __expectString(output.Comment),
        DocumentName: __expectString(output.DocumentName),
        DocumentVersion: __expectString(output.DocumentVersion),
        InstanceId: __expectString(output.InstanceId),
        InstanceName: __expectString(output.InstanceName),
        NotificationConfig: output.NotificationConfig != null ? de_NotificationConfig(output.NotificationConfig, context) : undefined,
        RequestedDateTime: output.RequestedDateTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.RequestedDateTime)))
            : undefined,
        ServiceRole: __expectString(output.ServiceRole),
        StandardErrorUrl: __expectString(output.StandardErrorUrl),
        StandardOutputUrl: __expectString(output.StandardOutputUrl),
        Status: __expectString(output.Status),
        StatusDetails: __expectString(output.StatusDetails),
        TraceOutput: __expectString(output.TraceOutput),
    };
};
const de_CommandInvocationList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_CommandInvocation(entry, context);
    });
    return retVal;
};
const de_CommandList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_Command(entry, context);
    });
    return retVal;
};
const de_CommandPlugin = (output, context) => {
    return {
        Name: __expectString(output.Name),
        Output: __expectString(output.Output),
        OutputS3BucketName: __expectString(output.OutputS3BucketName),
        OutputS3KeyPrefix: __expectString(output.OutputS3KeyPrefix),
        OutputS3Region: __expectString(output.OutputS3Region),
        ResponseCode: __expectInt32(output.ResponseCode),
        ResponseFinishDateTime: output.ResponseFinishDateTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ResponseFinishDateTime)))
            : undefined,
        ResponseStartDateTime: output.ResponseStartDateTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ResponseStartDateTime)))
            : undefined,
        StandardErrorUrl: __expectString(output.StandardErrorUrl),
        StandardOutputUrl: __expectString(output.StandardOutputUrl),
        Status: __expectString(output.Status),
        StatusDetails: __expectString(output.StatusDetails),
    };
};
const de_CommandPluginList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_CommandPlugin(entry, context);
    });
    return retVal;
};
const de_ComplianceExecutionSummary = (output, context) => {
    return {
        ExecutionId: __expectString(output.ExecutionId),
        ExecutionTime: output.ExecutionTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ExecutionTime)))
            : undefined,
        ExecutionType: __expectString(output.ExecutionType),
    };
};
const de_ComplianceItem = (output, context) => {
    return {
        ComplianceType: __expectString(output.ComplianceType),
        Details: output.Details != null ? de_ComplianceItemDetails(output.Details, context) : undefined,
        ExecutionSummary: output.ExecutionSummary != null ? de_ComplianceExecutionSummary(output.ExecutionSummary, context) : undefined,
        Id: __expectString(output.Id),
        ResourceId: __expectString(output.ResourceId),
        ResourceType: __expectString(output.ResourceType),
        Severity: __expectString(output.Severity),
        Status: __expectString(output.Status),
        Title: __expectString(output.Title),
    };
};
const de_ComplianceItemDetails = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const de_ComplianceItemList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ComplianceItem(entry, context);
    });
    return retVal;
};
const de_ComplianceSummaryItem = (output, context) => {
    return {
        ComplianceType: __expectString(output.ComplianceType),
        CompliantSummary: output.CompliantSummary != null ? de_CompliantSummary(output.CompliantSummary, context) : undefined,
        NonCompliantSummary: output.NonCompliantSummary != null ? de_NonCompliantSummary(output.NonCompliantSummary, context) : undefined,
    };
};
const de_ComplianceSummaryItemList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ComplianceSummaryItem(entry, context);
    });
    return retVal;
};
const de_ComplianceTypeCountLimitExceededException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_CompliantSummary = (output, context) => {
    return {
        CompliantCount: __expectInt32(output.CompliantCount),
        SeveritySummary: output.SeveritySummary != null ? de_SeveritySummary(output.SeveritySummary, context) : undefined,
    };
};
const de_CreateActivationResult = (output, context) => {
    return {
        ActivationCode: __expectString(output.ActivationCode),
        ActivationId: __expectString(output.ActivationId),
    };
};
const de_CreateAssociationBatchRequestEntry = (output, context) => {
    return {
        AlarmConfiguration: output.AlarmConfiguration != null ? de_AlarmConfiguration(output.AlarmConfiguration, context) : undefined,
        ApplyOnlyAtCronInterval: __expectBoolean(output.ApplyOnlyAtCronInterval),
        AssociationName: __expectString(output.AssociationName),
        AutomationTargetParameterName: __expectString(output.AutomationTargetParameterName),
        CalendarNames: output.CalendarNames != null ? de_CalendarNameOrARNList(output.CalendarNames, context) : undefined,
        ComplianceSeverity: __expectString(output.ComplianceSeverity),
        DocumentVersion: __expectString(output.DocumentVersion),
        InstanceId: __expectString(output.InstanceId),
        MaxConcurrency: __expectString(output.MaxConcurrency),
        MaxErrors: __expectString(output.MaxErrors),
        Name: __expectString(output.Name),
        OutputLocation: output.OutputLocation != null ? de_InstanceAssociationOutputLocation(output.OutputLocation, context) : undefined,
        Parameters: output.Parameters != null ? de_Parameters(output.Parameters, context) : undefined,
        ScheduleExpression: __expectString(output.ScheduleExpression),
        ScheduleOffset: __expectInt32(output.ScheduleOffset),
        SyncCompliance: __expectString(output.SyncCompliance),
        TargetLocations: output.TargetLocations != null ? de_TargetLocations(output.TargetLocations, context) : undefined,
        TargetMaps: output.TargetMaps != null ? de_TargetMaps(output.TargetMaps, context) : undefined,
        Targets: output.Targets != null ? de_Targets(output.Targets, context) : undefined,
    };
};
const de_CreateAssociationBatchResult = (output, context) => {
    return {
        Failed: output.Failed != null ? de_FailedCreateAssociationList(output.Failed, context) : undefined,
        Successful: output.Successful != null ? de_AssociationDescriptionList(output.Successful, context) : undefined,
    };
};
const de_CreateAssociationResult = (output, context) => {
    return {
        AssociationDescription: output.AssociationDescription != null
            ? de_AssociationDescription(output.AssociationDescription, context)
            : undefined,
    };
};
const de_CreateDocumentResult = (output, context) => {
    return {
        DocumentDescription: output.DocumentDescription != null ? de_DocumentDescription(output.DocumentDescription, context) : undefined,
    };
};
const de_CreateMaintenanceWindowResult = (output, context) => {
    return {
        WindowId: __expectString(output.WindowId),
    };
};
const de_CreateOpsItemResponse = (output, context) => {
    return {
        OpsItemArn: __expectString(output.OpsItemArn),
        OpsItemId: __expectString(output.OpsItemId),
    };
};
const de_CreateOpsMetadataResult = (output, context) => {
    return {
        OpsMetadataArn: __expectString(output.OpsMetadataArn),
    };
};
const de_CreatePatchBaselineResult = (output, context) => {
    return {
        BaselineId: __expectString(output.BaselineId),
    };
};
const de_CreateResourceDataSyncResult = (output, context) => {
    return {};
};
const de_CustomSchemaCountLimitExceededException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_DeleteActivationResult = (output, context) => {
    return {};
};
const de_DeleteAssociationResult = (output, context) => {
    return {};
};
const de_DeleteDocumentResult = (output, context) => {
    return {};
};
const de_DeleteInventoryResult = (output, context) => {
    return {
        DeletionId: __expectString(output.DeletionId),
        DeletionSummary: output.DeletionSummary != null ? de_InventoryDeletionSummary(output.DeletionSummary, context) : undefined,
        TypeName: __expectString(output.TypeName),
    };
};
const de_DeleteMaintenanceWindowResult = (output, context) => {
    return {
        WindowId: __expectString(output.WindowId),
    };
};
const de_DeleteOpsMetadataResult = (output, context) => {
    return {};
};
const de_DeleteParameterResult = (output, context) => {
    return {};
};
const de_DeleteParametersResult = (output, context) => {
    return {
        DeletedParameters: output.DeletedParameters != null ? de_ParameterNameList(output.DeletedParameters, context) : undefined,
        InvalidParameters: output.InvalidParameters != null ? de_ParameterNameList(output.InvalidParameters, context) : undefined,
    };
};
const de_DeletePatchBaselineResult = (output, context) => {
    return {
        BaselineId: __expectString(output.BaselineId),
    };
};
const de_DeleteResourceDataSyncResult = (output, context) => {
    return {};
};
const de_DeleteResourcePolicyResponse = (output, context) => {
    return {};
};
const de_DeregisterManagedInstanceResult = (output, context) => {
    return {};
};
const de_DeregisterPatchBaselineForPatchGroupResult = (output, context) => {
    return {
        BaselineId: __expectString(output.BaselineId),
        PatchGroup: __expectString(output.PatchGroup),
    };
};
const de_DeregisterTargetFromMaintenanceWindowResult = (output, context) => {
    return {
        WindowId: __expectString(output.WindowId),
        WindowTargetId: __expectString(output.WindowTargetId),
    };
};
const de_DeregisterTaskFromMaintenanceWindowResult = (output, context) => {
    return {
        WindowId: __expectString(output.WindowId),
        WindowTaskId: __expectString(output.WindowTaskId),
    };
};
const de_DescribeActivationsResult = (output, context) => {
    return {
        ActivationList: output.ActivationList != null ? de_ActivationList(output.ActivationList, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_DescribeAssociationExecutionsResult = (output, context) => {
    return {
        AssociationExecutions: output.AssociationExecutions != null
            ? de_AssociationExecutionsList(output.AssociationExecutions, context)
            : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_DescribeAssociationExecutionTargetsResult = (output, context) => {
    return {
        AssociationExecutionTargets: output.AssociationExecutionTargets != null
            ? de_AssociationExecutionTargetsList(output.AssociationExecutionTargets, context)
            : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_DescribeAssociationResult = (output, context) => {
    return {
        AssociationDescription: output.AssociationDescription != null
            ? de_AssociationDescription(output.AssociationDescription, context)
            : undefined,
    };
};
const de_DescribeAutomationExecutionsResult = (output, context) => {
    return {
        AutomationExecutionMetadataList: output.AutomationExecutionMetadataList != null
            ? de_AutomationExecutionMetadataList(output.AutomationExecutionMetadataList, context)
            : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_DescribeAutomationStepExecutionsResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        StepExecutions: output.StepExecutions != null ? de_StepExecutionList(output.StepExecutions, context) : undefined,
    };
};
const de_DescribeAvailablePatchesResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Patches: output.Patches != null ? de_PatchList(output.Patches, context) : undefined,
    };
};
const de_DescribeDocumentPermissionResponse = (output, context) => {
    return {
        AccountIds: output.AccountIds != null ? de_AccountIdList(output.AccountIds, context) : undefined,
        AccountSharingInfoList: output.AccountSharingInfoList != null
            ? de_AccountSharingInfoList(output.AccountSharingInfoList, context)
            : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_DescribeDocumentResult = (output, context) => {
    return {
        Document: output.Document != null ? de_DocumentDescription(output.Document, context) : undefined,
    };
};
const de_DescribeEffectiveInstanceAssociationsResult = (output, context) => {
    return {
        Associations: output.Associations != null ? de_InstanceAssociationList(output.Associations, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_DescribeEffectivePatchesForPatchBaselineResult = (output, context) => {
    return {
        EffectivePatches: output.EffectivePatches != null ? de_EffectivePatchList(output.EffectivePatches, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_DescribeInstanceAssociationsStatusResult = (output, context) => {
    return {
        InstanceAssociationStatusInfos: output.InstanceAssociationStatusInfos != null
            ? de_InstanceAssociationStatusInfos(output.InstanceAssociationStatusInfos, context)
            : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_DescribeInstanceInformationResult = (output, context) => {
    return {
        InstanceInformationList: output.InstanceInformationList != null
            ? de_InstanceInformationList(output.InstanceInformationList, context)
            : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_DescribeInstancePatchesResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Patches: output.Patches != null ? de_PatchComplianceDataList(output.Patches, context) : undefined,
    };
};
const de_DescribeInstancePatchStatesForPatchGroupResult = (output, context) => {
    return {
        InstancePatchStates: output.InstancePatchStates != null ? de_InstancePatchStatesList(output.InstancePatchStates, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_DescribeInstancePatchStatesResult = (output, context) => {
    return {
        InstancePatchStates: output.InstancePatchStates != null ? de_InstancePatchStateList(output.InstancePatchStates, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_DescribeInventoryDeletionsResult = (output, context) => {
    return {
        InventoryDeletions: output.InventoryDeletions != null ? de_InventoryDeletionsList(output.InventoryDeletions, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_DescribeMaintenanceWindowExecutionsResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        WindowExecutions: output.WindowExecutions != null ? de_MaintenanceWindowExecutionList(output.WindowExecutions, context) : undefined,
    };
};
const de_DescribeMaintenanceWindowExecutionTaskInvocationsResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        WindowExecutionTaskInvocationIdentities: output.WindowExecutionTaskInvocationIdentities != null
            ? de_MaintenanceWindowExecutionTaskInvocationIdentityList(output.WindowExecutionTaskInvocationIdentities, context)
            : undefined,
    };
};
const de_DescribeMaintenanceWindowExecutionTasksResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        WindowExecutionTaskIdentities: output.WindowExecutionTaskIdentities != null
            ? de_MaintenanceWindowExecutionTaskIdentityList(output.WindowExecutionTaskIdentities, context)
            : undefined,
    };
};
const de_DescribeMaintenanceWindowScheduleResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        ScheduledWindowExecutions: output.ScheduledWindowExecutions != null
            ? de_ScheduledWindowExecutionList(output.ScheduledWindowExecutions, context)
            : undefined,
    };
};
const de_DescribeMaintenanceWindowsForTargetResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        WindowIdentities: output.WindowIdentities != null
            ? de_MaintenanceWindowsForTargetList(output.WindowIdentities, context)
            : undefined,
    };
};
const de_DescribeMaintenanceWindowsResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        WindowIdentities: output.WindowIdentities != null ? de_MaintenanceWindowIdentityList(output.WindowIdentities, context) : undefined,
    };
};
const de_DescribeMaintenanceWindowTargetsResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Targets: output.Targets != null ? de_MaintenanceWindowTargetList(output.Targets, context) : undefined,
    };
};
const de_DescribeMaintenanceWindowTasksResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Tasks: output.Tasks != null ? de_MaintenanceWindowTaskList(output.Tasks, context) : undefined,
    };
};
const de_DescribeOpsItemsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        OpsItemSummaries: output.OpsItemSummaries != null ? de_OpsItemSummaries(output.OpsItemSummaries, context) : undefined,
    };
};
const de_DescribeParametersResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Parameters: output.Parameters != null ? de_ParameterMetadataList(output.Parameters, context) : undefined,
    };
};
const de_DescribePatchBaselinesResult = (output, context) => {
    return {
        BaselineIdentities: output.BaselineIdentities != null ? de_PatchBaselineIdentityList(output.BaselineIdentities, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_DescribePatchGroupsResult = (output, context) => {
    return {
        Mappings: output.Mappings != null ? de_PatchGroupPatchBaselineMappingList(output.Mappings, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_DescribePatchGroupStateResult = (output, context) => {
    return {
        Instances: __expectInt32(output.Instances),
        InstancesWithCriticalNonCompliantPatches: __expectInt32(output.InstancesWithCriticalNonCompliantPatches),
        InstancesWithFailedPatches: __expectInt32(output.InstancesWithFailedPatches),
        InstancesWithInstalledOtherPatches: __expectInt32(output.InstancesWithInstalledOtherPatches),
        InstancesWithInstalledPatches: __expectInt32(output.InstancesWithInstalledPatches),
        InstancesWithInstalledPendingRebootPatches: __expectInt32(output.InstancesWithInstalledPendingRebootPatches),
        InstancesWithInstalledRejectedPatches: __expectInt32(output.InstancesWithInstalledRejectedPatches),
        InstancesWithMissingPatches: __expectInt32(output.InstancesWithMissingPatches),
        InstancesWithNotApplicablePatches: __expectInt32(output.InstancesWithNotApplicablePatches),
        InstancesWithOtherNonCompliantPatches: __expectInt32(output.InstancesWithOtherNonCompliantPatches),
        InstancesWithSecurityNonCompliantPatches: __expectInt32(output.InstancesWithSecurityNonCompliantPatches),
        InstancesWithUnreportedNotApplicablePatches: __expectInt32(output.InstancesWithUnreportedNotApplicablePatches),
    };
};
const de_DescribePatchPropertiesResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Properties: output.Properties != null ? de_PatchPropertiesList(output.Properties, context) : undefined,
    };
};
const de_DescribeSessionsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Sessions: output.Sessions != null ? de_SessionList(output.Sessions, context) : undefined,
    };
};
const de_DisassociateOpsItemRelatedItemResponse = (output, context) => {
    return {};
};
const de_DocumentAlreadyExists = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_DocumentDefaultVersionDescription = (output, context) => {
    return {
        DefaultVersion: __expectString(output.DefaultVersion),
        DefaultVersionName: __expectString(output.DefaultVersionName),
        Name: __expectString(output.Name),
    };
};
const de_DocumentDescription = (output, context) => {
    return {
        ApprovedVersion: __expectString(output.ApprovedVersion),
        AttachmentsInformation: output.AttachmentsInformation != null
            ? de_AttachmentInformationList(output.AttachmentsInformation, context)
            : undefined,
        Author: __expectString(output.Author),
        Category: output.Category != null ? de_CategoryList(output.Category, context) : undefined,
        CategoryEnum: output.CategoryEnum != null ? de_CategoryEnumList(output.CategoryEnum, context) : undefined,
        CreatedDate: output.CreatedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedDate)))
            : undefined,
        DefaultVersion: __expectString(output.DefaultVersion),
        Description: __expectString(output.Description),
        DisplayName: __expectString(output.DisplayName),
        DocumentFormat: __expectString(output.DocumentFormat),
        DocumentType: __expectString(output.DocumentType),
        DocumentVersion: __expectString(output.DocumentVersion),
        Hash: __expectString(output.Hash),
        HashType: __expectString(output.HashType),
        LatestVersion: __expectString(output.LatestVersion),
        Name: __expectString(output.Name),
        Owner: __expectString(output.Owner),
        Parameters: output.Parameters != null ? de_DocumentParameterList(output.Parameters, context) : undefined,
        PendingReviewVersion: __expectString(output.PendingReviewVersion),
        PlatformTypes: output.PlatformTypes != null ? de_PlatformTypeList(output.PlatformTypes, context) : undefined,
        Requires: output.Requires != null ? de_DocumentRequiresList(output.Requires, context) : undefined,
        ReviewInformation: output.ReviewInformation != null ? de_ReviewInformationList(output.ReviewInformation, context) : undefined,
        ReviewStatus: __expectString(output.ReviewStatus),
        SchemaVersion: __expectString(output.SchemaVersion),
        Sha1: __expectString(output.Sha1),
        Status: __expectString(output.Status),
        StatusInformation: __expectString(output.StatusInformation),
        Tags: output.Tags != null ? de_TagList(output.Tags, context) : undefined,
        TargetType: __expectString(output.TargetType),
        VersionName: __expectString(output.VersionName),
    };
};
const de_DocumentIdentifier = (output, context) => {
    return {
        Author: __expectString(output.Author),
        CreatedDate: output.CreatedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedDate)))
            : undefined,
        DisplayName: __expectString(output.DisplayName),
        DocumentFormat: __expectString(output.DocumentFormat),
        DocumentType: __expectString(output.DocumentType),
        DocumentVersion: __expectString(output.DocumentVersion),
        Name: __expectString(output.Name),
        Owner: __expectString(output.Owner),
        PlatformTypes: output.PlatformTypes != null ? de_PlatformTypeList(output.PlatformTypes, context) : undefined,
        Requires: output.Requires != null ? de_DocumentRequiresList(output.Requires, context) : undefined,
        ReviewStatus: __expectString(output.ReviewStatus),
        SchemaVersion: __expectString(output.SchemaVersion),
        Tags: output.Tags != null ? de_TagList(output.Tags, context) : undefined,
        TargetType: __expectString(output.TargetType),
        VersionName: __expectString(output.VersionName),
    };
};
const de_DocumentIdentifierList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_DocumentIdentifier(entry, context);
    });
    return retVal;
};
const de_DocumentLimitExceeded = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_DocumentMetadataResponseInfo = (output, context) => {
    return {
        ReviewerResponse: output.ReviewerResponse != null ? de_DocumentReviewerResponseList(output.ReviewerResponse, context) : undefined,
    };
};
const de_DocumentParameter = (output, context) => {
    return {
        DefaultValue: __expectString(output.DefaultValue),
        Description: __expectString(output.Description),
        Name: __expectString(output.Name),
        Type: __expectString(output.Type),
    };
};
const de_DocumentParameterList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_DocumentParameter(entry, context);
    });
    return retVal;
};
const de_DocumentPermissionLimit = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_DocumentRequires = (output, context) => {
    return {
        Name: __expectString(output.Name),
        RequireType: __expectString(output.RequireType),
        Version: __expectString(output.Version),
        VersionName: __expectString(output.VersionName),
    };
};
const de_DocumentRequiresList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_DocumentRequires(entry, context);
    });
    return retVal;
};
const de_DocumentReviewCommentList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_DocumentReviewCommentSource(entry, context);
    });
    return retVal;
};
const de_DocumentReviewCommentSource = (output, context) => {
    return {
        Content: __expectString(output.Content),
        Type: __expectString(output.Type),
    };
};
const de_DocumentReviewerResponseList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_DocumentReviewerResponseSource(entry, context);
    });
    return retVal;
};
const de_DocumentReviewerResponseSource = (output, context) => {
    return {
        Comment: output.Comment != null ? de_DocumentReviewCommentList(output.Comment, context) : undefined,
        CreateTime: output.CreateTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreateTime))) : undefined,
        ReviewStatus: __expectString(output.ReviewStatus),
        Reviewer: __expectString(output.Reviewer),
        UpdatedTime: output.UpdatedTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.UpdatedTime)))
            : undefined,
    };
};
const de_DocumentVersionInfo = (output, context) => {
    return {
        CreatedDate: output.CreatedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedDate)))
            : undefined,
        DisplayName: __expectString(output.DisplayName),
        DocumentFormat: __expectString(output.DocumentFormat),
        DocumentVersion: __expectString(output.DocumentVersion),
        IsDefaultVersion: __expectBoolean(output.IsDefaultVersion),
        Name: __expectString(output.Name),
        ReviewStatus: __expectString(output.ReviewStatus),
        Status: __expectString(output.Status),
        StatusInformation: __expectString(output.StatusInformation),
        VersionName: __expectString(output.VersionName),
    };
};
const de_DocumentVersionLimitExceeded = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_DocumentVersionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_DocumentVersionInfo(entry, context);
    });
    return retVal;
};
const de_DoesNotExistException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_DuplicateDocumentContent = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_DuplicateDocumentVersionName = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_DuplicateInstanceId = (output, context) => {
    return {};
};
const de_EffectivePatch = (output, context) => {
    return {
        Patch: output.Patch != null ? de_Patch(output.Patch, context) : undefined,
        PatchStatus: output.PatchStatus != null ? de_PatchStatus(output.PatchStatus, context) : undefined,
    };
};
const de_EffectivePatchList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_EffectivePatch(entry, context);
    });
    return retVal;
};
const de_FailedCreateAssociation = (output, context) => {
    return {
        Entry: output.Entry != null ? de_CreateAssociationBatchRequestEntry(output.Entry, context) : undefined,
        Fault: __expectString(output.Fault),
        Message: __expectString(output.Message),
    };
};
const de_FailedCreateAssociationList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_FailedCreateAssociation(entry, context);
    });
    return retVal;
};
const de_FailureDetails = (output, context) => {
    return {
        Details: output.Details != null ? de_AutomationParameterMap(output.Details, context) : undefined,
        FailureStage: __expectString(output.FailureStage),
        FailureType: __expectString(output.FailureType),
    };
};
const de_FeatureNotAvailableException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_GetAutomationExecutionResult = (output, context) => {
    return {
        AutomationExecution: output.AutomationExecution != null ? de_AutomationExecution(output.AutomationExecution, context) : undefined,
    };
};
const de_GetCalendarStateResponse = (output, context) => {
    return {
        AtTime: __expectString(output.AtTime),
        NextTransitionTime: __expectString(output.NextTransitionTime),
        State: __expectString(output.State),
    };
};
const de_GetCommandInvocationResult = (output, context) => {
    return {
        CloudWatchOutputConfig: output.CloudWatchOutputConfig != null
            ? de_CloudWatchOutputConfig(output.CloudWatchOutputConfig, context)
            : undefined,
        CommandId: __expectString(output.CommandId),
        Comment: __expectString(output.Comment),
        DocumentName: __expectString(output.DocumentName),
        DocumentVersion: __expectString(output.DocumentVersion),
        ExecutionElapsedTime: __expectString(output.ExecutionElapsedTime),
        ExecutionEndDateTime: __expectString(output.ExecutionEndDateTime),
        ExecutionStartDateTime: __expectString(output.ExecutionStartDateTime),
        InstanceId: __expectString(output.InstanceId),
        PluginName: __expectString(output.PluginName),
        ResponseCode: __expectInt32(output.ResponseCode),
        StandardErrorContent: __expectString(output.StandardErrorContent),
        StandardErrorUrl: __expectString(output.StandardErrorUrl),
        StandardOutputContent: __expectString(output.StandardOutputContent),
        StandardOutputUrl: __expectString(output.StandardOutputUrl),
        Status: __expectString(output.Status),
        StatusDetails: __expectString(output.StatusDetails),
    };
};
const de_GetConnectionStatusResponse = (output, context) => {
    return {
        Status: __expectString(output.Status),
        Target: __expectString(output.Target),
    };
};
const de_GetDefaultPatchBaselineResult = (output, context) => {
    return {
        BaselineId: __expectString(output.BaselineId),
        OperatingSystem: __expectString(output.OperatingSystem),
    };
};
const de_GetDeployablePatchSnapshotForInstanceResult = (output, context) => {
    return {
        InstanceId: __expectString(output.InstanceId),
        Product: __expectString(output.Product),
        SnapshotDownloadUrl: __expectString(output.SnapshotDownloadUrl),
        SnapshotId: __expectString(output.SnapshotId),
    };
};
const de_GetDocumentResult = (output, context) => {
    return {
        AttachmentsContent: output.AttachmentsContent != null ? de_AttachmentContentList(output.AttachmentsContent, context) : undefined,
        Content: __expectString(output.Content),
        CreatedDate: output.CreatedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedDate)))
            : undefined,
        DisplayName: __expectString(output.DisplayName),
        DocumentFormat: __expectString(output.DocumentFormat),
        DocumentType: __expectString(output.DocumentType),
        DocumentVersion: __expectString(output.DocumentVersion),
        Name: __expectString(output.Name),
        Requires: output.Requires != null ? de_DocumentRequiresList(output.Requires, context) : undefined,
        ReviewStatus: __expectString(output.ReviewStatus),
        Status: __expectString(output.Status),
        StatusInformation: __expectString(output.StatusInformation),
        VersionName: __expectString(output.VersionName),
    };
};
const de_GetInventoryResult = (output, context) => {
    return {
        Entities: output.Entities != null ? de_InventoryResultEntityList(output.Entities, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_GetInventorySchemaResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Schemas: output.Schemas != null ? de_InventoryItemSchemaResultList(output.Schemas, context) : undefined,
    };
};
const de_GetMaintenanceWindowExecutionResult = (output, context) => {
    return {
        EndTime: output.EndTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.EndTime))) : undefined,
        StartTime: output.StartTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartTime))) : undefined,
        Status: __expectString(output.Status),
        StatusDetails: __expectString(output.StatusDetails),
        TaskIds: output.TaskIds != null ? de_MaintenanceWindowExecutionTaskIdList(output.TaskIds, context) : undefined,
        WindowExecutionId: __expectString(output.WindowExecutionId),
    };
};
const de_GetMaintenanceWindowExecutionTaskInvocationResult = (output, context) => {
    return {
        EndTime: output.EndTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.EndTime))) : undefined,
        ExecutionId: __expectString(output.ExecutionId),
        InvocationId: __expectString(output.InvocationId),
        OwnerInformation: __expectString(output.OwnerInformation),
        Parameters: __expectString(output.Parameters),
        StartTime: output.StartTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartTime))) : undefined,
        Status: __expectString(output.Status),
        StatusDetails: __expectString(output.StatusDetails),
        TaskExecutionId: __expectString(output.TaskExecutionId),
        TaskType: __expectString(output.TaskType),
        WindowExecutionId: __expectString(output.WindowExecutionId),
        WindowTargetId: __expectString(output.WindowTargetId),
    };
};
const de_GetMaintenanceWindowExecutionTaskResult = (output, context) => {
    return {
        AlarmConfiguration: output.AlarmConfiguration != null ? de_AlarmConfiguration(output.AlarmConfiguration, context) : undefined,
        EndTime: output.EndTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.EndTime))) : undefined,
        MaxConcurrency: __expectString(output.MaxConcurrency),
        MaxErrors: __expectString(output.MaxErrors),
        Priority: __expectInt32(output.Priority),
        ServiceRole: __expectString(output.ServiceRole),
        StartTime: output.StartTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartTime))) : undefined,
        Status: __expectString(output.Status),
        StatusDetails: __expectString(output.StatusDetails),
        TaskArn: __expectString(output.TaskArn),
        TaskExecutionId: __expectString(output.TaskExecutionId),
        TaskParameters: output.TaskParameters != null
            ? de_MaintenanceWindowTaskParametersList(output.TaskParameters, context)
            : undefined,
        TriggeredAlarms: output.TriggeredAlarms != null ? de_AlarmStateInformationList(output.TriggeredAlarms, context) : undefined,
        Type: __expectString(output.Type),
        WindowExecutionId: __expectString(output.WindowExecutionId),
    };
};
const de_GetMaintenanceWindowResult = (output, context) => {
    return {
        AllowUnassociatedTargets: __expectBoolean(output.AllowUnassociatedTargets),
        CreatedDate: output.CreatedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedDate)))
            : undefined,
        Cutoff: __expectInt32(output.Cutoff),
        Description: __expectString(output.Description),
        Duration: __expectInt32(output.Duration),
        Enabled: __expectBoolean(output.Enabled),
        EndDate: __expectString(output.EndDate),
        ModifiedDate: output.ModifiedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ModifiedDate)))
            : undefined,
        Name: __expectString(output.Name),
        NextExecutionTime: __expectString(output.NextExecutionTime),
        Schedule: __expectString(output.Schedule),
        ScheduleOffset: __expectInt32(output.ScheduleOffset),
        ScheduleTimezone: __expectString(output.ScheduleTimezone),
        StartDate: __expectString(output.StartDate),
        WindowId: __expectString(output.WindowId),
    };
};
const de_GetMaintenanceWindowTaskResult = (output, context) => {
    return {
        AlarmConfiguration: output.AlarmConfiguration != null ? de_AlarmConfiguration(output.AlarmConfiguration, context) : undefined,
        CutoffBehavior: __expectString(output.CutoffBehavior),
        Description: __expectString(output.Description),
        LoggingInfo: output.LoggingInfo != null ? de_LoggingInfo(output.LoggingInfo, context) : undefined,
        MaxConcurrency: __expectString(output.MaxConcurrency),
        MaxErrors: __expectString(output.MaxErrors),
        Name: __expectString(output.Name),
        Priority: __expectInt32(output.Priority),
        ServiceRoleArn: __expectString(output.ServiceRoleArn),
        Targets: output.Targets != null ? de_Targets(output.Targets, context) : undefined,
        TaskArn: __expectString(output.TaskArn),
        TaskInvocationParameters: output.TaskInvocationParameters != null
            ? de_MaintenanceWindowTaskInvocationParameters(output.TaskInvocationParameters, context)
            : undefined,
        TaskParameters: output.TaskParameters != null ? de_MaintenanceWindowTaskParameters(output.TaskParameters, context) : undefined,
        TaskType: __expectString(output.TaskType),
        WindowId: __expectString(output.WindowId),
        WindowTaskId: __expectString(output.WindowTaskId),
    };
};
const de_GetOpsItemResponse = (output, context) => {
    return {
        OpsItem: output.OpsItem != null ? de_OpsItem(output.OpsItem, context) : undefined,
    };
};
const de_GetOpsMetadataResult = (output, context) => {
    return {
        Metadata: output.Metadata != null ? de_MetadataMap(output.Metadata, context) : undefined,
        NextToken: __expectString(output.NextToken),
        ResourceId: __expectString(output.ResourceId),
    };
};
const de_GetOpsSummaryResult = (output, context) => {
    return {
        Entities: output.Entities != null ? de_OpsEntityList(output.Entities, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_GetParameterHistoryResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Parameters: output.Parameters != null ? de_ParameterHistoryList(output.Parameters, context) : undefined,
    };
};
const de_GetParameterResult = (output, context) => {
    return {
        Parameter: output.Parameter != null ? de_Parameter(output.Parameter, context) : undefined,
    };
};
const de_GetParametersByPathResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Parameters: output.Parameters != null ? de_ParameterList(output.Parameters, context) : undefined,
    };
};
const de_GetParametersResult = (output, context) => {
    return {
        InvalidParameters: output.InvalidParameters != null ? de_ParameterNameList(output.InvalidParameters, context) : undefined,
        Parameters: output.Parameters != null ? de_ParameterList(output.Parameters, context) : undefined,
    };
};
const de_GetPatchBaselineForPatchGroupResult = (output, context) => {
    return {
        BaselineId: __expectString(output.BaselineId),
        OperatingSystem: __expectString(output.OperatingSystem),
        PatchGroup: __expectString(output.PatchGroup),
    };
};
const de_GetPatchBaselineResult = (output, context) => {
    return {
        ApprovalRules: output.ApprovalRules != null ? de_PatchRuleGroup(output.ApprovalRules, context) : undefined,
        ApprovedPatches: output.ApprovedPatches != null ? de_PatchIdList(output.ApprovedPatches, context) : undefined,
        ApprovedPatchesComplianceLevel: __expectString(output.ApprovedPatchesComplianceLevel),
        ApprovedPatchesEnableNonSecurity: __expectBoolean(output.ApprovedPatchesEnableNonSecurity),
        BaselineId: __expectString(output.BaselineId),
        CreatedDate: output.CreatedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedDate)))
            : undefined,
        Description: __expectString(output.Description),
        GlobalFilters: output.GlobalFilters != null ? de_PatchFilterGroup(output.GlobalFilters, context) : undefined,
        ModifiedDate: output.ModifiedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ModifiedDate)))
            : undefined,
        Name: __expectString(output.Name),
        OperatingSystem: __expectString(output.OperatingSystem),
        PatchGroups: output.PatchGroups != null ? de_PatchGroupList(output.PatchGroups, context) : undefined,
        RejectedPatches: output.RejectedPatches != null ? de_PatchIdList(output.RejectedPatches, context) : undefined,
        RejectedPatchesAction: __expectString(output.RejectedPatchesAction),
        Sources: output.Sources != null ? de_PatchSourceList(output.Sources, context) : undefined,
    };
};
const de_GetResourcePoliciesResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Policies: output.Policies != null ? de_GetResourcePoliciesResponseEntries(output.Policies, context) : undefined,
    };
};
const de_GetResourcePoliciesResponseEntries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_GetResourcePoliciesResponseEntry(entry, context);
    });
    return retVal;
};
const de_GetResourcePoliciesResponseEntry = (output, context) => {
    return {
        Policy: __expectString(output.Policy),
        PolicyHash: __expectString(output.PolicyHash),
        PolicyId: __expectString(output.PolicyId),
    };
};
const de_GetServiceSettingResult = (output, context) => {
    return {
        ServiceSetting: output.ServiceSetting != null ? de_ServiceSetting(output.ServiceSetting, context) : undefined,
    };
};
const de_HierarchyLevelLimitExceededException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_HierarchyTypeMismatchException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_IdempotentParameterMismatch = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_IncompatiblePolicyException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_InstanceAggregatedAssociationOverview = (output, context) => {
    return {
        DetailedStatus: __expectString(output.DetailedStatus),
        InstanceAssociationStatusAggregatedCount: output.InstanceAssociationStatusAggregatedCount != null
            ? de_InstanceAssociationStatusAggregatedCount(output.InstanceAssociationStatusAggregatedCount, context)
            : undefined,
    };
};
const de_InstanceAssociation = (output, context) => {
    return {
        AssociationId: __expectString(output.AssociationId),
        AssociationVersion: __expectString(output.AssociationVersion),
        Content: __expectString(output.Content),
        InstanceId: __expectString(output.InstanceId),
    };
};
const de_InstanceAssociationList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_InstanceAssociation(entry, context);
    });
    return retVal;
};
const de_InstanceAssociationOutputLocation = (output, context) => {
    return {
        S3Location: output.S3Location != null ? de_S3OutputLocation(output.S3Location, context) : undefined,
    };
};
const de_InstanceAssociationOutputUrl = (output, context) => {
    return {
        S3OutputUrl: output.S3OutputUrl != null ? de_S3OutputUrl(output.S3OutputUrl, context) : undefined,
    };
};
const de_InstanceAssociationStatusAggregatedCount = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectInt32(value);
        return acc;
    }, {});
};
const de_InstanceAssociationStatusInfo = (output, context) => {
    return {
        AssociationId: __expectString(output.AssociationId),
        AssociationName: __expectString(output.AssociationName),
        AssociationVersion: __expectString(output.AssociationVersion),
        DetailedStatus: __expectString(output.DetailedStatus),
        DocumentVersion: __expectString(output.DocumentVersion),
        ErrorCode: __expectString(output.ErrorCode),
        ExecutionDate: output.ExecutionDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ExecutionDate)))
            : undefined,
        ExecutionSummary: __expectString(output.ExecutionSummary),
        InstanceId: __expectString(output.InstanceId),
        Name: __expectString(output.Name),
        OutputUrl: output.OutputUrl != null ? de_InstanceAssociationOutputUrl(output.OutputUrl, context) : undefined,
        Status: __expectString(output.Status),
    };
};
const de_InstanceAssociationStatusInfos = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_InstanceAssociationStatusInfo(entry, context);
    });
    return retVal;
};
const de_InstanceIdList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_InstanceInformation = (output, context) => {
    return {
        ActivationId: __expectString(output.ActivationId),
        AgentVersion: __expectString(output.AgentVersion),
        AssociationOverview: output.AssociationOverview != null
            ? de_InstanceAggregatedAssociationOverview(output.AssociationOverview, context)
            : undefined,
        AssociationStatus: __expectString(output.AssociationStatus),
        ComputerName: __expectString(output.ComputerName),
        IPAddress: __expectString(output.IPAddress),
        IamRole: __expectString(output.IamRole),
        InstanceId: __expectString(output.InstanceId),
        IsLatestVersion: __expectBoolean(output.IsLatestVersion),
        LastAssociationExecutionDate: output.LastAssociationExecutionDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastAssociationExecutionDate)))
            : undefined,
        LastPingDateTime: output.LastPingDateTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastPingDateTime)))
            : undefined,
        LastSuccessfulAssociationExecutionDate: output.LastSuccessfulAssociationExecutionDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastSuccessfulAssociationExecutionDate)))
            : undefined,
        Name: __expectString(output.Name),
        PingStatus: __expectString(output.PingStatus),
        PlatformName: __expectString(output.PlatformName),
        PlatformType: __expectString(output.PlatformType),
        PlatformVersion: __expectString(output.PlatformVersion),
        RegistrationDate: output.RegistrationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.RegistrationDate)))
            : undefined,
        ResourceType: __expectString(output.ResourceType),
        SourceId: __expectString(output.SourceId),
        SourceType: __expectString(output.SourceType),
    };
};
const de_InstanceInformationList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_InstanceInformation(entry, context);
    });
    return retVal;
};
const de_InstancePatchState = (output, context) => {
    return {
        BaselineId: __expectString(output.BaselineId),
        CriticalNonCompliantCount: __expectInt32(output.CriticalNonCompliantCount),
        FailedCount: __expectInt32(output.FailedCount),
        InstallOverrideList: __expectString(output.InstallOverrideList),
        InstalledCount: __expectInt32(output.InstalledCount),
        InstalledOtherCount: __expectInt32(output.InstalledOtherCount),
        InstalledPendingRebootCount: __expectInt32(output.InstalledPendingRebootCount),
        InstalledRejectedCount: __expectInt32(output.InstalledRejectedCount),
        InstanceId: __expectString(output.InstanceId),
        LastNoRebootInstallOperationTime: output.LastNoRebootInstallOperationTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastNoRebootInstallOperationTime)))
            : undefined,
        MissingCount: __expectInt32(output.MissingCount),
        NotApplicableCount: __expectInt32(output.NotApplicableCount),
        Operation: __expectString(output.Operation),
        OperationEndTime: output.OperationEndTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.OperationEndTime)))
            : undefined,
        OperationStartTime: output.OperationStartTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.OperationStartTime)))
            : undefined,
        OtherNonCompliantCount: __expectInt32(output.OtherNonCompliantCount),
        OwnerInformation: __expectString(output.OwnerInformation),
        PatchGroup: __expectString(output.PatchGroup),
        RebootOption: __expectString(output.RebootOption),
        SecurityNonCompliantCount: __expectInt32(output.SecurityNonCompliantCount),
        SnapshotId: __expectString(output.SnapshotId),
        UnreportedNotApplicableCount: __expectInt32(output.UnreportedNotApplicableCount),
    };
};
const de_InstancePatchStateList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_InstancePatchState(entry, context);
    });
    return retVal;
};
const de_InstancePatchStatesList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_InstancePatchState(entry, context);
    });
    return retVal;
};
const de_InternalServerError = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidActivation = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidActivationId = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidAggregatorException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidAllowedPatternException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_InvalidAssociation = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidAssociationVersion = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidAutomationExecutionParametersException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidAutomationSignalException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidAutomationStatusUpdateException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidCommandId = (output, context) => {
    return {};
};
const de_InvalidDeleteInventoryParametersException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidDeletionIdException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidDocument = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidDocumentContent = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidDocumentOperation = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidDocumentSchemaVersion = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidDocumentType = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidDocumentVersion = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidFilter = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidFilterKey = (output, context) => {
    return {};
};
const de_InvalidFilterOption = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_InvalidFilterValue = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidInstanceId = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidInstanceInformationFilterValue = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_InvalidInventoryGroupException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidInventoryItemContextException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidInventoryRequestException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidItemContentException = (output, context) => {
    return {
        Message: __expectString(output.Message),
        TypeName: __expectString(output.TypeName),
    };
};
const de_InvalidKeyId = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_InvalidNextToken = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidNotificationConfig = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidOptionException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidOutputFolder = (output, context) => {
    return {};
};
const de_InvalidOutputLocation = (output, context) => {
    return {};
};
const de_InvalidParameters = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidPermissionType = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidPluginName = (output, context) => {
    return {};
};
const de_InvalidPolicyAttributeException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_InvalidPolicyTypeException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_InvalidResourceId = (output, context) => {
    return {};
};
const de_InvalidResourceType = (output, context) => {
    return {};
};
const de_InvalidResultAttributeException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidRole = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidSchedule = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidTag = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidTarget = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidTargetMaps = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidTypeNameException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InvalidUpdate = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_InventoryDeletionsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_InventoryDeletionStatusItem(entry, context);
    });
    return retVal;
};
const de_InventoryDeletionStatusItem = (output, context) => {
    return {
        DeletionId: __expectString(output.DeletionId),
        DeletionStartTime: output.DeletionStartTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.DeletionStartTime)))
            : undefined,
        DeletionSummary: output.DeletionSummary != null ? de_InventoryDeletionSummary(output.DeletionSummary, context) : undefined,
        LastStatus: __expectString(output.LastStatus),
        LastStatusMessage: __expectString(output.LastStatusMessage),
        LastStatusUpdateTime: output.LastStatusUpdateTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastStatusUpdateTime)))
            : undefined,
        TypeName: __expectString(output.TypeName),
    };
};
const de_InventoryDeletionSummary = (output, context) => {
    return {
        RemainingCount: __expectInt32(output.RemainingCount),
        SummaryItems: output.SummaryItems != null ? de_InventoryDeletionSummaryItems(output.SummaryItems, context) : undefined,
        TotalCount: __expectInt32(output.TotalCount),
    };
};
const de_InventoryDeletionSummaryItem = (output, context) => {
    return {
        Count: __expectInt32(output.Count),
        RemainingCount: __expectInt32(output.RemainingCount),
        Version: __expectString(output.Version),
    };
};
const de_InventoryDeletionSummaryItems = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_InventoryDeletionSummaryItem(entry, context);
    });
    return retVal;
};
const de_InventoryItemAttribute = (output, context) => {
    return {
        DataType: __expectString(output.DataType),
        Name: __expectString(output.Name),
    };
};
const de_InventoryItemAttributeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_InventoryItemAttribute(entry, context);
    });
    return retVal;
};
const de_InventoryItemEntry = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const de_InventoryItemEntryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_InventoryItemEntry(entry, context);
    });
    return retVal;
};
const de_InventoryItemSchema = (output, context) => {
    return {
        Attributes: output.Attributes != null ? de_InventoryItemAttributeList(output.Attributes, context) : undefined,
        DisplayName: __expectString(output.DisplayName),
        TypeName: __expectString(output.TypeName),
        Version: __expectString(output.Version),
    };
};
const de_InventoryItemSchemaResultList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_InventoryItemSchema(entry, context);
    });
    return retVal;
};
const de_InventoryResultEntity = (output, context) => {
    return {
        Data: output.Data != null ? de_InventoryResultItemMap(output.Data, context) : undefined,
        Id: __expectString(output.Id),
    };
};
const de_InventoryResultEntityList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_InventoryResultEntity(entry, context);
    });
    return retVal;
};
const de_InventoryResultItem = (output, context) => {
    return {
        CaptureTime: __expectString(output.CaptureTime),
        Content: output.Content != null ? de_InventoryItemEntryList(output.Content, context) : undefined,
        ContentHash: __expectString(output.ContentHash),
        SchemaVersion: __expectString(output.SchemaVersion),
        TypeName: __expectString(output.TypeName),
    };
};
const de_InventoryResultItemMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_InventoryResultItem(value, context);
        return acc;
    }, {});
};
const de_InvocationDoesNotExist = (output, context) => {
    return {};
};
const de_ItemContentMismatchException = (output, context) => {
    return {
        Message: __expectString(output.Message),
        TypeName: __expectString(output.TypeName),
    };
};
const de_ItemSizeLimitExceededException = (output, context) => {
    return {
        Message: __expectString(output.Message),
        TypeName: __expectString(output.TypeName),
    };
};
const de_LabelParameterVersionResult = (output, context) => {
    return {
        InvalidLabels: output.InvalidLabels != null ? de_ParameterLabelList(output.InvalidLabels, context) : undefined,
        ParameterVersion: __expectLong(output.ParameterVersion),
    };
};
const de_ListAssociationsResult = (output, context) => {
    return {
        Associations: output.Associations != null ? de_AssociationList(output.Associations, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_ListAssociationVersionsResult = (output, context) => {
    return {
        AssociationVersions: output.AssociationVersions != null ? de_AssociationVersionList(output.AssociationVersions, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_ListCommandInvocationsResult = (output, context) => {
    return {
        CommandInvocations: output.CommandInvocations != null ? de_CommandInvocationList(output.CommandInvocations, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_ListCommandsResult = (output, context) => {
    return {
        Commands: output.Commands != null ? de_CommandList(output.Commands, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_ListComplianceItemsResult = (output, context) => {
    return {
        ComplianceItems: output.ComplianceItems != null ? de_ComplianceItemList(output.ComplianceItems, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_ListComplianceSummariesResult = (output, context) => {
    return {
        ComplianceSummaryItems: output.ComplianceSummaryItems != null
            ? de_ComplianceSummaryItemList(output.ComplianceSummaryItems, context)
            : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_ListDocumentMetadataHistoryResponse = (output, context) => {
    return {
        Author: __expectString(output.Author),
        DocumentVersion: __expectString(output.DocumentVersion),
        Metadata: output.Metadata != null ? de_DocumentMetadataResponseInfo(output.Metadata, context) : undefined,
        Name: __expectString(output.Name),
        NextToken: __expectString(output.NextToken),
    };
};
const de_ListDocumentsResult = (output, context) => {
    return {
        DocumentIdentifiers: output.DocumentIdentifiers != null ? de_DocumentIdentifierList(output.DocumentIdentifiers, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_ListDocumentVersionsResult = (output, context) => {
    return {
        DocumentVersions: output.DocumentVersions != null ? de_DocumentVersionList(output.DocumentVersions, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const de_ListInventoryEntriesResult = (output, context) => {
    return {
        CaptureTime: __expectString(output.CaptureTime),
        Entries: output.Entries != null ? de_InventoryItemEntryList(output.Entries, context) : undefined,
        InstanceId: __expectString(output.InstanceId),
        NextToken: __expectString(output.NextToken),
        SchemaVersion: __expectString(output.SchemaVersion),
        TypeName: __expectString(output.TypeName),
    };
};
const de_ListOpsItemEventsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Summaries: output.Summaries != null ? de_OpsItemEventSummaries(output.Summaries, context) : undefined,
    };
};
const de_ListOpsItemRelatedItemsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Summaries: output.Summaries != null ? de_OpsItemRelatedItemSummaries(output.Summaries, context) : undefined,
    };
};
const de_ListOpsMetadataResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        OpsMetadataList: output.OpsMetadataList != null ? de_OpsMetadataList(output.OpsMetadataList, context) : undefined,
    };
};
const de_ListResourceComplianceSummariesResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        ResourceComplianceSummaryItems: output.ResourceComplianceSummaryItems != null
            ? de_ResourceComplianceSummaryItemList(output.ResourceComplianceSummaryItems, context)
            : undefined,
    };
};
const de_ListResourceDataSyncResult = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        ResourceDataSyncItems: output.ResourceDataSyncItems != null
            ? de_ResourceDataSyncItemList(output.ResourceDataSyncItems, context)
            : undefined,
    };
};
const de_ListTagsForResourceResult = (output, context) => {
    return {
        TagList: output.TagList != null ? de_TagList(output.TagList, context) : undefined,
    };
};
const de_LoggingInfo = (output, context) => {
    return {
        S3BucketName: __expectString(output.S3BucketName),
        S3KeyPrefix: __expectString(output.S3KeyPrefix),
        S3Region: __expectString(output.S3Region),
    };
};
const de_MaintenanceWindowAutomationParameters = (output, context) => {
    return {
        DocumentVersion: __expectString(output.DocumentVersion),
        Parameters: output.Parameters != null ? de_AutomationParameterMap(output.Parameters, context) : undefined,
    };
};
const de_MaintenanceWindowExecution = (output, context) => {
    return {
        EndTime: output.EndTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.EndTime))) : undefined,
        StartTime: output.StartTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartTime))) : undefined,
        Status: __expectString(output.Status),
        StatusDetails: __expectString(output.StatusDetails),
        WindowExecutionId: __expectString(output.WindowExecutionId),
        WindowId: __expectString(output.WindowId),
    };
};
const de_MaintenanceWindowExecutionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_MaintenanceWindowExecution(entry, context);
    });
    return retVal;
};
const de_MaintenanceWindowExecutionTaskIdentity = (output, context) => {
    return {
        AlarmConfiguration: output.AlarmConfiguration != null ? de_AlarmConfiguration(output.AlarmConfiguration, context) : undefined,
        EndTime: output.EndTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.EndTime))) : undefined,
        StartTime: output.StartTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartTime))) : undefined,
        Status: __expectString(output.Status),
        StatusDetails: __expectString(output.StatusDetails),
        TaskArn: __expectString(output.TaskArn),
        TaskExecutionId: __expectString(output.TaskExecutionId),
        TaskType: __expectString(output.TaskType),
        TriggeredAlarms: output.TriggeredAlarms != null ? de_AlarmStateInformationList(output.TriggeredAlarms, context) : undefined,
        WindowExecutionId: __expectString(output.WindowExecutionId),
    };
};
const de_MaintenanceWindowExecutionTaskIdentityList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_MaintenanceWindowExecutionTaskIdentity(entry, context);
    });
    return retVal;
};
const de_MaintenanceWindowExecutionTaskIdList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_MaintenanceWindowExecutionTaskInvocationIdentity = (output, context) => {
    return {
        EndTime: output.EndTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.EndTime))) : undefined,
        ExecutionId: __expectString(output.ExecutionId),
        InvocationId: __expectString(output.InvocationId),
        OwnerInformation: __expectString(output.OwnerInformation),
        Parameters: __expectString(output.Parameters),
        StartTime: output.StartTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartTime))) : undefined,
        Status: __expectString(output.Status),
        StatusDetails: __expectString(output.StatusDetails),
        TaskExecutionId: __expectString(output.TaskExecutionId),
        TaskType: __expectString(output.TaskType),
        WindowExecutionId: __expectString(output.WindowExecutionId),
        WindowTargetId: __expectString(output.WindowTargetId),
    };
};
const de_MaintenanceWindowExecutionTaskInvocationIdentityList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_MaintenanceWindowExecutionTaskInvocationIdentity(entry, context);
    });
    return retVal;
};
const de_MaintenanceWindowIdentity = (output, context) => {
    return {
        Cutoff: __expectInt32(output.Cutoff),
        Description: __expectString(output.Description),
        Duration: __expectInt32(output.Duration),
        Enabled: __expectBoolean(output.Enabled),
        EndDate: __expectString(output.EndDate),
        Name: __expectString(output.Name),
        NextExecutionTime: __expectString(output.NextExecutionTime),
        Schedule: __expectString(output.Schedule),
        ScheduleOffset: __expectInt32(output.ScheduleOffset),
        ScheduleTimezone: __expectString(output.ScheduleTimezone),
        StartDate: __expectString(output.StartDate),
        WindowId: __expectString(output.WindowId),
    };
};
const de_MaintenanceWindowIdentityForTarget = (output, context) => {
    return {
        Name: __expectString(output.Name),
        WindowId: __expectString(output.WindowId),
    };
};
const de_MaintenanceWindowIdentityList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_MaintenanceWindowIdentity(entry, context);
    });
    return retVal;
};
const de_MaintenanceWindowLambdaParameters = (output, context) => {
    return {
        ClientContext: __expectString(output.ClientContext),
        Payload: output.Payload != null ? context.base64Decoder(output.Payload) : undefined,
        Qualifier: __expectString(output.Qualifier),
    };
};
const de_MaintenanceWindowRunCommandParameters = (output, context) => {
    return {
        CloudWatchOutputConfig: output.CloudWatchOutputConfig != null
            ? de_CloudWatchOutputConfig(output.CloudWatchOutputConfig, context)
            : undefined,
        Comment: __expectString(output.Comment),
        DocumentHash: __expectString(output.DocumentHash),
        DocumentHashType: __expectString(output.DocumentHashType),
        DocumentVersion: __expectString(output.DocumentVersion),
        NotificationConfig: output.NotificationConfig != null ? de_NotificationConfig(output.NotificationConfig, context) : undefined,
        OutputS3BucketName: __expectString(output.OutputS3BucketName),
        OutputS3KeyPrefix: __expectString(output.OutputS3KeyPrefix),
        Parameters: output.Parameters != null ? de_Parameters(output.Parameters, context) : undefined,
        ServiceRoleArn: __expectString(output.ServiceRoleArn),
        TimeoutSeconds: __expectInt32(output.TimeoutSeconds),
    };
};
const de_MaintenanceWindowsForTargetList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_MaintenanceWindowIdentityForTarget(entry, context);
    });
    return retVal;
};
const de_MaintenanceWindowStepFunctionsParameters = (output, context) => {
    return {
        Input: __expectString(output.Input),
        Name: __expectString(output.Name),
    };
};
const de_MaintenanceWindowTarget = (output, context) => {
    return {
        Description: __expectString(output.Description),
        Name: __expectString(output.Name),
        OwnerInformation: __expectString(output.OwnerInformation),
        ResourceType: __expectString(output.ResourceType),
        Targets: output.Targets != null ? de_Targets(output.Targets, context) : undefined,
        WindowId: __expectString(output.WindowId),
        WindowTargetId: __expectString(output.WindowTargetId),
    };
};
const de_MaintenanceWindowTargetList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_MaintenanceWindowTarget(entry, context);
    });
    return retVal;
};
const de_MaintenanceWindowTask = (output, context) => {
    return {
        AlarmConfiguration: output.AlarmConfiguration != null ? de_AlarmConfiguration(output.AlarmConfiguration, context) : undefined,
        CutoffBehavior: __expectString(output.CutoffBehavior),
        Description: __expectString(output.Description),
        LoggingInfo: output.LoggingInfo != null ? de_LoggingInfo(output.LoggingInfo, context) : undefined,
        MaxConcurrency: __expectString(output.MaxConcurrency),
        MaxErrors: __expectString(output.MaxErrors),
        Name: __expectString(output.Name),
        Priority: __expectInt32(output.Priority),
        ServiceRoleArn: __expectString(output.ServiceRoleArn),
        Targets: output.Targets != null ? de_Targets(output.Targets, context) : undefined,
        TaskArn: __expectString(output.TaskArn),
        TaskParameters: output.TaskParameters != null ? de_MaintenanceWindowTaskParameters(output.TaskParameters, context) : undefined,
        Type: __expectString(output.Type),
        WindowId: __expectString(output.WindowId),
        WindowTaskId: __expectString(output.WindowTaskId),
    };
};
const de_MaintenanceWindowTaskInvocationParameters = (output, context) => {
    return {
        Automation: output.Automation != null ? de_MaintenanceWindowAutomationParameters(output.Automation, context) : undefined,
        Lambda: output.Lambda != null ? de_MaintenanceWindowLambdaParameters(output.Lambda, context) : undefined,
        RunCommand: output.RunCommand != null ? de_MaintenanceWindowRunCommandParameters(output.RunCommand, context) : undefined,
        StepFunctions: output.StepFunctions != null
            ? de_MaintenanceWindowStepFunctionsParameters(output.StepFunctions, context)
            : undefined,
    };
};
const de_MaintenanceWindowTaskList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_MaintenanceWindowTask(entry, context);
    });
    return retVal;
};
const de_MaintenanceWindowTaskParameters = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_MaintenanceWindowTaskParameterValueExpression(value, context);
        return acc;
    }, {});
};
const de_MaintenanceWindowTaskParametersList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_MaintenanceWindowTaskParameters(entry, context);
    });
    return retVal;
};
const de_MaintenanceWindowTaskParameterValueExpression = (output, context) => {
    return {
        Values: output.Values != null ? de_MaintenanceWindowTaskParameterValueList(output.Values, context) : undefined,
    };
};
const de_MaintenanceWindowTaskParameterValueList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_MaxDocumentSizeExceeded = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_MetadataMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_MetadataValue(value, context);
        return acc;
    }, {});
};
const de_MetadataValue = (output, context) => {
    return {
        Value: __expectString(output.Value),
    };
};
const de_ModifyDocumentPermissionResponse = (output, context) => {
    return {};
};
const de_NonCompliantSummary = (output, context) => {
    return {
        NonCompliantCount: __expectInt32(output.NonCompliantCount),
        SeveritySummary: output.SeveritySummary != null ? de_SeveritySummary(output.SeveritySummary, context) : undefined,
    };
};
const de_NormalStringMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const de_NotificationConfig = (output, context) => {
    return {
        NotificationArn: __expectString(output.NotificationArn),
        NotificationEvents: output.NotificationEvents != null ? de_NotificationEventList(output.NotificationEvents, context) : undefined,
        NotificationType: __expectString(output.NotificationType),
    };
};
const de_NotificationEventList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_OpsEntity = (output, context) => {
    return {
        Data: output.Data != null ? de_OpsEntityItemMap(output.Data, context) : undefined,
        Id: __expectString(output.Id),
    };
};
const de_OpsEntityItem = (output, context) => {
    return {
        CaptureTime: __expectString(output.CaptureTime),
        Content: output.Content != null ? de_OpsEntityItemEntryList(output.Content, context) : undefined,
    };
};
const de_OpsEntityItemEntry = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const de_OpsEntityItemEntryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_OpsEntityItemEntry(entry, context);
    });
    return retVal;
};
const de_OpsEntityItemMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_OpsEntityItem(value, context);
        return acc;
    }, {});
};
const de_OpsEntityList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_OpsEntity(entry, context);
    });
    return retVal;
};
const de_OpsItem = (output, context) => {
    return {
        ActualEndTime: output.ActualEndTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ActualEndTime)))
            : undefined,
        ActualStartTime: output.ActualStartTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ActualStartTime)))
            : undefined,
        Category: __expectString(output.Category),
        CreatedBy: __expectString(output.CreatedBy),
        CreatedTime: output.CreatedTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedTime)))
            : undefined,
        Description: __expectString(output.Description),
        LastModifiedBy: __expectString(output.LastModifiedBy),
        LastModifiedTime: output.LastModifiedTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedTime)))
            : undefined,
        Notifications: output.Notifications != null ? de_OpsItemNotifications(output.Notifications, context) : undefined,
        OperationalData: output.OperationalData != null ? de_OpsItemOperationalData(output.OperationalData, context) : undefined,
        OpsItemArn: __expectString(output.OpsItemArn),
        OpsItemId: __expectString(output.OpsItemId),
        OpsItemType: __expectString(output.OpsItemType),
        PlannedEndTime: output.PlannedEndTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.PlannedEndTime)))
            : undefined,
        PlannedStartTime: output.PlannedStartTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.PlannedStartTime)))
            : undefined,
        Priority: __expectInt32(output.Priority),
        RelatedOpsItems: output.RelatedOpsItems != null ? de_RelatedOpsItems(output.RelatedOpsItems, context) : undefined,
        Severity: __expectString(output.Severity),
        Source: __expectString(output.Source),
        Status: __expectString(output.Status),
        Title: __expectString(output.Title),
        Version: __expectString(output.Version),
    };
};
const de_OpsItemAccessDeniedException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_OpsItemAlreadyExistsException = (output, context) => {
    return {
        Message: __expectString(output.Message),
        OpsItemId: __expectString(output.OpsItemId),
    };
};
const de_OpsItemDataValue = (output, context) => {
    return {
        Type: __expectString(output.Type),
        Value: __expectString(output.Value),
    };
};
const de_OpsItemEventSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_OpsItemEventSummary(entry, context);
    });
    return retVal;
};
const de_OpsItemEventSummary = (output, context) => {
    return {
        CreatedBy: output.CreatedBy != null ? de_OpsItemIdentity(output.CreatedBy, context) : undefined,
        CreatedTime: output.CreatedTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedTime)))
            : undefined,
        Detail: __expectString(output.Detail),
        DetailType: __expectString(output.DetailType),
        EventId: __expectString(output.EventId),
        OpsItemId: __expectString(output.OpsItemId),
        Source: __expectString(output.Source),
    };
};
const de_OpsItemIdentity = (output, context) => {
    return {
        Arn: __expectString(output.Arn),
    };
};
const de_OpsItemInvalidParameterException = (output, context) => {
    return {
        Message: __expectString(output.Message),
        ParameterNames: output.ParameterNames != null ? de_OpsItemParameterNamesList(output.ParameterNames, context) : undefined,
    };
};
const de_OpsItemLimitExceededException = (output, context) => {
    return {
        Limit: __expectInt32(output.Limit),
        LimitType: __expectString(output.LimitType),
        Message: __expectString(output.Message),
        ResourceTypes: output.ResourceTypes != null ? de_OpsItemParameterNamesList(output.ResourceTypes, context) : undefined,
    };
};
const de_OpsItemNotFoundException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_OpsItemNotification = (output, context) => {
    return {
        Arn: __expectString(output.Arn),
    };
};
const de_OpsItemNotifications = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_OpsItemNotification(entry, context);
    });
    return retVal;
};
const de_OpsItemOperationalData = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_OpsItemDataValue(value, context);
        return acc;
    }, {});
};
const de_OpsItemParameterNamesList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_OpsItemRelatedItemAlreadyExistsException = (output, context) => {
    return {
        Message: __expectString(output.Message),
        OpsItemId: __expectString(output.OpsItemId),
        ResourceUri: __expectString(output.ResourceUri),
    };
};
const de_OpsItemRelatedItemAssociationNotFoundException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_OpsItemRelatedItemSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_OpsItemRelatedItemSummary(entry, context);
    });
    return retVal;
};
const de_OpsItemRelatedItemSummary = (output, context) => {
    return {
        AssociationId: __expectString(output.AssociationId),
        AssociationType: __expectString(output.AssociationType),
        CreatedBy: output.CreatedBy != null ? de_OpsItemIdentity(output.CreatedBy, context) : undefined,
        CreatedTime: output.CreatedTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedTime)))
            : undefined,
        LastModifiedBy: output.LastModifiedBy != null ? de_OpsItemIdentity(output.LastModifiedBy, context) : undefined,
        LastModifiedTime: output.LastModifiedTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedTime)))
            : undefined,
        OpsItemId: __expectString(output.OpsItemId),
        ResourceType: __expectString(output.ResourceType),
        ResourceUri: __expectString(output.ResourceUri),
    };
};
const de_OpsItemSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_OpsItemSummary(entry, context);
    });
    return retVal;
};
const de_OpsItemSummary = (output, context) => {
    return {
        ActualEndTime: output.ActualEndTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ActualEndTime)))
            : undefined,
        ActualStartTime: output.ActualStartTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ActualStartTime)))
            : undefined,
        Category: __expectString(output.Category),
        CreatedBy: __expectString(output.CreatedBy),
        CreatedTime: output.CreatedTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedTime)))
            : undefined,
        LastModifiedBy: __expectString(output.LastModifiedBy),
        LastModifiedTime: output.LastModifiedTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedTime)))
            : undefined,
        OperationalData: output.OperationalData != null ? de_OpsItemOperationalData(output.OperationalData, context) : undefined,
        OpsItemId: __expectString(output.OpsItemId),
        OpsItemType: __expectString(output.OpsItemType),
        PlannedEndTime: output.PlannedEndTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.PlannedEndTime)))
            : undefined,
        PlannedStartTime: output.PlannedStartTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.PlannedStartTime)))
            : undefined,
        Priority: __expectInt32(output.Priority),
        Severity: __expectString(output.Severity),
        Source: __expectString(output.Source),
        Status: __expectString(output.Status),
        Title: __expectString(output.Title),
    };
};
const de_OpsMetadata = (output, context) => {
    return {
        CreationDate: output.CreationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationDate)))
            : undefined,
        LastModifiedDate: output.LastModifiedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedDate)))
            : undefined,
        LastModifiedUser: __expectString(output.LastModifiedUser),
        OpsMetadataArn: __expectString(output.OpsMetadataArn),
        ResourceId: __expectString(output.ResourceId),
    };
};
const de_OpsMetadataAlreadyExistsException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_OpsMetadataInvalidArgumentException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_OpsMetadataKeyLimitExceededException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_OpsMetadataLimitExceededException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_OpsMetadataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_OpsMetadata(entry, context);
    });
    return retVal;
};
const de_OpsMetadataNotFoundException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_OpsMetadataTooManyUpdatesException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_OutputSource = (output, context) => {
    return {
        OutputSourceId: __expectString(output.OutputSourceId),
        OutputSourceType: __expectString(output.OutputSourceType),
    };
};
const de_Parameter = (output, context) => {
    return {
        ARN: __expectString(output.ARN),
        DataType: __expectString(output.DataType),
        LastModifiedDate: output.LastModifiedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedDate)))
            : undefined,
        Name: __expectString(output.Name),
        Selector: __expectString(output.Selector),
        SourceResult: __expectString(output.SourceResult),
        Type: __expectString(output.Type),
        Value: __expectString(output.Value),
        Version: __expectLong(output.Version),
    };
};
const de_ParameterAlreadyExists = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_ParameterHistory = (output, context) => {
    return {
        AllowedPattern: __expectString(output.AllowedPattern),
        DataType: __expectString(output.DataType),
        Description: __expectString(output.Description),
        KeyId: __expectString(output.KeyId),
        Labels: output.Labels != null ? de_ParameterLabelList(output.Labels, context) : undefined,
        LastModifiedDate: output.LastModifiedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedDate)))
            : undefined,
        LastModifiedUser: __expectString(output.LastModifiedUser),
        Name: __expectString(output.Name),
        Policies: output.Policies != null ? de_ParameterPolicyList(output.Policies, context) : undefined,
        Tier: __expectString(output.Tier),
        Type: __expectString(output.Type),
        Value: __expectString(output.Value),
        Version: __expectLong(output.Version),
    };
};
const de_ParameterHistoryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ParameterHistory(entry, context);
    });
    return retVal;
};
const de_ParameterInlinePolicy = (output, context) => {
    return {
        PolicyStatus: __expectString(output.PolicyStatus),
        PolicyText: __expectString(output.PolicyText),
        PolicyType: __expectString(output.PolicyType),
    };
};
const de_ParameterLabelList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_ParameterLimitExceeded = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_ParameterList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_Parameter(entry, context);
    });
    return retVal;
};
const de_ParameterMaxVersionLimitExceeded = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_ParameterMetadata = (output, context) => {
    return {
        AllowedPattern: __expectString(output.AllowedPattern),
        DataType: __expectString(output.DataType),
        Description: __expectString(output.Description),
        KeyId: __expectString(output.KeyId),
        LastModifiedDate: output.LastModifiedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedDate)))
            : undefined,
        LastModifiedUser: __expectString(output.LastModifiedUser),
        Name: __expectString(output.Name),
        Policies: output.Policies != null ? de_ParameterPolicyList(output.Policies, context) : undefined,
        Tier: __expectString(output.Tier),
        Type: __expectString(output.Type),
        Version: __expectLong(output.Version),
    };
};
const de_ParameterMetadataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ParameterMetadata(entry, context);
    });
    return retVal;
};
const de_ParameterNameList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_ParameterNotFound = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_ParameterPatternMismatchException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_ParameterPolicyList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ParameterInlinePolicy(entry, context);
    });
    return retVal;
};
const de_Parameters = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_ParameterValueList(value, context);
        return acc;
    }, {});
};
const de_ParameterValueList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_ParameterVersionLabelLimitExceeded = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_ParameterVersionNotFound = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_Patch = (output, context) => {
    return {
        AdvisoryIds: output.AdvisoryIds != null ? de_PatchAdvisoryIdList(output.AdvisoryIds, context) : undefined,
        Arch: __expectString(output.Arch),
        BugzillaIds: output.BugzillaIds != null ? de_PatchBugzillaIdList(output.BugzillaIds, context) : undefined,
        CVEIds: output.CVEIds != null ? de_PatchCVEIdList(output.CVEIds, context) : undefined,
        Classification: __expectString(output.Classification),
        ContentUrl: __expectString(output.ContentUrl),
        Description: __expectString(output.Description),
        Epoch: __expectInt32(output.Epoch),
        Id: __expectString(output.Id),
        KbNumber: __expectString(output.KbNumber),
        Language: __expectString(output.Language),
        MsrcNumber: __expectString(output.MsrcNumber),
        MsrcSeverity: __expectString(output.MsrcSeverity),
        Name: __expectString(output.Name),
        Product: __expectString(output.Product),
        ProductFamily: __expectString(output.ProductFamily),
        Release: __expectString(output.Release),
        ReleaseDate: output.ReleaseDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ReleaseDate)))
            : undefined,
        Repository: __expectString(output.Repository),
        Severity: __expectString(output.Severity),
        Title: __expectString(output.Title),
        Vendor: __expectString(output.Vendor),
        Version: __expectString(output.Version),
    };
};
const de_PatchAdvisoryIdList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_PatchBaselineIdentity = (output, context) => {
    return {
        BaselineDescription: __expectString(output.BaselineDescription),
        BaselineId: __expectString(output.BaselineId),
        BaselineName: __expectString(output.BaselineName),
        DefaultBaseline: __expectBoolean(output.DefaultBaseline),
        OperatingSystem: __expectString(output.OperatingSystem),
    };
};
const de_PatchBaselineIdentityList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_PatchBaselineIdentity(entry, context);
    });
    return retVal;
};
const de_PatchBugzillaIdList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_PatchComplianceData = (output, context) => {
    return {
        CVEIds: __expectString(output.CVEIds),
        Classification: __expectString(output.Classification),
        InstalledTime: output.InstalledTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.InstalledTime)))
            : undefined,
        KBId: __expectString(output.KBId),
        Severity: __expectString(output.Severity),
        State: __expectString(output.State),
        Title: __expectString(output.Title),
    };
};
const de_PatchComplianceDataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_PatchComplianceData(entry, context);
    });
    return retVal;
};
const de_PatchCVEIdList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_PatchFilter = (output, context) => {
    return {
        Key: __expectString(output.Key),
        Values: output.Values != null ? de_PatchFilterValueList(output.Values, context) : undefined,
    };
};
const de_PatchFilterGroup = (output, context) => {
    return {
        PatchFilters: output.PatchFilters != null ? de_PatchFilterList(output.PatchFilters, context) : undefined,
    };
};
const de_PatchFilterList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_PatchFilter(entry, context);
    });
    return retVal;
};
const de_PatchFilterValueList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_PatchGroupList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_PatchGroupPatchBaselineMapping = (output, context) => {
    return {
        BaselineIdentity: output.BaselineIdentity != null ? de_PatchBaselineIdentity(output.BaselineIdentity, context) : undefined,
        PatchGroup: __expectString(output.PatchGroup),
    };
};
const de_PatchGroupPatchBaselineMappingList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_PatchGroupPatchBaselineMapping(entry, context);
    });
    return retVal;
};
const de_PatchIdList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_PatchList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_Patch(entry, context);
    });
    return retVal;
};
const de_PatchPropertiesList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_PatchPropertyEntry(entry, context);
    });
    return retVal;
};
const de_PatchPropertyEntry = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const de_PatchRule = (output, context) => {
    return {
        ApproveAfterDays: __expectInt32(output.ApproveAfterDays),
        ApproveUntilDate: __expectString(output.ApproveUntilDate),
        ComplianceLevel: __expectString(output.ComplianceLevel),
        EnableNonSecurity: __expectBoolean(output.EnableNonSecurity),
        PatchFilterGroup: output.PatchFilterGroup != null ? de_PatchFilterGroup(output.PatchFilterGroup, context) : undefined,
    };
};
const de_PatchRuleGroup = (output, context) => {
    return {
        PatchRules: output.PatchRules != null ? de_PatchRuleList(output.PatchRules, context) : undefined,
    };
};
const de_PatchRuleList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_PatchRule(entry, context);
    });
    return retVal;
};
const de_PatchSource = (output, context) => {
    return {
        Configuration: __expectString(output.Configuration),
        Name: __expectString(output.Name),
        Products: output.Products != null ? de_PatchSourceProductList(output.Products, context) : undefined,
    };
};
const de_PatchSourceList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_PatchSource(entry, context);
    });
    return retVal;
};
const de_PatchSourceProductList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_PatchStatus = (output, context) => {
    return {
        ApprovalDate: output.ApprovalDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ApprovalDate)))
            : undefined,
        ComplianceLevel: __expectString(output.ComplianceLevel),
        DeploymentStatus: __expectString(output.DeploymentStatus),
    };
};
const de_PlatformTypeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_PoliciesLimitExceededException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_ProgressCounters = (output, context) => {
    return {
        CancelledSteps: __expectInt32(output.CancelledSteps),
        FailedSteps: __expectInt32(output.FailedSteps),
        SuccessSteps: __expectInt32(output.SuccessSteps),
        TimedOutSteps: __expectInt32(output.TimedOutSteps),
        TotalSteps: __expectInt32(output.TotalSteps),
    };
};
const de_PutComplianceItemsResult = (output, context) => {
    return {};
};
const de_PutInventoryResult = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_PutParameterResult = (output, context) => {
    return {
        Tier: __expectString(output.Tier),
        Version: __expectLong(output.Version),
    };
};
const de_PutResourcePolicyResponse = (output, context) => {
    return {
        PolicyHash: __expectString(output.PolicyHash),
        PolicyId: __expectString(output.PolicyId),
    };
};
const de_Regions = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_RegisterDefaultPatchBaselineResult = (output, context) => {
    return {
        BaselineId: __expectString(output.BaselineId),
    };
};
const de_RegisterPatchBaselineForPatchGroupResult = (output, context) => {
    return {
        BaselineId: __expectString(output.BaselineId),
        PatchGroup: __expectString(output.PatchGroup),
    };
};
const de_RegisterTargetWithMaintenanceWindowResult = (output, context) => {
    return {
        WindowTargetId: __expectString(output.WindowTargetId),
    };
};
const de_RegisterTaskWithMaintenanceWindowResult = (output, context) => {
    return {
        WindowTaskId: __expectString(output.WindowTaskId),
    };
};
const de_RelatedOpsItem = (output, context) => {
    return {
        OpsItemId: __expectString(output.OpsItemId),
    };
};
const de_RelatedOpsItems = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_RelatedOpsItem(entry, context);
    });
    return retVal;
};
const de_RemoveTagsFromResourceResult = (output, context) => {
    return {};
};
const de_ResetServiceSettingResult = (output, context) => {
    return {
        ServiceSetting: output.ServiceSetting != null ? de_ServiceSetting(output.ServiceSetting, context) : undefined,
    };
};
const de_ResolvedTargets = (output, context) => {
    return {
        ParameterValues: output.ParameterValues != null ? de_TargetParameterList(output.ParameterValues, context) : undefined,
        Truncated: __expectBoolean(output.Truncated),
    };
};
const de_ResourceComplianceSummaryItem = (output, context) => {
    return {
        ComplianceType: __expectString(output.ComplianceType),
        CompliantSummary: output.CompliantSummary != null ? de_CompliantSummary(output.CompliantSummary, context) : undefined,
        ExecutionSummary: output.ExecutionSummary != null ? de_ComplianceExecutionSummary(output.ExecutionSummary, context) : undefined,
        NonCompliantSummary: output.NonCompliantSummary != null ? de_NonCompliantSummary(output.NonCompliantSummary, context) : undefined,
        OverallSeverity: __expectString(output.OverallSeverity),
        ResourceId: __expectString(output.ResourceId),
        ResourceType: __expectString(output.ResourceType),
        Status: __expectString(output.Status),
    };
};
const de_ResourceComplianceSummaryItemList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ResourceComplianceSummaryItem(entry, context);
    });
    return retVal;
};
const de_ResourceDataSyncAlreadyExistsException = (output, context) => {
    return {
        SyncName: __expectString(output.SyncName),
    };
};
const de_ResourceDataSyncAwsOrganizationsSource = (output, context) => {
    return {
        OrganizationSourceType: __expectString(output.OrganizationSourceType),
        OrganizationalUnits: output.OrganizationalUnits != null
            ? de_ResourceDataSyncOrganizationalUnitList(output.OrganizationalUnits, context)
            : undefined,
    };
};
const de_ResourceDataSyncConflictException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_ResourceDataSyncCountExceededException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_ResourceDataSyncDestinationDataSharing = (output, context) => {
    return {
        DestinationDataSharingType: __expectString(output.DestinationDataSharingType),
    };
};
const de_ResourceDataSyncInvalidConfigurationException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_ResourceDataSyncItem = (output, context) => {
    return {
        LastStatus: __expectString(output.LastStatus),
        LastSuccessfulSyncTime: output.LastSuccessfulSyncTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastSuccessfulSyncTime)))
            : undefined,
        LastSyncStatusMessage: __expectString(output.LastSyncStatusMessage),
        LastSyncTime: output.LastSyncTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastSyncTime)))
            : undefined,
        S3Destination: output.S3Destination != null ? de_ResourceDataSyncS3Destination(output.S3Destination, context) : undefined,
        SyncCreatedTime: output.SyncCreatedTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.SyncCreatedTime)))
            : undefined,
        SyncLastModifiedTime: output.SyncLastModifiedTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.SyncLastModifiedTime)))
            : undefined,
        SyncName: __expectString(output.SyncName),
        SyncSource: output.SyncSource != null ? de_ResourceDataSyncSourceWithState(output.SyncSource, context) : undefined,
        SyncType: __expectString(output.SyncType),
    };
};
const de_ResourceDataSyncItemList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ResourceDataSyncItem(entry, context);
    });
    return retVal;
};
const de_ResourceDataSyncNotFoundException = (output, context) => {
    return {
        Message: __expectString(output.Message),
        SyncName: __expectString(output.SyncName),
        SyncType: __expectString(output.SyncType),
    };
};
const de_ResourceDataSyncOrganizationalUnit = (output, context) => {
    return {
        OrganizationalUnitId: __expectString(output.OrganizationalUnitId),
    };
};
const de_ResourceDataSyncOrganizationalUnitList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ResourceDataSyncOrganizationalUnit(entry, context);
    });
    return retVal;
};
const de_ResourceDataSyncS3Destination = (output, context) => {
    return {
        AWSKMSKeyARN: __expectString(output.AWSKMSKeyARN),
        BucketName: __expectString(output.BucketName),
        DestinationDataSharing: output.DestinationDataSharing != null
            ? de_ResourceDataSyncDestinationDataSharing(output.DestinationDataSharing, context)
            : undefined,
        Prefix: __expectString(output.Prefix),
        Region: __expectString(output.Region),
        SyncFormat: __expectString(output.SyncFormat),
    };
};
const de_ResourceDataSyncSourceRegionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_ResourceDataSyncSourceWithState = (output, context) => {
    return {
        AwsOrganizationsSource: output.AwsOrganizationsSource != null
            ? de_ResourceDataSyncAwsOrganizationsSource(output.AwsOrganizationsSource, context)
            : undefined,
        EnableAllOpsDataSources: __expectBoolean(output.EnableAllOpsDataSources),
        IncludeFutureRegions: __expectBoolean(output.IncludeFutureRegions),
        SourceRegions: output.SourceRegions != null ? de_ResourceDataSyncSourceRegionList(output.SourceRegions, context) : undefined,
        SourceType: __expectString(output.SourceType),
        State: __expectString(output.State),
    };
};
const de_ResourceInUseException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_ResourceLimitExceededException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_ResourcePolicyConflictException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_ResourcePolicyInvalidParameterException = (output, context) => {
    return {
        Message: __expectString(output.Message),
        ParameterNames: output.ParameterNames != null ? de_ResourcePolicyParameterNamesList(output.ParameterNames, context) : undefined,
    };
};
const de_ResourcePolicyLimitExceededException = (output, context) => {
    return {
        Limit: __expectInt32(output.Limit),
        LimitType: __expectString(output.LimitType),
        Message: __expectString(output.Message),
    };
};
const de_ResourcePolicyParameterNamesList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_ResumeSessionResponse = (output, context) => {
    return {
        SessionId: __expectString(output.SessionId),
        StreamUrl: __expectString(output.StreamUrl),
        TokenValue: __expectString(output.TokenValue),
    };
};
const de_ReviewInformation = (output, context) => {
    return {
        ReviewedTime: output.ReviewedTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ReviewedTime)))
            : undefined,
        Reviewer: __expectString(output.Reviewer),
        Status: __expectString(output.Status),
    };
};
const de_ReviewInformationList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ReviewInformation(entry, context);
    });
    return retVal;
};
const de_Runbook = (output, context) => {
    return {
        DocumentName: __expectString(output.DocumentName),
        DocumentVersion: __expectString(output.DocumentVersion),
        MaxConcurrency: __expectString(output.MaxConcurrency),
        MaxErrors: __expectString(output.MaxErrors),
        Parameters: output.Parameters != null ? de_AutomationParameterMap(output.Parameters, context) : undefined,
        TargetLocations: output.TargetLocations != null ? de_TargetLocations(output.TargetLocations, context) : undefined,
        TargetMaps: output.TargetMaps != null ? de_TargetMaps(output.TargetMaps, context) : undefined,
        TargetParameterName: __expectString(output.TargetParameterName),
        Targets: output.Targets != null ? de_Targets(output.Targets, context) : undefined,
    };
};
const de_Runbooks = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_Runbook(entry, context);
    });
    return retVal;
};
const de_S3OutputLocation = (output, context) => {
    return {
        OutputS3BucketName: __expectString(output.OutputS3BucketName),
        OutputS3KeyPrefix: __expectString(output.OutputS3KeyPrefix),
        OutputS3Region: __expectString(output.OutputS3Region),
    };
};
const de_S3OutputUrl = (output, context) => {
    return {
        OutputUrl: __expectString(output.OutputUrl),
    };
};
const de_ScheduledWindowExecution = (output, context) => {
    return {
        ExecutionTime: __expectString(output.ExecutionTime),
        Name: __expectString(output.Name),
        WindowId: __expectString(output.WindowId),
    };
};
const de_ScheduledWindowExecutionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_ScheduledWindowExecution(entry, context);
    });
    return retVal;
};
const de_SendAutomationSignalResult = (output, context) => {
    return {};
};
const de_SendCommandResult = (output, context) => {
    return {
        Command: output.Command != null ? de_Command(output.Command, context) : undefined,
    };
};
const de_ServiceSetting = (output, context) => {
    return {
        ARN: __expectString(output.ARN),
        LastModifiedDate: output.LastModifiedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedDate)))
            : undefined,
        LastModifiedUser: __expectString(output.LastModifiedUser),
        SettingId: __expectString(output.SettingId),
        SettingValue: __expectString(output.SettingValue),
        Status: __expectString(output.Status),
    };
};
const de_ServiceSettingNotFound = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_Session = (output, context) => {
    return {
        Details: __expectString(output.Details),
        DocumentName: __expectString(output.DocumentName),
        EndDate: output.EndDate != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.EndDate))) : undefined,
        MaxSessionDuration: __expectString(output.MaxSessionDuration),
        OutputUrl: output.OutputUrl != null ? de_SessionManagerOutputUrl(output.OutputUrl, context) : undefined,
        Owner: __expectString(output.Owner),
        Reason: __expectString(output.Reason),
        SessionId: __expectString(output.SessionId),
        StartDate: output.StartDate != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartDate))) : undefined,
        Status: __expectString(output.Status),
        Target: __expectString(output.Target),
    };
};
const de_SessionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_Session(entry, context);
    });
    return retVal;
};
const de_SessionManagerOutputUrl = (output, context) => {
    return {
        CloudWatchOutputUrl: __expectString(output.CloudWatchOutputUrl),
        S3OutputUrl: __expectString(output.S3OutputUrl),
    };
};
const de_SeveritySummary = (output, context) => {
    return {
        CriticalCount: __expectInt32(output.CriticalCount),
        HighCount: __expectInt32(output.HighCount),
        InformationalCount: __expectInt32(output.InformationalCount),
        LowCount: __expectInt32(output.LowCount),
        MediumCount: __expectInt32(output.MediumCount),
        UnspecifiedCount: __expectInt32(output.UnspecifiedCount),
    };
};
const de_StartAssociationsOnceResult = (output, context) => {
    return {};
};
const de_StartAutomationExecutionResult = (output, context) => {
    return {
        AutomationExecutionId: __expectString(output.AutomationExecutionId),
    };
};
const de_StartChangeRequestExecutionResult = (output, context) => {
    return {
        AutomationExecutionId: __expectString(output.AutomationExecutionId),
    };
};
const de_StartSessionResponse = (output, context) => {
    return {
        SessionId: __expectString(output.SessionId),
        StreamUrl: __expectString(output.StreamUrl),
        TokenValue: __expectString(output.TokenValue),
    };
};
const de_StatusUnchanged = (output, context) => {
    return {};
};
const de_StepExecution = (output, context) => {
    return {
        Action: __expectString(output.Action),
        ExecutionEndTime: output.ExecutionEndTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ExecutionEndTime)))
            : undefined,
        ExecutionStartTime: output.ExecutionStartTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ExecutionStartTime)))
            : undefined,
        FailureDetails: output.FailureDetails != null ? de_FailureDetails(output.FailureDetails, context) : undefined,
        FailureMessage: __expectString(output.FailureMessage),
        Inputs: output.Inputs != null ? de_NormalStringMap(output.Inputs, context) : undefined,
        IsCritical: __expectBoolean(output.IsCritical),
        IsEnd: __expectBoolean(output.IsEnd),
        MaxAttempts: __expectInt32(output.MaxAttempts),
        NextStep: __expectString(output.NextStep),
        OnFailure: __expectString(output.OnFailure),
        Outputs: output.Outputs != null ? de_AutomationParameterMap(output.Outputs, context) : undefined,
        OverriddenParameters: output.OverriddenParameters != null ? de_AutomationParameterMap(output.OverriddenParameters, context) : undefined,
        Response: __expectString(output.Response),
        ResponseCode: __expectString(output.ResponseCode),
        StepExecutionId: __expectString(output.StepExecutionId),
        StepName: __expectString(output.StepName),
        StepStatus: __expectString(output.StepStatus),
        TargetLocation: output.TargetLocation != null ? de_TargetLocation(output.TargetLocation, context) : undefined,
        Targets: output.Targets != null ? de_Targets(output.Targets, context) : undefined,
        TimeoutSeconds: __expectLong(output.TimeoutSeconds),
        TriggeredAlarms: output.TriggeredAlarms != null ? de_AlarmStateInformationList(output.TriggeredAlarms, context) : undefined,
        ValidNextSteps: output.ValidNextSteps != null ? de_ValidNextStepList(output.ValidNextSteps, context) : undefined,
    };
};
const de_StepExecutionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_StepExecution(entry, context);
    });
    return retVal;
};
const de_StopAutomationExecutionResult = (output, context) => {
    return {};
};
const de_SubTypeCountLimitExceededException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_Tag = (output, context) => {
    return {
        Key: __expectString(output.Key),
        Value: __expectString(output.Value),
    };
};
const de_TagList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_Tag(entry, context);
    });
    return retVal;
};
const de_Target = (output, context) => {
    return {
        Key: __expectString(output.Key),
        Values: output.Values != null ? de_TargetValues(output.Values, context) : undefined,
    };
};
const de_TargetInUseException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_TargetLocation = (output, context) => {
    return {
        Accounts: output.Accounts != null ? de_Accounts(output.Accounts, context) : undefined,
        ExecutionRoleName: __expectString(output.ExecutionRoleName),
        Regions: output.Regions != null ? de_Regions(output.Regions, context) : undefined,
        TargetLocationAlarmConfiguration: output.TargetLocationAlarmConfiguration != null
            ? de_AlarmConfiguration(output.TargetLocationAlarmConfiguration, context)
            : undefined,
        TargetLocationMaxConcurrency: __expectString(output.TargetLocationMaxConcurrency),
        TargetLocationMaxErrors: __expectString(output.TargetLocationMaxErrors),
    };
};
const de_TargetLocations = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_TargetLocation(entry, context);
    });
    return retVal;
};
const de_TargetMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_TargetMapValueList(value, context);
        return acc;
    }, {});
};
const de_TargetMaps = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_TargetMap(entry, context);
    });
    return retVal;
};
const de_TargetMapValueList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_TargetNotConnected = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_TargetParameterList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_Targets = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return de_Target(entry, context);
    });
    return retVal;
};
const de_TargetValues = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const de_TerminateSessionResponse = (output, context) => {
    return {
        SessionId: __expectString(output.SessionId),
    };
};
const de_TooManyTagsError = (output, context) => {
    return {};
};
const de_TooManyUpdates = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_TotalSizeLimitExceededException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_UnlabelParameterVersionResult = (output, context) => {
    return {
        InvalidLabels: output.InvalidLabels != null ? de_ParameterLabelList(output.InvalidLabels, context) : undefined,
        RemovedLabels: output.RemovedLabels != null ? de_ParameterLabelList(output.RemovedLabels, context) : undefined,
    };
};
const de_UnsupportedCalendarException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_UnsupportedFeatureRequiredException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_UnsupportedInventoryItemContextException = (output, context) => {
    return {
        Message: __expectString(output.Message),
        TypeName: __expectString(output.TypeName),
    };
};
const de_UnsupportedInventorySchemaVersionException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_UnsupportedOperatingSystem = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_UnsupportedParameterType = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const de_UnsupportedPlatformType = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const de_UpdateAssociationResult = (output, context) => {
    return {
        AssociationDescription: output.AssociationDescription != null
            ? de_AssociationDescription(output.AssociationDescription, context)
            : undefined,
    };
};
const de_UpdateAssociationStatusResult = (output, context) => {
    return {
        AssociationDescription: output.AssociationDescription != null
            ? de_AssociationDescription(output.AssociationDescription, context)
            : undefined,
    };
};
const de_UpdateDocumentDefaultVersionResult = (output, context) => {
    return {
        Description: output.Description != null ? de_DocumentDefaultVersionDescription(output.Description, context) : undefined,
    };
};
const de_UpdateDocumentMetadataResponse = (output, context) => {
    return {};
};
const de_UpdateDocumentResult = (output, context) => {
    return {
        DocumentDescription: output.DocumentDescription != null ? de_DocumentDescription(output.DocumentDescription, context) : undefined,
    };
};
const de_UpdateMaintenanceWindowResult = (output, context) => {
    return {
        AllowUnassociatedTargets: __expectBoolean(output.AllowUnassociatedTargets),
        Cutoff: __expectInt32(output.Cutoff),
        Description: __expectString(output.Description),
        Duration: __expectInt32(output.Duration),
        Enabled: __expectBoolean(output.Enabled),
        EndDate: __expectString(output.EndDate),
        Name: __expectString(output.Name),
        Schedule: __expectString(output.Schedule),
        ScheduleOffset: __expectInt32(output.ScheduleOffset),
        ScheduleTimezone: __expectString(output.ScheduleTimezone),
        StartDate: __expectString(output.StartDate),
        WindowId: __expectString(output.WindowId),
    };
};
const de_UpdateMaintenanceWindowTargetResult = (output, context) => {
    return {
        Description: __expectString(output.Description),
        Name: __expectString(output.Name),
        OwnerInformation: __expectString(output.OwnerInformation),
        Targets: output.Targets != null ? de_Targets(output.Targets, context) : undefined,
        WindowId: __expectString(output.WindowId),
        WindowTargetId: __expectString(output.WindowTargetId),
    };
};
const de_UpdateMaintenanceWindowTaskResult = (output, context) => {
    return {
        AlarmConfiguration: output.AlarmConfiguration != null ? de_AlarmConfiguration(output.AlarmConfiguration, context) : undefined,
        CutoffBehavior: __expectString(output.CutoffBehavior),
        Description: __expectString(output.Description),
        LoggingInfo: output.LoggingInfo != null ? de_LoggingInfo(output.LoggingInfo, context) : undefined,
        MaxConcurrency: __expectString(output.MaxConcurrency),
        MaxErrors: __expectString(output.MaxErrors),
        Name: __expectString(output.Name),
        Priority: __expectInt32(output.Priority),
        ServiceRoleArn: __expectString(output.ServiceRoleArn),
        Targets: output.Targets != null ? de_Targets(output.Targets, context) : undefined,
        TaskArn: __expectString(output.TaskArn),
        TaskInvocationParameters: output.TaskInvocationParameters != null
            ? de_MaintenanceWindowTaskInvocationParameters(output.TaskInvocationParameters, context)
            : undefined,
        TaskParameters: output.TaskParameters != null ? de_MaintenanceWindowTaskParameters(output.TaskParameters, context) : undefined,
        WindowId: __expectString(output.WindowId),
        WindowTaskId: __expectString(output.WindowTaskId),
    };
};
const de_UpdateManagedInstanceRoleResult = (output, context) => {
    return {};
};
const de_UpdateOpsItemResponse = (output, context) => {
    return {};
};
const de_UpdateOpsMetadataResult = (output, context) => {
    return {
        OpsMetadataArn: __expectString(output.OpsMetadataArn),
    };
};
const de_UpdatePatchBaselineResult = (output, context) => {
    return {
        ApprovalRules: output.ApprovalRules != null ? de_PatchRuleGroup(output.ApprovalRules, context) : undefined,
        ApprovedPatches: output.ApprovedPatches != null ? de_PatchIdList(output.ApprovedPatches, context) : undefined,
        ApprovedPatchesComplianceLevel: __expectString(output.ApprovedPatchesComplianceLevel),
        ApprovedPatchesEnableNonSecurity: __expectBoolean(output.ApprovedPatchesEnableNonSecurity),
        BaselineId: __expectString(output.BaselineId),
        CreatedDate: output.CreatedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedDate)))
            : undefined,
        Description: __expectString(output.Description),
        GlobalFilters: output.GlobalFilters != null ? de_PatchFilterGroup(output.GlobalFilters, context) : undefined,
        ModifiedDate: output.ModifiedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ModifiedDate)))
            : undefined,
        Name: __expectString(output.Name),
        OperatingSystem: __expectString(output.OperatingSystem),
        RejectedPatches: output.RejectedPatches != null ? de_PatchIdList(output.RejectedPatches, context) : undefined,
        RejectedPatchesAction: __expectString(output.RejectedPatchesAction),
        Sources: output.Sources != null ? de_PatchSourceList(output.Sources, context) : undefined,
    };
};
const de_UpdateResourceDataSyncResult = (output, context) => {
    return {};
};
const de_UpdateServiceSettingResult = (output, context) => {
    return {};
};
const de_ValidNextStepList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
